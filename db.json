{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/uploads/avater.jpeg","path":"uploads/avater.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"fd27543297c6ba9e80ae6af4be10fb6922872d58","modified":1552570733000},{"_id":"source/CNAME","hash":"fbd9c88400f9ee0db1bae42cb708ed4b3de5f85a","modified":1552571229000},{"_id":"source/favicon.ico","hash":"795fe654c19cf00d899e9f929c5f2dd8b52a9ab7","modified":1552570733000},{"_id":"source/about/index.md","hash":"0dfda33077a3dc38d18cf04b5fdfa291126b4b5c","modified":1552570733000},{"_id":"source/categories/index.md","hash":"547a51031563abab7cfacb518306c2726b50724e","modified":1552570733000},{"_id":"source/tags/index.md","hash":"2c35c1fb03d6b397bccbcd09dcbf4a7e15515a55","modified":1552570733000},{"_id":"source/uploads/avater.jpeg","hash":"87357ae3dfb7e29d1d439eb5bd82d674430a4de9","modified":1552570733000},{"_id":"source/_posts/CSS/css实现垂直居中.md","hash":"0f2a7ce0e808f2b2f26a57c87b3a0ecc5be2ad81","modified":1552570733000},{"_id":"source/_posts/JS/javascript实现对象的深度克隆.md","hash":"32c60aeb425400fc4bbae87a52e0323875e40c5f","modified":1552570733000},{"_id":"source/_posts/JS/new操作到底做了什么.md","hash":"73b17a49dc9f4c5a011d22923687a6e4ea51b08a","modified":1552570733000},{"_id":"source/_posts/JS/原生js实现class筛选器.md","hash":"ba245f1233a5cc0329bd7d76ee44ced8c5f3ce7f","modified":1552570733000},{"_id":"source/_posts/个人成长/2017-01-13-plan.md","hash":"b0f21f4229d4ec84214b108454b7cd6843ec04b8","modified":1552570733000},{"_id":"source/_posts/个人成长/前端资料总结.md","hash":"fc893b56be13636eb3f8859fedd448bdf7f01201","modified":1552570733000},{"_id":"source/_posts/其他/gulp小白文.md","hash":"667b805d811a885f216508aa12ffe455c6d2c2ae","modified":1552570733000},{"_id":"source/_posts/前端面试题/前端面试题-第一套.md","hash":"38429626c7c6266598ad5c26797c50e1fd046eb8","modified":1552570733000},{"_id":"source/_posts/前端面试题/前端面试题-第二套.md","hash":"638ed4e8edad2e25938b06b410d9dbedd8b090ef","modified":1552570733000},{"_id":"source/_posts/性能优化/前端性能优化--学习总结.md","hash":"d48ce6048bf8407a139490df2afbe4b1b6e9a039","modified":1552570733000},{"_id":"source/_posts/版本控制/2017-02-13-git学习笔记.md","hash":"6927bbcd74c207b823c9993be0eac351a76d9c41","modified":1552570733000},{"_id":"source/_posts/网络/HTTP简介.md","hash":"4fd75d9cee6a1566419dcaf15190f16993bc6c8c","modified":1552570733000},{"_id":"public/404.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477429},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477429},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477429},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2019/03/JS/javascript实现对象的深度克隆.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/04/性能优化/前端性能优化--学习总结.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/03/JS/原生js实现class筛选器.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/03/CSS/css实现垂直居中.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/03/前端面试题/前端面试题-第一套.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/03/JS/new操作到底做了什么.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/03/其他/gulp小白文.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/02/网络/HTTP简介.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477430},{"_id":"public/2017/02/个人成长/前端资料总结.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477431},{"_id":"public/2017/02/版本控制/2017-02-13-git学习笔记.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477431},{"_id":"public/2017/02/前端面试题/前端面试题-第二套.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477431},{"_id":"public/2017/01/个人成长/2017-01-13-plan.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477431},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477431},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477431},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2017/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2017/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2017/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2017/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2017/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2017/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2019/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477432},{"_id":"public/archives/2019/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477433},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477433},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477433},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477433},{"_id":"public/categories/CSS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477433},{"_id":"public/categories/javascript/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/JS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/个人成长/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/其他/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/前端面试题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/HTML5学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/代码版本控制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/性能优化/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/categories/网络/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/tags/前端开发/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/tags/前端开发/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477434},{"_id":"public/tags/前端开发/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/个人成长/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/个人成长/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/CSS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/js实现对象的深度克隆/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/javascript/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/深度克隆/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/JS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/继承/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/前端资料总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/JavaScript、HTML、CSS、Node/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/其他/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477435},{"_id":"public/tags/自动化构建/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477436},{"_id":"public/tags/前端面试题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477436},{"_id":"public/tags/HTML5简介/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477436},{"_id":"public/tags/代码版本控制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477436},{"_id":"public/tags/git/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477436},{"_id":"public/tags/前端性能优化/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477436},{"_id":"public/tags/HTTP学习总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552833477436},{"_id":"public/CNAME","hash":"fbd9c88400f9ee0db1bae42cb708ed4b3de5f85a","modified":1552833477439},{"_id":"public/favicon.ico","hash":"795fe654c19cf00d899e9f929c5f2dd8b52a9ab7","modified":1552833477439},{"_id":"public/uploads/avater.jpeg","hash":"87357ae3dfb7e29d1d439eb5bd82d674430a4de9","modified":1552833477439}],"Category":[{"name":"CSS","_id":"cjtd0yj2j00069oxzykb16gbr"},{"name":"javascript","_id":"cjtd0yj2o000b9oxznc1mmxch"},{"name":"JS","_id":"cjtd0yj2x000g9oxzix4mh9ru"},{"name":"个人成长","_id":"cjtd0yj33000q9oxzl7krug0c"},{"name":"其他","_id":"cjtd0yj34000x9oxzimb1xjt1"},{"name":"前端面试题","_id":"cjtd0yj3500119oxz9vn4jv1f"},{"name":"HTML5学习笔记","_id":"cjtd0yj3600169oxzrzg4yato"},{"name":"代码版本控制","_id":"cjtd0yj37001c9oxzew4y4tcp"},{"name":"性能优化","_id":"cjtd0yj3j002h9oxzz7uveq8k"},{"name":"网络","_id":"cjtd0yj3m002o9oxzagj30h2z"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"https://xujiao1989.github.io/blog/\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"https://xujiao1989.github.io/blog/\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","date":"2019-03-14T13:38:53.000Z","updated":"2019-03-14T13:38:53.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjtd0yj2300009oxzmira8xgg","content":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"https://xujiao1989.github.io/blog/\" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"https://xujiao1989.github.io/blog/\" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n"},{"title":"麻将大神徐大胖！","date":"2017-01-13T11:51:53.000Z","type":"about","comments":0,"_content":"## 当我开始爱自己\n\n当我真正开始爱自己，\n我才认识到，所有的痛苦和情感的折磨，\n都只是提醒我：\n活着，不要违背自己的本心。\n今天我明白了，这叫做\n**『真实』。**\n\n当我真正开始爱自己，\n我才懂得，把自己的愿望强加于人，\n是多么的无礼，\n就算我知道，时机并不成熟，\n那人也还没有做好准备，\n就算那个人就是我自己，\n今天我明白了，这叫做\n\n**『尊重』。**\n\n当我开始爱自己，\n我不再渴求不同的人生，\n我知道任何发生在我身边的事情，\n都是对我成长的邀请。\n如今，我称之为\n\n**『成熟』。**\n\n当我开始真正爱自己，\n我才明白，我其实一直都在正确的时间，\n正确的地方，发生的一切都恰如其分。\n由此我得以平静。\n今天我明白了，这叫做\n\n**『自信』。**\n\n\n当我开始真正爱自己，\n我不再牺牲自己的自由时间，\n不再去勾画什么宏伟的明天。\n今天我只做有趣和快乐的事，\n做自己热爱，让心欢喜的事，\n用我的方式，以我的韵律。\n今天我明白了，这叫做\n\n**『单纯』。**\n\n当我开始真正爱自己，\n我开始远离一切不健康的东西。\n不论是饮食和人物，还是事情和环境，\n我远离一切让我远离本真的东西。\n从前我把这叫做\n“追求健康的自私自利”，\n但今天我明白了，这是\n\n**『自爱』。**\n\n当我开始真正爱自己，\n我不再总想着要永远正确，不犯错误。\n我今天明白了，这叫做\n\n**『谦逊』。**\n\n当我开始真正爱自己，\n我不再继续沉溺于过去，\n也不再为明天而忧虑，\n现在我只活在一切正在发生的当下，\n今天，我活在此时此地，\n如此日复一日。这就叫\n\n**『完美』。**\n\n\n当我开始真正爱自己，\n我明白，我的思虑让我变得贫乏和病态，\n但当我唤起了心灵的力量，\n理智就变成了一个重要的伙伴，\n这种组合我称之为，\n\n**『心的智慧』。**\n\n我们无须再害怕自己和他人的分歧，\n矛盾和问题，\n因为即使星星有时也会碰在一起，\n形成新的世界，\n今天我明白，这就是 **『生命』！**\n","source":"about/index.md","raw":"---\ntitle: 麻将大神徐大胖！\ndate: 2017-01-13 19:51:53\ntype: \"about\"\ncomments: false\n---\n## 当我开始爱自己\n\n当我真正开始爱自己，\n我才认识到，所有的痛苦和情感的折磨，\n都只是提醒我：\n活着，不要违背自己的本心。\n今天我明白了，这叫做\n**『真实』。**\n\n当我真正开始爱自己，\n我才懂得，把自己的愿望强加于人，\n是多么的无礼，\n就算我知道，时机并不成熟，\n那人也还没有做好准备，\n就算那个人就是我自己，\n今天我明白了，这叫做\n\n**『尊重』。**\n\n当我开始爱自己，\n我不再渴求不同的人生，\n我知道任何发生在我身边的事情，\n都是对我成长的邀请。\n如今，我称之为\n\n**『成熟』。**\n\n当我开始真正爱自己，\n我才明白，我其实一直都在正确的时间，\n正确的地方，发生的一切都恰如其分。\n由此我得以平静。\n今天我明白了，这叫做\n\n**『自信』。**\n\n\n当我开始真正爱自己，\n我不再牺牲自己的自由时间，\n不再去勾画什么宏伟的明天。\n今天我只做有趣和快乐的事，\n做自己热爱，让心欢喜的事，\n用我的方式，以我的韵律。\n今天我明白了，这叫做\n\n**『单纯』。**\n\n当我开始真正爱自己，\n我开始远离一切不健康的东西。\n不论是饮食和人物，还是事情和环境，\n我远离一切让我远离本真的东西。\n从前我把这叫做\n“追求健康的自私自利”，\n但今天我明白了，这是\n\n**『自爱』。**\n\n当我开始真正爱自己，\n我不再总想着要永远正确，不犯错误。\n我今天明白了，这叫做\n\n**『谦逊』。**\n\n当我开始真正爱自己，\n我不再继续沉溺于过去，\n也不再为明天而忧虑，\n现在我只活在一切正在发生的当下，\n今天，我活在此时此地，\n如此日复一日。这就叫\n\n**『完美』。**\n\n\n当我开始真正爱自己，\n我明白，我的思虑让我变得贫乏和病态，\n但当我唤起了心灵的力量，\n理智就变成了一个重要的伙伴，\n这种组合我称之为，\n\n**『心的智慧』。**\n\n我们无须再害怕自己和他人的分歧，\n矛盾和问题，\n因为即使星星有时也会碰在一起，\n形成新的世界，\n今天我明白，这就是 **『生命』！**\n","updated":"2019-03-14T13:38:53.000Z","path":"about/index.html","layout":"page","_id":"cjtd0yj2600019oxzm8sepwr7","content":"<h2 id=\"当我开始爱自己\"><a href=\"#当我开始爱自己\" class=\"headerlink\" title=\"当我开始爱自己\"></a>当我开始爱自己</h2><p>当我真正开始爱自己，<br>我才认识到，所有的痛苦和情感的折磨，<br>都只是提醒我：<br>活着，不要违背自己的本心。<br>今天我明白了，这叫做<br><strong>『真实』。</strong></p>\n<p>当我真正开始爱自己，<br>我才懂得，把自己的愿望强加于人，<br>是多么的无礼，<br>就算我知道，时机并不成熟，<br>那人也还没有做好准备，<br>就算那个人就是我自己，<br>今天我明白了，这叫做</p>\n<p><strong>『尊重』。</strong></p>\n<p>当我开始爱自己，<br>我不再渴求不同的人生，<br>我知道任何发生在我身边的事情，<br>都是对我成长的邀请。<br>如今，我称之为</p>\n<p><strong>『成熟』。</strong></p>\n<p>当我开始真正爱自己，<br>我才明白，我其实一直都在正确的时间，<br>正确的地方，发生的一切都恰如其分。<br>由此我得以平静。<br>今天我明白了，这叫做</p>\n<p><strong>『自信』。</strong></p>\n<p>当我开始真正爱自己，<br>我不再牺牲自己的自由时间，<br>不再去勾画什么宏伟的明天。<br>今天我只做有趣和快乐的事，<br>做自己热爱，让心欢喜的事，<br>用我的方式，以我的韵律。<br>今天我明白了，这叫做</p>\n<p><strong>『单纯』。</strong></p>\n<p>当我开始真正爱自己，<br>我开始远离一切不健康的东西。<br>不论是饮食和人物，还是事情和环境，<br>我远离一切让我远离本真的东西。<br>从前我把这叫做<br>“追求健康的自私自利”，<br>但今天我明白了，这是</p>\n<p><strong>『自爱』。</strong></p>\n<p>当我开始真正爱自己，<br>我不再总想着要永远正确，不犯错误。<br>我今天明白了，这叫做</p>\n<p><strong>『谦逊』。</strong></p>\n<p>当我开始真正爱自己，<br>我不再继续沉溺于过去，<br>也不再为明天而忧虑，<br>现在我只活在一切正在发生的当下，<br>今天，我活在此时此地，<br>如此日复一日。这就叫</p>\n<p><strong>『完美』。</strong></p>\n<p>当我开始真正爱自己，<br>我明白，我的思虑让我变得贫乏和病态，<br>但当我唤起了心灵的力量，<br>理智就变成了一个重要的伙伴，<br>这种组合我称之为，</p>\n<p><strong>『心的智慧』。</strong></p>\n<p>我们无须再害怕自己和他人的分歧，<br>矛盾和问题，<br>因为即使星星有时也会碰在一起，<br>形成新的世界，<br>今天我明白，这就是 <strong>『生命』！</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"当我开始爱自己\"><a href=\"#当我开始爱自己\" class=\"headerlink\" title=\"当我开始爱自己\"></a>当我开始爱自己</h2><p>当我真正开始爱自己，<br>我才认识到，所有的痛苦和情感的折磨，<br>都只是提醒我：<br>活着，不要违背自己的本心。<br>今天我明白了，这叫做<br><strong>『真实』。</strong></p>\n<p>当我真正开始爱自己，<br>我才懂得，把自己的愿望强加于人，<br>是多么的无礼，<br>就算我知道，时机并不成熟，<br>那人也还没有做好准备，<br>就算那个人就是我自己，<br>今天我明白了，这叫做</p>\n<p><strong>『尊重』。</strong></p>\n<p>当我开始爱自己，<br>我不再渴求不同的人生，<br>我知道任何发生在我身边的事情，<br>都是对我成长的邀请。<br>如今，我称之为</p>\n<p><strong>『成熟』。</strong></p>\n<p>当我开始真正爱自己，<br>我才明白，我其实一直都在正确的时间，<br>正确的地方，发生的一切都恰如其分。<br>由此我得以平静。<br>今天我明白了，这叫做</p>\n<p><strong>『自信』。</strong></p>\n<p>当我开始真正爱自己，<br>我不再牺牲自己的自由时间，<br>不再去勾画什么宏伟的明天。<br>今天我只做有趣和快乐的事，<br>做自己热爱，让心欢喜的事，<br>用我的方式，以我的韵律。<br>今天我明白了，这叫做</p>\n<p><strong>『单纯』。</strong></p>\n<p>当我开始真正爱自己，<br>我开始远离一切不健康的东西。<br>不论是饮食和人物，还是事情和环境，<br>我远离一切让我远离本真的东西。<br>从前我把这叫做<br>“追求健康的自私自利”，<br>但今天我明白了，这是</p>\n<p><strong>『自爱』。</strong></p>\n<p>当我开始真正爱自己，<br>我不再总想着要永远正确，不犯错误。<br>我今天明白了，这叫做</p>\n<p><strong>『谦逊』。</strong></p>\n<p>当我开始真正爱自己，<br>我不再继续沉溺于过去，<br>也不再为明天而忧虑，<br>现在我只活在一切正在发生的当下，<br>今天，我活在此时此地，<br>如此日复一日。这就叫</p>\n<p><strong>『完美』。</strong></p>\n<p>当我开始真正爱自己，<br>我明白，我的思虑让我变得贫乏和病态，<br>但当我唤起了心灵的力量，<br>理智就变成了一个重要的伙伴，<br>这种组合我称之为，</p>\n<p><strong>『心的智慧』。</strong></p>\n<p>我们无须再害怕自己和他人的分歧，<br>矛盾和问题，<br>因为即使星星有时也会碰在一起，<br>形成新的世界，<br>今天我明白，这就是 <strong>『生命』！</strong></p>\n"},{"title":"tags","date":"2017-01-13T11:47:58.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-01-13 19:47:58\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-03-14T13:38:53.000Z","path":"tags/index.html","layout":"page","_id":"cjtd0yj2700029oxzcsqray2c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-01-13T11:50:25.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-13 19:50:25\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-03-14T13:38:53.000Z","path":"categories/index.html","layout":"page","_id":"cjtd0yj2800039oxzmpoa9s7b","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"css实现垂直居中","date":"2017-03-27T16:00:00.000Z","_content":"\n\n## 1. 方法一（inline/inline-block配合vertical-align）\n\n这种方法应用于子元素都是inline/inline-block level的元素，可以使用vertical-align属性，兼容IE6+ 如果原本元素不是inline level的话，使用display:inline-block兼容到IE8+\n\n```html\n <div class=\"parent\">\n       <span class=\"con\">我是内容我是内容我是内容\n       </span>\n     <img class=\"con\" src=\"/images/csstest1.png\">\n     <img class=\"con\" src=\"/images/csstest1.png\">\n </div>\n```\n\n```css\n .parent{\n    background: #ccc;\n    line-height: 2;\n    font-size: 30px;\n}\n.con{\n    vertical-align: middle;\n}\n```\n根据上面的例子我们可以得到以下所示的样式\n\n![css垂直居中示例图1](/images/csstest1.PNG)\n\n在这里，span/img都是行内元素，我们可以采用vertical-align实现垂直居中。上面默认情况下，vertical-align是基于基线对其的。\n\n\n对于上面的例子，我们也可以对span设置display:inline-block属性，设置高宽后，可以做到span中任意内容的居中效果\n\n## 2.方法二（table-cell配合vertical-align）\n\n使用display:tabel-cell，table-cell也是可以使用vertical-align：middle使得元素垂直居中，但是display:table-cell有兼容性问题，兼容IE8+\n\n```html\n     <div class=\"parent\">\n         <div class=\"con\">这是第二个内容这是</div>\n     </div>\n```\n\n```css\n    .parent{\n        background: #ccc;\n        width: 200px;\n        height: 200px;\n        display: table-cell;\n        vertical-align: middle;\n    }\n    .con{\n        width:100px;\n        height:100px;\n        border: 2px solid red;\n    }\n```\n根据上面的例子我们可以得到以下所示的样式\n\n![css垂直居中示例图2](/images/csstest2.PNG)\n\n这里需要注意的是table-cell设置需要设置在父元素上保证其内容垂直居中，如果你希望con中的文字也居中现在，也可以对con添加上`display: table-cell;vertical-align: middle;`。为什么没有line-height。line-height对多行文本的垂直居中实现效果并不是很好\n\n+ 兼容性：IE6/7不兼容display:table-cell。\n+ 自适应：子容器无法自适应于父容器，高度无法使用百分比单位，因为根据渲染规则，display:table-cell的元素的包含块是它父级的display:table的元素。溢出：父元素就算给定高度，设置overflow，也不会导致溢出隐藏；在子元素溢出的时候，父容器不能保有自身设置的高度，直接会被撑高。\n+ 其他：display:table-cell本身让很多属性无效。\n\n## 3. 方法三：（position:absolute来实现）--不兼容IE6/7\n\n```HTML\n    <div class=\"parent\">\n        <div class=\"con\">这是第二个内容这是</div>\n    </div>\n```\n\n利用position：absolute如何保证con始终在parent的中心位置。\n\n```css\n    .parent{\n        background: #ccc;\n        width: 300px;\n        height: 300px;\n        position: relative;\n    }\n    .con{\n        height:140px;\n        width:70%;\n        background: yellow;\n        position: absolute;\n        top:0;\n        bottom:0;\n        left:0;\n        right:0;\n        margin: auto;\n    }\n```\n![css垂直居中示例图3](/images/csstest3.PNG)\n\n我们经常使用margin:0 auto使得块级元素水平居中。这里`position: absolute; top:0;bottom:0;left:0;right: 0;`的作用是什么，如果我们把这个删除了，可以发现原生con是水平居中了，在垂直方向上没有生效，这是为什么？？\n\n原理是：\n‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度。\n\n\n## 4. 子容器绝对定位，top:50%，负margin（兼容IE6+）\n\n要求子元素定高\n\n```HTML\n    <div class=\"parent\">\n        <div class=\"con\">这是第二个内容这是</div>\n    </div>\n```\n\n```css\n    .parent{\n        background: #ccc;\n        width: 300px;\n        height: 300px;\n        position: relative;\n    }\n    .con{\n        width:140px;\n        height:140px;\n        background: yellow;\n        position: absolute;\n        top:50%;\n        margin-top: -70px;\n    }\n```\n\n![css垂直居中示例图4](/images/csstest4.PNG)\n\n## 5. 参考文章\n\n+ [张鑫旭的深入理解CSS系列](http://www.imooc.com/u/197450/courses?sort=publish)\n+ [子容器垂直居中于父容器的方案](https://segmentfault.com/a/1190000000381042)\n+ [子容器超过父容器如何垂直居中](https://segmentfault.com/q/1010000000343188#a-1020000000343394)\n---\n做一个勤于思考的人\n","source":"_posts/CSS/css实现垂直居中.md","raw":"---\ntitle: css实现垂直居中\ndate: 2017-03-28\ntags:\n  - 前端开发\n  - 个人成长\n  - CSS\ncategories: CSS\n---\n\n\n## 1. 方法一（inline/inline-block配合vertical-align）\n\n这种方法应用于子元素都是inline/inline-block level的元素，可以使用vertical-align属性，兼容IE6+ 如果原本元素不是inline level的话，使用display:inline-block兼容到IE8+\n\n```html\n <div class=\"parent\">\n       <span class=\"con\">我是内容我是内容我是内容\n       </span>\n     <img class=\"con\" src=\"/images/csstest1.png\">\n     <img class=\"con\" src=\"/images/csstest1.png\">\n </div>\n```\n\n```css\n .parent{\n    background: #ccc;\n    line-height: 2;\n    font-size: 30px;\n}\n.con{\n    vertical-align: middle;\n}\n```\n根据上面的例子我们可以得到以下所示的样式\n\n![css垂直居中示例图1](/images/csstest1.PNG)\n\n在这里，span/img都是行内元素，我们可以采用vertical-align实现垂直居中。上面默认情况下，vertical-align是基于基线对其的。\n\n\n对于上面的例子，我们也可以对span设置display:inline-block属性，设置高宽后，可以做到span中任意内容的居中效果\n\n## 2.方法二（table-cell配合vertical-align）\n\n使用display:tabel-cell，table-cell也是可以使用vertical-align：middle使得元素垂直居中，但是display:table-cell有兼容性问题，兼容IE8+\n\n```html\n     <div class=\"parent\">\n         <div class=\"con\">这是第二个内容这是</div>\n     </div>\n```\n\n```css\n    .parent{\n        background: #ccc;\n        width: 200px;\n        height: 200px;\n        display: table-cell;\n        vertical-align: middle;\n    }\n    .con{\n        width:100px;\n        height:100px;\n        border: 2px solid red;\n    }\n```\n根据上面的例子我们可以得到以下所示的样式\n\n![css垂直居中示例图2](/images/csstest2.PNG)\n\n这里需要注意的是table-cell设置需要设置在父元素上保证其内容垂直居中，如果你希望con中的文字也居中现在，也可以对con添加上`display: table-cell;vertical-align: middle;`。为什么没有line-height。line-height对多行文本的垂直居中实现效果并不是很好\n\n+ 兼容性：IE6/7不兼容display:table-cell。\n+ 自适应：子容器无法自适应于父容器，高度无法使用百分比单位，因为根据渲染规则，display:table-cell的元素的包含块是它父级的display:table的元素。溢出：父元素就算给定高度，设置overflow，也不会导致溢出隐藏；在子元素溢出的时候，父容器不能保有自身设置的高度，直接会被撑高。\n+ 其他：display:table-cell本身让很多属性无效。\n\n## 3. 方法三：（position:absolute来实现）--不兼容IE6/7\n\n```HTML\n    <div class=\"parent\">\n        <div class=\"con\">这是第二个内容这是</div>\n    </div>\n```\n\n利用position：absolute如何保证con始终在parent的中心位置。\n\n```css\n    .parent{\n        background: #ccc;\n        width: 300px;\n        height: 300px;\n        position: relative;\n    }\n    .con{\n        height:140px;\n        width:70%;\n        background: yellow;\n        position: absolute;\n        top:0;\n        bottom:0;\n        left:0;\n        right:0;\n        margin: auto;\n    }\n```\n![css垂直居中示例图3](/images/csstest3.PNG)\n\n我们经常使用margin:0 auto使得块级元素水平居中。这里`position: absolute; top:0;bottom:0;left:0;right: 0;`的作用是什么，如果我们把这个删除了，可以发现原生con是水平居中了，在垂直方向上没有生效，这是为什么？？\n\n原理是：\n‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度。\n\n\n## 4. 子容器绝对定位，top:50%，负margin（兼容IE6+）\n\n要求子元素定高\n\n```HTML\n    <div class=\"parent\">\n        <div class=\"con\">这是第二个内容这是</div>\n    </div>\n```\n\n```css\n    .parent{\n        background: #ccc;\n        width: 300px;\n        height: 300px;\n        position: relative;\n    }\n    .con{\n        width:140px;\n        height:140px;\n        background: yellow;\n        position: absolute;\n        top:50%;\n        margin-top: -70px;\n    }\n```\n\n![css垂直居中示例图4](/images/csstest4.PNG)\n\n## 5. 参考文章\n\n+ [张鑫旭的深入理解CSS系列](http://www.imooc.com/u/197450/courses?sort=publish)\n+ [子容器垂直居中于父容器的方案](https://segmentfault.com/a/1190000000381042)\n+ [子容器超过父容器如何垂直居中](https://segmentfault.com/q/1010000000343188#a-1020000000343394)\n---\n做一个勤于思考的人\n","slug":"CSS/css实现垂直居中","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2e00049oxzqm8rz85l","content":"<h2 id=\"1-方法一（inline-inline-block配合vertical-align）\"><a href=\"#1-方法一（inline-inline-block配合vertical-align）\" class=\"headerlink\" title=\"1. 方法一（inline/inline-block配合vertical-align）\"></a>1. 方法一（inline/inline-block配合vertical-align）</h2><p>这种方法应用于子元素都是inline/inline-block level的元素，可以使用vertical-align属性，兼容IE6+ 如果原本元素不是inline level的话，使用display:inline-block兼容到IE8+</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>我是内容我是内容我是内容</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/images/csstest1.png\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/images/csstest1.png\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的例子我们可以得到以下所示的样式</p>\n<p><img src=\"/images/csstest1.PNG\" alt=\"css垂直居中示例图1\"></p>\n<p>在这里，span/img都是行内元素，我们可以采用vertical-align实现垂直居中。上面默认情况下，vertical-align是基于基线对其的。</p>\n<p>对于上面的例子，我们也可以对span设置display:inline-block属性，设置高宽后，可以做到span中任意内容的居中效果</p>\n<h2 id=\"2-方法二（table-cell配合vertical-align）\"><a href=\"#2-方法二（table-cell配合vertical-align）\" class=\"headerlink\" title=\"2.方法二（table-cell配合vertical-align）\"></a>2.方法二（table-cell配合vertical-align）</h2><p>使用display:tabel-cell，table-cell也是可以使用vertical-align：middle使得元素垂直居中，但是display:table-cell有兼容性问题，兼容IE8+</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>这是第二个内容这是<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的例子我们可以得到以下所示的样式</p>\n<p><img src=\"/images/csstest2.PNG\" alt=\"css垂直居中示例图2\"></p>\n<p>这里需要注意的是table-cell设置需要设置在父元素上保证其内容垂直居中，如果你希望con中的文字也居中现在，也可以对con添加上<code>display: table-cell;vertical-align: middle;</code>。为什么没有line-height。line-height对多行文本的垂直居中实现效果并不是很好</p>\n<ul>\n<li>兼容性：IE6/7不兼容display:table-cell。</li>\n<li>自适应：子容器无法自适应于父容器，高度无法使用百分比单位，因为根据渲染规则，display:table-cell的元素的包含块是它父级的display:table的元素。溢出：父元素就算给定高度，设置overflow，也不会导致溢出隐藏；在子元素溢出的时候，父容器不能保有自身设置的高度，直接会被撑高。</li>\n<li>其他：display:table-cell本身让很多属性无效。</li>\n</ul>\n<h2 id=\"3-方法三：（position-absolute来实现）–不兼容IE6-7\"><a href=\"#3-方法三：（position-absolute来实现）–不兼容IE6-7\" class=\"headerlink\" title=\"3. 方法三：（position:absolute来实现）–不兼容IE6/7\"></a>3. 方法三：（position:absolute来实现）–不兼容IE6/7</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>这是第二个内容这是<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>利用position：absolute如何保证con始终在parent的中心位置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">140px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">70%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/csstest3.PNG\" alt=\"css垂直居中示例图3\"></p>\n<p>我们经常使用margin:0 auto使得块级元素水平居中。这里<code>position: absolute; top:0;bottom:0;left:0;right: 0;</code>的作用是什么，如果我们把这个删除了，可以发现原生con是水平居中了，在垂直方向上没有生效，这是为什么？？</p>\n<p>原理是：<br>‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度。</p>\n<h2 id=\"4-子容器绝对定位，top-50-，负margin（兼容IE6-）\"><a href=\"#4-子容器绝对定位，top-50-，负margin（兼容IE6-）\" class=\"headerlink\" title=\"4. 子容器绝对定位，top:50%，负margin（兼容IE6+）\"></a>4. 子容器绝对定位，top:50%，负margin（兼容IE6+）</h2><p>要求子元素定高</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>这是第二个内容这是<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">140px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">140px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">70px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/csstest4.PNG\" alt=\"css垂直居中示例图4\"></p>\n<h2 id=\"5-参考文章\"><a href=\"#5-参考文章\" class=\"headerlink\" title=\"5. 参考文章\"></a>5. 参考文章</h2><ul>\n<li><a href=\"http://www.imooc.com/u/197450/courses?sort=publish\" target=\"_blank\" rel=\"noopener\">张鑫旭的深入理解CSS系列</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000381042\" target=\"_blank\" rel=\"noopener\">子容器垂直居中于父容器的方案</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000000343188#a-1020000000343394\" target=\"_blank\" rel=\"noopener\">子容器超过父容器如何垂直居中</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-方法一（inline-inline-block配合vertical-align）\"><a href=\"#1-方法一（inline-inline-block配合vertical-align）\" class=\"headerlink\" title=\"1. 方法一（inline/inline-block配合vertical-align）\"></a>1. 方法一（inline/inline-block配合vertical-align）</h2><p>这种方法应用于子元素都是inline/inline-block level的元素，可以使用vertical-align属性，兼容IE6+ 如果原本元素不是inline level的话，使用display:inline-block兼容到IE8+</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>我是内容我是内容我是内容</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/images/csstest1.png\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/images/csstest1.png\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的例子我们可以得到以下所示的样式</p>\n<p><img src=\"/images/csstest1.PNG\" alt=\"css垂直居中示例图1\"></p>\n<p>在这里，span/img都是行内元素，我们可以采用vertical-align实现垂直居中。上面默认情况下，vertical-align是基于基线对其的。</p>\n<p>对于上面的例子，我们也可以对span设置display:inline-block属性，设置高宽后，可以做到span中任意内容的居中效果</p>\n<h2 id=\"2-方法二（table-cell配合vertical-align）\"><a href=\"#2-方法二（table-cell配合vertical-align）\" class=\"headerlink\" title=\"2.方法二（table-cell配合vertical-align）\"></a>2.方法二（table-cell配合vertical-align）</h2><p>使用display:tabel-cell，table-cell也是可以使用vertical-align：middle使得元素垂直居中，但是display:table-cell有兼容性问题，兼容IE8+</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>这是第二个内容这是<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的例子我们可以得到以下所示的样式</p>\n<p><img src=\"/images/csstest2.PNG\" alt=\"css垂直居中示例图2\"></p>\n<p>这里需要注意的是table-cell设置需要设置在父元素上保证其内容垂直居中，如果你希望con中的文字也居中现在，也可以对con添加上<code>display: table-cell;vertical-align: middle;</code>。为什么没有line-height。line-height对多行文本的垂直居中实现效果并不是很好</p>\n<ul>\n<li>兼容性：IE6/7不兼容display:table-cell。</li>\n<li>自适应：子容器无法自适应于父容器，高度无法使用百分比单位，因为根据渲染规则，display:table-cell的元素的包含块是它父级的display:table的元素。溢出：父元素就算给定高度，设置overflow，也不会导致溢出隐藏；在子元素溢出的时候，父容器不能保有自身设置的高度，直接会被撑高。</li>\n<li>其他：display:table-cell本身让很多属性无效。</li>\n</ul>\n<h2 id=\"3-方法三：（position-absolute来实现）–不兼容IE6-7\"><a href=\"#3-方法三：（position-absolute来实现）–不兼容IE6-7\" class=\"headerlink\" title=\"3. 方法三：（position:absolute来实现）–不兼容IE6/7\"></a>3. 方法三：（position:absolute来实现）–不兼容IE6/7</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>这是第二个内容这是<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>利用position：absolute如何保证con始终在parent的中心位置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">140px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">70%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/csstest3.PNG\" alt=\"css垂直居中示例图3\"></p>\n<p>我们经常使用margin:0 auto使得块级元素水平居中。这里<code>position: absolute; top:0;bottom:0;left:0;right: 0;</code>的作用是什么，如果我们把这个删除了，可以发现原生con是水平居中了，在垂直方向上没有生效，这是为什么？？</p>\n<p>原理是：<br>‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度。</p>\n<h2 id=\"4-子容器绝对定位，top-50-，负margin（兼容IE6-）\"><a href=\"#4-子容器绝对定位，top-50-，负margin（兼容IE6-）\" class=\"headerlink\" title=\"4. 子容器绝对定位，top:50%，负margin（兼容IE6+）\"></a>4. 子容器绝对定位，top:50%，负margin（兼容IE6+）</h2><p>要求子元素定高</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"con\"</span>&gt;</span>这是第二个内容这是<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">140px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">140px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">70px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/csstest4.PNG\" alt=\"css垂直居中示例图4\"></p>\n<h2 id=\"5-参考文章\"><a href=\"#5-参考文章\" class=\"headerlink\" title=\"5. 参考文章\"></a>5. 参考文章</h2><ul>\n<li><a href=\"http://www.imooc.com/u/197450/courses?sort=publish\" target=\"_blank\" rel=\"noopener\">张鑫旭的深入理解CSS系列</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000381042\" target=\"_blank\" rel=\"noopener\">子容器垂直居中于父容器的方案</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000000343188#a-1020000000343394\" target=\"_blank\" rel=\"noopener\">子容器超过父容器如何垂直居中</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n"},{"title":"js实现对象的深度克隆","date":"2019-03-14T13:38:53.000Z","_content":"\n\n## 1. 变量访问的方式\n\n在JavaScript中，访问变量可以通过**值访问**也可以通过**引用访问**。\n\n+ `按值访问：`直接读取值的本身\n\n+ `按引用访问：`读取引用地址，根据地址查找真实值。引用类型的值是保存在内存中的对象，在JavaScript中不允许直接访问内存中的位置。所以在操作对象时，实际上操作的是在操作对象的引用而不是实际的对象。\n\n## 2. 函数中的传参方式\n\n在JavaScript的函数传参数方式只能`按值传递`（不管传递的变量是值类型还是引用类型）。也就是将传递的参数复制给函数的一个局部变量（arguments）。\n\n值复制和引用复制：\n\n+ `值复制:`将值本身复制给arguments的一个元素，参数不会影响原变量\n+ `引用复制:`将值得地址复制给arguments的一个元素，参数会影响到原来的变量\n\n\n\n## 3. 如何实现一个对象的深度克隆\n\n### 3.1 为什么要深度克隆一个对象\n\n在日常中对一个对象的复制都只是对其引用的复制，两者之间还是会相互影响，如：\n\n```javascript\n    var a = [1,2,3];\n    var b = a;\n    b.push(5);\n    console.log(a);// [1, 2, 3, 5]，对b的操作影响了a\n```\n\n\t\t\n所以为了是b和a完全一致,但是又不相互影响,就有了深度克隆这一说。\n\n\n### 3.2 获取对象的基本类型\n\n我们都知道在JavaScript中,基本的数据类型(string/boolean/undefined/null/number)的复制属于值复制,相互之间不会有什么影响。那么我们接下来主要讨论的是对象的复制。\n\n+ 对象的类型：function、object、Array\n+ 如何获取以上的基本类型： Object.prototype.toString.call(para) \n  \n  + [object Function]\n  + [object Object]\n  + [object Array]\n \n  也就是返回值是一个字符串，可以通过以下方法获取具体的类型\n  \n  ```javascript\n      function objType(obj) {\n          var obj = Object.prototype.toString.call(obj).substring(8);\n          return obj.substring(0,obj.length-1);\n      }\n      \n      //获取值分别是：Function、Object、Array   \n  ```\n\t    \n+ 函数的复制我们怎么去理解：函数是一个对象,函数名是指向对象的名称。\n\n  ```javascript\n      function text(){\n         console.log(\"a\");\n      }\n  ```\n\n            \n            \n这里,我们可以理解,以上的声明在内存中开辟了一个空间,保存了一个方法,这个方法包含一个打印功能。然后 变量text包含执行这个方法的地址。所以,var b = text;操作,就是将方法的地址复制给函数b。\n    \n+ 在JavaScript中,函数不存在重载,也就是不存在某个函数被修改了的情况(只是断开了指向)。\n   \n### 3.3 具体实现\n\n这里的实现分为你三个部分,入口函数deepClone,对象的克隆函数,以及数组的克隆函数\n\n\n#### 3.3.1 对象的克隆\n\n```javascript\n function cloneObj(obj) {\n    var tempObj = new Object();\n    for(key in obj){\n        switch (objType(obj[key])){\n            case \"Object\":\n                tempObj[key] =cloneObj(obj[key]);\n                break;\n            case \"Array\":\n                tempObj[key] = cloneArr(obj[key]);\n                break;\n            default:\n                tempObj[key] = obj[key];\n\n            break;\n        }\n    }\n    return tempObj;\n }\n```\n       \n            \n            \n#### 3.3.2 数组的克隆\n  \n```javascript\nfunction cloneArr(arr) {\n    var tempArr = new Array();\n    for(var i = 0;i<arr.length;i++){\n        switch (objType(arr[i])){\n            case \"Object\":\n                tempArr.push(cloneObj(arr[key]));\n                break;\n            case \"Array\":\n                tempArr.push(cloneArr(arr[key]))\n                cloneArr(arr[i]);\n                break;\n            default:\n                tempArr.push(arr[i])\n        \n                break;\n        }\n    }\n    \n    return tempArr;\n}\n```\n            \n            \n            \n#### 3.3.3 克隆的入口\n\n```javascript\nfunction deepClone(para) {\n    var temp = null;\n    switch (objType(para)){\n         case \"Object\":\n             temp = cloneObj(para);\n             break;\n         case \"Array\":\n             temp = cloneArr(para);\n             break;\n         default:\n             temp = para;\n             break;\n    }\n    return temp;\n}\n```\n            \n  \n            \n#### 3.3.4 测试\n\n```javascript\n\n var testObj = {\n        \"name\":\"xujiao\",\n        \"age\":\"28\",\n        \"say\":function () {\n            console.log(123);\n        },\n        \"arr\":[1,3,4],\n        \"obj\":{\n          \"a\":12,\n          \"b\":1,\n          \"c\":3\n        }\n    }\n    var clonexx = deepClone(testObj);\n    clonexx.arr.push(333);\n    console.log(clonexx);\n    console.log(testObj);//对clonexx的操作并没有影响testObj\n    \n```\n      \n\n\t\n\t\n\t\n\t\n\t\n\n\n","source":"_posts/JS/javascript实现对象的深度克隆.md","raw":"---\ntitle: js实现对象的深度克隆\ndate: {{date}}\ntags:\n  - 前端开发\n  - js实现对象的深度克隆\n  - javascript\n  - 深度克隆\ncategories: javascript\n---\n\n\n## 1. 变量访问的方式\n\n在JavaScript中，访问变量可以通过**值访问**也可以通过**引用访问**。\n\n+ `按值访问：`直接读取值的本身\n\n+ `按引用访问：`读取引用地址，根据地址查找真实值。引用类型的值是保存在内存中的对象，在JavaScript中不允许直接访问内存中的位置。所以在操作对象时，实际上操作的是在操作对象的引用而不是实际的对象。\n\n## 2. 函数中的传参方式\n\n在JavaScript的函数传参数方式只能`按值传递`（不管传递的变量是值类型还是引用类型）。也就是将传递的参数复制给函数的一个局部变量（arguments）。\n\n值复制和引用复制：\n\n+ `值复制:`将值本身复制给arguments的一个元素，参数不会影响原变量\n+ `引用复制:`将值得地址复制给arguments的一个元素，参数会影响到原来的变量\n\n\n\n## 3. 如何实现一个对象的深度克隆\n\n### 3.1 为什么要深度克隆一个对象\n\n在日常中对一个对象的复制都只是对其引用的复制，两者之间还是会相互影响，如：\n\n```javascript\n    var a = [1,2,3];\n    var b = a;\n    b.push(5);\n    console.log(a);// [1, 2, 3, 5]，对b的操作影响了a\n```\n\n\t\t\n所以为了是b和a完全一致,但是又不相互影响,就有了深度克隆这一说。\n\n\n### 3.2 获取对象的基本类型\n\n我们都知道在JavaScript中,基本的数据类型(string/boolean/undefined/null/number)的复制属于值复制,相互之间不会有什么影响。那么我们接下来主要讨论的是对象的复制。\n\n+ 对象的类型：function、object、Array\n+ 如何获取以上的基本类型： Object.prototype.toString.call(para) \n  \n  + [object Function]\n  + [object Object]\n  + [object Array]\n \n  也就是返回值是一个字符串，可以通过以下方法获取具体的类型\n  \n  ```javascript\n      function objType(obj) {\n          var obj = Object.prototype.toString.call(obj).substring(8);\n          return obj.substring(0,obj.length-1);\n      }\n      \n      //获取值分别是：Function、Object、Array   \n  ```\n\t    \n+ 函数的复制我们怎么去理解：函数是一个对象,函数名是指向对象的名称。\n\n  ```javascript\n      function text(){\n         console.log(\"a\");\n      }\n  ```\n\n            \n            \n这里,我们可以理解,以上的声明在内存中开辟了一个空间,保存了一个方法,这个方法包含一个打印功能。然后 变量text包含执行这个方法的地址。所以,var b = text;操作,就是将方法的地址复制给函数b。\n    \n+ 在JavaScript中,函数不存在重载,也就是不存在某个函数被修改了的情况(只是断开了指向)。\n   \n### 3.3 具体实现\n\n这里的实现分为你三个部分,入口函数deepClone,对象的克隆函数,以及数组的克隆函数\n\n\n#### 3.3.1 对象的克隆\n\n```javascript\n function cloneObj(obj) {\n    var tempObj = new Object();\n    for(key in obj){\n        switch (objType(obj[key])){\n            case \"Object\":\n                tempObj[key] =cloneObj(obj[key]);\n                break;\n            case \"Array\":\n                tempObj[key] = cloneArr(obj[key]);\n                break;\n            default:\n                tempObj[key] = obj[key];\n\n            break;\n        }\n    }\n    return tempObj;\n }\n```\n       \n            \n            \n#### 3.3.2 数组的克隆\n  \n```javascript\nfunction cloneArr(arr) {\n    var tempArr = new Array();\n    for(var i = 0;i<arr.length;i++){\n        switch (objType(arr[i])){\n            case \"Object\":\n                tempArr.push(cloneObj(arr[key]));\n                break;\n            case \"Array\":\n                tempArr.push(cloneArr(arr[key]))\n                cloneArr(arr[i]);\n                break;\n            default:\n                tempArr.push(arr[i])\n        \n                break;\n        }\n    }\n    \n    return tempArr;\n}\n```\n            \n            \n            \n#### 3.3.3 克隆的入口\n\n```javascript\nfunction deepClone(para) {\n    var temp = null;\n    switch (objType(para)){\n         case \"Object\":\n             temp = cloneObj(para);\n             break;\n         case \"Array\":\n             temp = cloneArr(para);\n             break;\n         default:\n             temp = para;\n             break;\n    }\n    return temp;\n}\n```\n            \n  \n            \n#### 3.3.4 测试\n\n```javascript\n\n var testObj = {\n        \"name\":\"xujiao\",\n        \"age\":\"28\",\n        \"say\":function () {\n            console.log(123);\n        },\n        \"arr\":[1,3,4],\n        \"obj\":{\n          \"a\":12,\n          \"b\":1,\n          \"c\":3\n        }\n    }\n    var clonexx = deepClone(testObj);\n    clonexx.arr.push(333);\n    console.log(clonexx);\n    console.log(testObj);//对clonexx的操作并没有影响testObj\n    \n```\n      \n\n\t\n\t\n\t\n\t\n\t\n\n\n","slug":"JS/javascript实现对象的深度克隆","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2h00059oxzdan7ma8i","content":"<h2 id=\"1-变量访问的方式\"><a href=\"#1-变量访问的方式\" class=\"headerlink\" title=\"1. 变量访问的方式\"></a>1. 变量访问的方式</h2><p>在JavaScript中，访问变量可以通过<strong>值访问</strong>也可以通过<strong>引用访问</strong>。</p>\n<ul>\n<li><p><code>按值访问：</code>直接读取值的本身</p>\n</li>\n<li><p><code>按引用访问：</code>读取引用地址，根据地址查找真实值。引用类型的值是保存在内存中的对象，在JavaScript中不允许直接访问内存中的位置。所以在操作对象时，实际上操作的是在操作对象的引用而不是实际的对象。</p>\n</li>\n</ul>\n<h2 id=\"2-函数中的传参方式\"><a href=\"#2-函数中的传参方式\" class=\"headerlink\" title=\"2. 函数中的传参方式\"></a>2. 函数中的传参方式</h2><p>在JavaScript的函数传参数方式只能<code>按值传递</code>（不管传递的变量是值类型还是引用类型）。也就是将传递的参数复制给函数的一个局部变量（arguments）。</p>\n<p>值复制和引用复制：</p>\n<ul>\n<li><code>值复制:</code>将值本身复制给arguments的一个元素，参数不会影响原变量</li>\n<li><code>引用复制:</code>将值得地址复制给arguments的一个元素，参数会影响到原来的变量</li>\n</ul>\n<h2 id=\"3-如何实现一个对象的深度克隆\"><a href=\"#3-如何实现一个对象的深度克隆\" class=\"headerlink\" title=\"3. 如何实现一个对象的深度克隆\"></a>3. 如何实现一个对象的深度克隆</h2><h3 id=\"3-1-为什么要深度克隆一个对象\"><a href=\"#3-1-为什么要深度克隆一个对象\" class=\"headerlink\" title=\"3.1 为什么要深度克隆一个对象\"></a>3.1 为什么要深度克隆一个对象</h3><p>在日常中对一个对象的复制都只是对其引用的复制，两者之间还是会相互影响，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\">b.push(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">// [1, 2, 3, 5]，对b的操作影响了a</span></span><br></pre></td></tr></table></figure>\n<p>所以为了是b和a完全一致,但是又不相互影响,就有了深度克隆这一说。</p>\n<h3 id=\"3-2-获取对象的基本类型\"><a href=\"#3-2-获取对象的基本类型\" class=\"headerlink\" title=\"3.2 获取对象的基本类型\"></a>3.2 获取对象的基本类型</h3><p>我们都知道在JavaScript中,基本的数据类型(string/boolean/undefined/null/number)的复制属于值复制,相互之间不会有什么影响。那么我们接下来主要讨论的是对象的复制。</p>\n<ul>\n<li>对象的类型：function、object、Array</li>\n<li><p>如何获取以上的基本类型： Object.prototype.toString.call(para) </p>\n<ul>\n<li>[object Function]</li>\n<li>[object Object]</li>\n<li>[object Array]</li>\n</ul>\n<p>也就是返回值是一个字符串，可以通过以下方法获取具体的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">objType</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.prototype.toString.call(obj).substring(<span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj.substring(<span class=\"number\">0</span>,obj.length<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取值分别是：Function、Object、Array</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>函数的复制我们怎么去理解：函数是一个对象,函数名是指向对象的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">text</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里,我们可以理解,以上的声明在内存中开辟了一个空间,保存了一个方法,这个方法包含一个打印功能。然后 变量text包含执行这个方法的地址。所以,var b = text;操作,就是将方法的地址复制给函数b。</p>\n<ul>\n<li>在JavaScript中,函数不存在重载,也就是不存在某个函数被修改了的情况(只是断开了指向)。</li>\n</ul>\n<h3 id=\"3-3-具体实现\"><a href=\"#3-3-具体实现\" class=\"headerlink\" title=\"3.3 具体实现\"></a>3.3 具体实现</h3><p>这里的实现分为你三个部分,入口函数deepClone,对象的克隆函数,以及数组的克隆函数</p>\n<h4 id=\"3-3-1-对象的克隆\"><a href=\"#3-3-1-对象的克隆\" class=\"headerlink\" title=\"3.3.1 对象的克隆\"></a>3.3.1 对象的克隆</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneObj</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> tempObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (objType(obj[key]))&#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">\"Object\"</span>:</span><br><span class=\"line\">               tempObj[key] =cloneObj(obj[key]);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">\"Array\"</span>:</span><br><span class=\"line\">               tempObj[key] = cloneArr(obj[key]);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">               tempObj[key] = obj[key];</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> tempObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-2-数组的克隆\"><a href=\"#3-3-2-数组的克隆\" class=\"headerlink\" title=\"3.3.2 数组的克隆\"></a>3.3.2 数组的克隆</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneArr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (objType(arr[i]))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"Object\"</span>:</span><br><span class=\"line\">                tempArr.push(cloneObj(arr[key]));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"Array\"</span>:</span><br><span class=\"line\">                tempArr.push(cloneArr(arr[key]))</span><br><span class=\"line\">                cloneArr(arr[i]);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                tempArr.push(arr[i])</span><br><span class=\"line\">        </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> tempArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-克隆的入口\"><a href=\"#3-3-3-克隆的入口\" class=\"headerlink\" title=\"3.3.3 克隆的入口\"></a>3.3.3 克隆的入口</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">para</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (objType(para))&#123;</span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"string\">\"Object\"</span>:</span><br><span class=\"line\">             temp = cloneObj(para);</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"string\">\"Array\"</span>:</span><br><span class=\"line\">             temp = cloneArr(para);</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">         <span class=\"keyword\">default</span>:</span><br><span class=\"line\">             temp = para;</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-4-测试\"><a href=\"#3-3-4-测试\" class=\"headerlink\" title=\"3.3.4 测试\"></a>3.3.4 测试</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testObj = &#123;</span><br><span class=\"line\">       <span class=\"string\">\"name\"</span>:<span class=\"string\">\"xujiao\"</span>,</span><br><span class=\"line\">       <span class=\"string\">\"age\"</span>:<span class=\"string\">\"28\"</span>,</span><br><span class=\"line\">       <span class=\"string\">\"say\"</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"number\">123</span>);</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       <span class=\"string\">\"arr\"</span>:[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">       <span class=\"string\">\"obj\"</span>:&#123;</span><br><span class=\"line\">         <span class=\"string\">\"a\"</span>:<span class=\"number\">12</span>,</span><br><span class=\"line\">         <span class=\"string\">\"b\"</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">         <span class=\"string\">\"c\"</span>:<span class=\"number\">3</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> clonexx = deepClone(testObj);</span><br><span class=\"line\">   clonexx.arr.push(<span class=\"number\">333</span>);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(clonexx);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(testObj);<span class=\"comment\">//对clonexx的操作并没有影响testObj</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-变量访问的方式\"><a href=\"#1-变量访问的方式\" class=\"headerlink\" title=\"1. 变量访问的方式\"></a>1. 变量访问的方式</h2><p>在JavaScript中，访问变量可以通过<strong>值访问</strong>也可以通过<strong>引用访问</strong>。</p>\n<ul>\n<li><p><code>按值访问：</code>直接读取值的本身</p>\n</li>\n<li><p><code>按引用访问：</code>读取引用地址，根据地址查找真实值。引用类型的值是保存在内存中的对象，在JavaScript中不允许直接访问内存中的位置。所以在操作对象时，实际上操作的是在操作对象的引用而不是实际的对象。</p>\n</li>\n</ul>\n<h2 id=\"2-函数中的传参方式\"><a href=\"#2-函数中的传参方式\" class=\"headerlink\" title=\"2. 函数中的传参方式\"></a>2. 函数中的传参方式</h2><p>在JavaScript的函数传参数方式只能<code>按值传递</code>（不管传递的变量是值类型还是引用类型）。也就是将传递的参数复制给函数的一个局部变量（arguments）。</p>\n<p>值复制和引用复制：</p>\n<ul>\n<li><code>值复制:</code>将值本身复制给arguments的一个元素，参数不会影响原变量</li>\n<li><code>引用复制:</code>将值得地址复制给arguments的一个元素，参数会影响到原来的变量</li>\n</ul>\n<h2 id=\"3-如何实现一个对象的深度克隆\"><a href=\"#3-如何实现一个对象的深度克隆\" class=\"headerlink\" title=\"3. 如何实现一个对象的深度克隆\"></a>3. 如何实现一个对象的深度克隆</h2><h3 id=\"3-1-为什么要深度克隆一个对象\"><a href=\"#3-1-为什么要深度克隆一个对象\" class=\"headerlink\" title=\"3.1 为什么要深度克隆一个对象\"></a>3.1 为什么要深度克隆一个对象</h3><p>在日常中对一个对象的复制都只是对其引用的复制，两者之间还是会相互影响，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\">b.push(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">// [1, 2, 3, 5]，对b的操作影响了a</span></span><br></pre></td></tr></table></figure>\n<p>所以为了是b和a完全一致,但是又不相互影响,就有了深度克隆这一说。</p>\n<h3 id=\"3-2-获取对象的基本类型\"><a href=\"#3-2-获取对象的基本类型\" class=\"headerlink\" title=\"3.2 获取对象的基本类型\"></a>3.2 获取对象的基本类型</h3><p>我们都知道在JavaScript中,基本的数据类型(string/boolean/undefined/null/number)的复制属于值复制,相互之间不会有什么影响。那么我们接下来主要讨论的是对象的复制。</p>\n<ul>\n<li>对象的类型：function、object、Array</li>\n<li><p>如何获取以上的基本类型： Object.prototype.toString.call(para) </p>\n<ul>\n<li>[object Function]</li>\n<li>[object Object]</li>\n<li>[object Array]</li>\n</ul>\n<p>也就是返回值是一个字符串，可以通过以下方法获取具体的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">objType</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.prototype.toString.call(obj).substring(<span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj.substring(<span class=\"number\">0</span>,obj.length<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取值分别是：Function、Object、Array</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>函数的复制我们怎么去理解：函数是一个对象,函数名是指向对象的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">text</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里,我们可以理解,以上的声明在内存中开辟了一个空间,保存了一个方法,这个方法包含一个打印功能。然后 变量text包含执行这个方法的地址。所以,var b = text;操作,就是将方法的地址复制给函数b。</p>\n<ul>\n<li>在JavaScript中,函数不存在重载,也就是不存在某个函数被修改了的情况(只是断开了指向)。</li>\n</ul>\n<h3 id=\"3-3-具体实现\"><a href=\"#3-3-具体实现\" class=\"headerlink\" title=\"3.3 具体实现\"></a>3.3 具体实现</h3><p>这里的实现分为你三个部分,入口函数deepClone,对象的克隆函数,以及数组的克隆函数</p>\n<h4 id=\"3-3-1-对象的克隆\"><a href=\"#3-3-1-对象的克隆\" class=\"headerlink\" title=\"3.3.1 对象的克隆\"></a>3.3.1 对象的克隆</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneObj</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> tempObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (objType(obj[key]))&#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">\"Object\"</span>:</span><br><span class=\"line\">               tempObj[key] =cloneObj(obj[key]);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">\"Array\"</span>:</span><br><span class=\"line\">               tempObj[key] = cloneArr(obj[key]);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">               tempObj[key] = obj[key];</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> tempObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-2-数组的克隆\"><a href=\"#3-3-2-数组的克隆\" class=\"headerlink\" title=\"3.3.2 数组的克隆\"></a>3.3.2 数组的克隆</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneArr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (objType(arr[i]))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"Object\"</span>:</span><br><span class=\"line\">                tempArr.push(cloneObj(arr[key]));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"Array\"</span>:</span><br><span class=\"line\">                tempArr.push(cloneArr(arr[key]))</span><br><span class=\"line\">                cloneArr(arr[i]);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                tempArr.push(arr[i])</span><br><span class=\"line\">        </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> tempArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-克隆的入口\"><a href=\"#3-3-3-克隆的入口\" class=\"headerlink\" title=\"3.3.3 克隆的入口\"></a>3.3.3 克隆的入口</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">para</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (objType(para))&#123;</span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"string\">\"Object\"</span>:</span><br><span class=\"line\">             temp = cloneObj(para);</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"string\">\"Array\"</span>:</span><br><span class=\"line\">             temp = cloneArr(para);</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">         <span class=\"keyword\">default</span>:</span><br><span class=\"line\">             temp = para;</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-4-测试\"><a href=\"#3-3-4-测试\" class=\"headerlink\" title=\"3.3.4 测试\"></a>3.3.4 测试</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testObj = &#123;</span><br><span class=\"line\">       <span class=\"string\">\"name\"</span>:<span class=\"string\">\"xujiao\"</span>,</span><br><span class=\"line\">       <span class=\"string\">\"age\"</span>:<span class=\"string\">\"28\"</span>,</span><br><span class=\"line\">       <span class=\"string\">\"say\"</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"number\">123</span>);</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       <span class=\"string\">\"arr\"</span>:[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">       <span class=\"string\">\"obj\"</span>:&#123;</span><br><span class=\"line\">         <span class=\"string\">\"a\"</span>:<span class=\"number\">12</span>,</span><br><span class=\"line\">         <span class=\"string\">\"b\"</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">         <span class=\"string\">\"c\"</span>:<span class=\"number\">3</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> clonexx = deepClone(testObj);</span><br><span class=\"line\">   clonexx.arr.push(<span class=\"number\">333</span>);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(clonexx);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(testObj);<span class=\"comment\">//对clonexx的操作并没有影响testObj</span></span><br></pre></td></tr></table></figure>\n"},{"title":"new操作到底做了什么","date":"2017-03-24T16:00:00.000Z","_content":"  \n## 1. new操作做了哪些\n\n\n```javascript\nfunction F(name,age){\n    this.name = name;\n    this.age = age;\n    this.say = function(){\n       console.log(this.name+\"/\"+this.age)\n    }\n   return {\n      a:1,\n      b:2\n   }\n }\n\n var f = new F();\n console.log(f);\n```\n    \n \nnew调用函数（实例化）执行了5项操作\n\n#### 1.1 第一步：创建一个新的对象\n\n```javascript\nvar f = new Object();\n```\n\n    \n#### 1.2 第二步：创建原型链接\n```javascript\nf._proto_ = F.prototyte;\nf._proto_ === F.prototype // true\n```\n      \n#### 1.3 第三步：绑定this\n\n让F中的的this指向f上\n\n#### 1.4 第四步：执行构造函数中的代码，也就是为新对象添加属性\n\n```javascript\nf.name = undefined, \n   f.age = undefined,\n   f.say= function(){\n   console.log(this.name+\"/\"+this.age)//这里this指向f\n}\n```\n       \n#### 1.5 第五步：返回新对象\n  + 如果返回的对象是值类型，就丢弃，返回这个新对象\n     return 1;是无效的，控制台打印的是对象f\n  + 如果是引用类型，这返回这个引用类型，取代新对象\n     return {a:1,b:2}会取代f\n\n## 2. call、apply、bind\n\n三者的作用都是改变this指向的，并且参第一个参数都是this要指向的对象，都可以利用后续参数传参\n\n### 2.1 区别在于：\n\n+ call和apply本质上功能一致，都是直接执行了，但是传参的方式不一样\n    + obj.call(obj1,arg1,arg2),\n    + obj.apply(obj1,[arg1,arg2])\n+ bind没有直接执行，而是返回一个函数，我们可以链式一直玩下去~\n\n## 3. 继承\n       \n上面扯了那么多似乎都跟继承没什么关系，我理解的是，什么是继承，继承就是能够使用其他对象的属性和方法，管你用什么方法。\n那么有几种方法可以让我们使用别的对象的方法和属性呢。\n\n+ 看上面的new操作第四步做了什么，执行了构造函数里面的代码，相当于复制了一份，那么相当于可以使用F中的属性和方法了。\n从这个层面上看，构造函数是实现继承的一个方式。\n\n    + 问题是：如果每次继承父元素的属性和方法都得复制父元素的全部代码的话，似不似撒\n    + 解决方法是什么，看new操作第二步干了什么，是的，__proto__属性指向了F的prototype，所以可以把F中通用的方法都移到F.prototype上，这就是传说中的基于原型的继承。\n\n+ 另一个关于继承的方法，是利用改变this指向实现的\n   \n```javascript\n        function Person(name,age) {\n           this.name = name;\n           this.age = age;\n           this.say=function () {\n               console.log(this.name+\"/\"+this.age);\n           }\n       }\n   \n       function xx(name,age){\n           Person.apply(this,arguments);\n       }\n   \n       var b = new xx(\"我\",\"18\");\n       b.say();\n```\n\n看到了吗  b是从xx的实例，可是它居然能使用parson的say方法，可不就是继承吗   \n\n## 4. 小知识     \n\n### 4.1 Object.create()了解\n+ 是es5的新特性\n+ 有两个参数，第二个参数可选（描述性）\n```javascript\n//可以看下object.create的实现\nif (!Object.create) {\n  Object.create = function (o) {\n     function F() {}  //定义了一个隐式的构造函数\n     F.prototype = o;\n     return new F();  //其实还是通过new来实现的\n };\n}\n\nobject.create(null)\n//创建一个很空的对象，他的原型都是空的，区别new object\n```\n        \n### 4.2 _ proto _ 和prototype的区别\n\n+ **JS中对象**:具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的**构造函数的原型**，这也保证了实例能够访问在构造函数原型中定义的属性和方法。\n  \n+ 函数是个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——**原型属性（prototype)**，这个属性是一个指针，指向一个函数的原型对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫constructor，这个属性包含了一个指针，指回原构造函数。        \n```javascript\n\nfunction F(name,age){\n    this.name = name;\n    this.age = age;\n    this.say = function(){\n       console.log(this.name+\"/\"+this.age)\n    }\n }\nvar f = new F();\nconsole.log(F.constructor === Function);//F的构造函数是Function\nconsole.log(Function.prototype);//function(){}\nconsole.log(Function.__proto__);//function(){}\nconsole.log(F.__proto__)//F.__proto__指向构造函数Function的原型prototype:function(){}\n\nconsole.log(f.constructor === F);//true\n\nconsole.log(F.prototype);//Object{}\nconsole.log(f.__proto__);//f.__proto__指向构造函数F的原型:Object{}\n\nconsole.log(F.prototype);//Object{}\nconsole.log(f.prototype);//prototype是方法的属性,f是个普通的对象,没有prototype属性\n\n\n```\n     \n                 \n+ constructor：constructor不需要手动创建，它是对象原型上的一个属性。Object.prototype.constructor，返回一个**指向创建了该对象原型的函数引用**。需要注意的是，该属性的值是那个函数本身，该属性为只读。\n```javascript\n//对于上面的例子：\nconsole.log(F.constructor)\n//Function() { [native code] }\n console.log(f.constructor);\nfunction F(name,age){\n     this.name = name;\n     this.age = age;\n     this.say = function(){\n        console.log(this.name+\"/\"+this.age)\n     }\n }\n```\n    \n  \n## 5. 其他\n\n+ 构造函数的首字母一般大写\n+ 值类型赋值是值的复制\n+ 对象类型的赋值不仅是值的复制也是引用的复制\n```javascript\nvar a = [1,2,3];\nvar b = a;\nb.push(4);\n//a[1,2,3,4] b[1,2,3,4]\n\nvar a = [1,2,3];\n    b = a;//值和引用都给了b\n    b = [1,2,3,4];// a[1,2,3] b[1,2,3,4]\n```\n         \n              \n  \n---\n做一个勤于思考的人","source":"_posts/JS/new操作到底做了什么.md","raw":"---\ntitle: new操作到底做了什么\ndate: 2017-03-25\ntags:\n  - 前端开发\n  - 个人成长\n  - JS\n  - 继承\ncategories: JS\n---\n  \n## 1. new操作做了哪些\n\n\n```javascript\nfunction F(name,age){\n    this.name = name;\n    this.age = age;\n    this.say = function(){\n       console.log(this.name+\"/\"+this.age)\n    }\n   return {\n      a:1,\n      b:2\n   }\n }\n\n var f = new F();\n console.log(f);\n```\n    \n \nnew调用函数（实例化）执行了5项操作\n\n#### 1.1 第一步：创建一个新的对象\n\n```javascript\nvar f = new Object();\n```\n\n    \n#### 1.2 第二步：创建原型链接\n```javascript\nf._proto_ = F.prototyte;\nf._proto_ === F.prototype // true\n```\n      \n#### 1.3 第三步：绑定this\n\n让F中的的this指向f上\n\n#### 1.4 第四步：执行构造函数中的代码，也就是为新对象添加属性\n\n```javascript\nf.name = undefined, \n   f.age = undefined,\n   f.say= function(){\n   console.log(this.name+\"/\"+this.age)//这里this指向f\n}\n```\n       \n#### 1.5 第五步：返回新对象\n  + 如果返回的对象是值类型，就丢弃，返回这个新对象\n     return 1;是无效的，控制台打印的是对象f\n  + 如果是引用类型，这返回这个引用类型，取代新对象\n     return {a:1,b:2}会取代f\n\n## 2. call、apply、bind\n\n三者的作用都是改变this指向的，并且参第一个参数都是this要指向的对象，都可以利用后续参数传参\n\n### 2.1 区别在于：\n\n+ call和apply本质上功能一致，都是直接执行了，但是传参的方式不一样\n    + obj.call(obj1,arg1,arg2),\n    + obj.apply(obj1,[arg1,arg2])\n+ bind没有直接执行，而是返回一个函数，我们可以链式一直玩下去~\n\n## 3. 继承\n       \n上面扯了那么多似乎都跟继承没什么关系，我理解的是，什么是继承，继承就是能够使用其他对象的属性和方法，管你用什么方法。\n那么有几种方法可以让我们使用别的对象的方法和属性呢。\n\n+ 看上面的new操作第四步做了什么，执行了构造函数里面的代码，相当于复制了一份，那么相当于可以使用F中的属性和方法了。\n从这个层面上看，构造函数是实现继承的一个方式。\n\n    + 问题是：如果每次继承父元素的属性和方法都得复制父元素的全部代码的话，似不似撒\n    + 解决方法是什么，看new操作第二步干了什么，是的，__proto__属性指向了F的prototype，所以可以把F中通用的方法都移到F.prototype上，这就是传说中的基于原型的继承。\n\n+ 另一个关于继承的方法，是利用改变this指向实现的\n   \n```javascript\n        function Person(name,age) {\n           this.name = name;\n           this.age = age;\n           this.say=function () {\n               console.log(this.name+\"/\"+this.age);\n           }\n       }\n   \n       function xx(name,age){\n           Person.apply(this,arguments);\n       }\n   \n       var b = new xx(\"我\",\"18\");\n       b.say();\n```\n\n看到了吗  b是从xx的实例，可是它居然能使用parson的say方法，可不就是继承吗   \n\n## 4. 小知识     \n\n### 4.1 Object.create()了解\n+ 是es5的新特性\n+ 有两个参数，第二个参数可选（描述性）\n```javascript\n//可以看下object.create的实现\nif (!Object.create) {\n  Object.create = function (o) {\n     function F() {}  //定义了一个隐式的构造函数\n     F.prototype = o;\n     return new F();  //其实还是通过new来实现的\n };\n}\n\nobject.create(null)\n//创建一个很空的对象，他的原型都是空的，区别new object\n```\n        \n### 4.2 _ proto _ 和prototype的区别\n\n+ **JS中对象**:具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的**构造函数的原型**，这也保证了实例能够访问在构造函数原型中定义的属性和方法。\n  \n+ 函数是个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——**原型属性（prototype)**，这个属性是一个指针，指向一个函数的原型对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫constructor，这个属性包含了一个指针，指回原构造函数。        \n```javascript\n\nfunction F(name,age){\n    this.name = name;\n    this.age = age;\n    this.say = function(){\n       console.log(this.name+\"/\"+this.age)\n    }\n }\nvar f = new F();\nconsole.log(F.constructor === Function);//F的构造函数是Function\nconsole.log(Function.prototype);//function(){}\nconsole.log(Function.__proto__);//function(){}\nconsole.log(F.__proto__)//F.__proto__指向构造函数Function的原型prototype:function(){}\n\nconsole.log(f.constructor === F);//true\n\nconsole.log(F.prototype);//Object{}\nconsole.log(f.__proto__);//f.__proto__指向构造函数F的原型:Object{}\n\nconsole.log(F.prototype);//Object{}\nconsole.log(f.prototype);//prototype是方法的属性,f是个普通的对象,没有prototype属性\n\n\n```\n     \n                 \n+ constructor：constructor不需要手动创建，它是对象原型上的一个属性。Object.prototype.constructor，返回一个**指向创建了该对象原型的函数引用**。需要注意的是，该属性的值是那个函数本身，该属性为只读。\n```javascript\n//对于上面的例子：\nconsole.log(F.constructor)\n//Function() { [native code] }\n console.log(f.constructor);\nfunction F(name,age){\n     this.name = name;\n     this.age = age;\n     this.say = function(){\n        console.log(this.name+\"/\"+this.age)\n     }\n }\n```\n    \n  \n## 5. 其他\n\n+ 构造函数的首字母一般大写\n+ 值类型赋值是值的复制\n+ 对象类型的赋值不仅是值的复制也是引用的复制\n```javascript\nvar a = [1,2,3];\nvar b = a;\nb.push(4);\n//a[1,2,3,4] b[1,2,3,4]\n\nvar a = [1,2,3];\n    b = a;//值和引用都给了b\n    b = [1,2,3,4];// a[1,2,3] b[1,2,3,4]\n```\n         \n              \n  \n---\n做一个勤于思考的人","slug":"JS/new操作到底做了什么","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2l00089oxzszpe5stv","content":"<h2 id=\"1-new操作做了哪些\"><a href=\"#1-new操作做了哪些\" class=\"headerlink\" title=\"1. new操作做了哪些\"></a>1. new操作做了哪些</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      a:<span class=\"number\">1</span>,</span><br><span class=\"line\">      b:<span class=\"number\">2</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(f);</span><br></pre></td></tr></table></figure>\n<p>new调用函数（实例化）执行了5项操作</p>\n<h4 id=\"1-1-第一步：创建一个新的对象\"><a href=\"#1-1-第一步：创建一个新的对象\" class=\"headerlink\" title=\"1.1 第一步：创建一个新的对象\"></a>1.1 第一步：创建一个新的对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2-第二步：创建原型链接\"><a href=\"#1-2-第二步：创建原型链接\" class=\"headerlink\" title=\"1.2 第二步：创建原型链接\"></a>1.2 第二步：创建原型链接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f._proto_ = F.prototyte;</span><br><span class=\"line\">f._proto_ === F.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-第三步：绑定this\"><a href=\"#1-3-第三步：绑定this\" class=\"headerlink\" title=\"1.3 第三步：绑定this\"></a>1.3 第三步：绑定this</h4><p>让F中的的this指向f上</p>\n<h4 id=\"1-4-第四步：执行构造函数中的代码，也就是为新对象添加属性\"><a href=\"#1-4-第四步：执行构造函数中的代码，也就是为新对象添加属性\" class=\"headerlink\" title=\"1.4 第四步：执行构造函数中的代码，也就是为新对象添加属性\"></a>1.4 第四步：执行构造函数中的代码，也就是为新对象添加属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.name = <span class=\"literal\">undefined</span>, </span><br><span class=\"line\">   f.age = <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">   f.say= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)<span class=\"comment\">//这里this指向f</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-5-第五步：返回新对象\"><a href=\"#1-5-第五步：返回新对象\" class=\"headerlink\" title=\"1.5 第五步：返回新对象\"></a>1.5 第五步：返回新对象</h4><ul>\n<li>如果返回的对象是值类型，就丢弃，返回这个新对象<br> return 1;是无效的，控制台打印的是对象f</li>\n<li>如果是引用类型，这返回这个引用类型，取代新对象<br> return {a:1,b:2}会取代f</li>\n</ul>\n<h2 id=\"2-call、apply、bind\"><a href=\"#2-call、apply、bind\" class=\"headerlink\" title=\"2. call、apply、bind\"></a>2. call、apply、bind</h2><p>三者的作用都是改变this指向的，并且参第一个参数都是this要指向的对象，都可以利用后续参数传参</p>\n<h3 id=\"2-1-区别在于：\"><a href=\"#2-1-区别在于：\" class=\"headerlink\" title=\"2.1 区别在于：\"></a>2.1 区别在于：</h3><ul>\n<li>call和apply本质上功能一致，都是直接执行了，但是传参的方式不一样<ul>\n<li>obj.call(obj1,arg1,arg2),</li>\n<li>obj.apply(obj1,[arg1,arg2])</li>\n</ul>\n</li>\n<li>bind没有直接执行，而是返回一个函数，我们可以链式一直玩下去~</li>\n</ul>\n<h2 id=\"3-继承\"><a href=\"#3-继承\" class=\"headerlink\" title=\"3. 继承\"></a>3. 继承</h2><p>上面扯了那么多似乎都跟继承没什么关系，我理解的是，什么是继承，继承就是能够使用其他对象的属性和方法，管你用什么方法。<br>那么有几种方法可以让我们使用别的对象的方法和属性呢。</p>\n<ul>\n<li><p>看上面的new操作第四步做了什么，执行了构造函数里面的代码，相当于复制了一份，那么相当于可以使用F中的属性和方法了。<br>从这个层面上看，构造函数是实现继承的一个方式。</p>\n<ul>\n<li>问题是：如果每次继承父元素的属性和方法都得复制父元素的全部代码的话，似不似撒</li>\n<li>解决方法是什么，看new操作第二步干了什么，是的，<strong>proto</strong>属性指向了F的prototype，所以可以把F中通用的方法都移到F.prototype上，这就是传说中的基于原型的继承。</li>\n</ul>\n</li>\n<li><p>另一个关于继承的方法，是利用改变this指向实现的</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">xx</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    Person.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> xx(<span class=\"string\">\"我\"</span>,<span class=\"string\">\"18\"</span>);</span><br><span class=\"line\">b.say();</span><br></pre></td></tr></table></figure>\n<p>看到了吗  b是从xx的实例，可是它居然能使用parson的say方法，可不就是继承吗   </p>\n<h2 id=\"4-小知识\"><a href=\"#4-小知识\" class=\"headerlink\" title=\"4. 小知识\"></a>4. 小知识</h2><h3 id=\"4-1-Object-create-了解\"><a href=\"#4-1-Object-create-了解\" class=\"headerlink\" title=\"4.1 Object.create()了解\"></a>4.1 Object.create()了解</h3><ul>\n<li>是es5的新特性</li>\n<li>有两个参数，第二个参数可选（描述性）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以看下object.create的实现</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Object</span>.create) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;  <span class=\"comment\">//定义了一个隐式的构造函数</span></span><br><span class=\"line\">     F.prototype = o;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();  <span class=\"comment\">//其实还是通过new来实现的</span></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">object.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"comment\">//创建一个很空的对象，他的原型都是空的，区别new object</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"4-2-proto-和prototype的区别\"><a href=\"#4-2-proto-和prototype的区别\" class=\"headerlink\" title=\"4.2 _ proto _ 和prototype的区别\"></a>4.2 _ proto _ 和prototype的区别</h3><ul>\n<li><p><strong>JS中对象</strong>:具有属性<strong>proto</strong>，可称为隐式原型，一个对象的隐式原型指向构造该对象的<strong>构造函数的原型</strong>，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p>\n</li>\n<li><p>函数是个特殊的对象，除了和其他对象一样有上述<em>proto</em>属性之外，还有自己特有的属性——<strong>原型属性（prototype)</strong>，这个属性是一个指针，指向一个函数的原型对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫constructor，这个属性包含了一个指针，指回原构造函数。        </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.constructor === <span class=\"built_in\">Function</span>);<span class=\"comment\">//F的构造函数是Function</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype);<span class=\"comment\">//function()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.__proto__);<span class=\"comment\">//function()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.__proto__)<span class=\"comment\">//F.__proto__指向构造函数Function的原型prototype:function()&#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.constructor === F);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.prototype);<span class=\"comment\">//Object&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.__proto__);<span class=\"comment\">//f.__proto__指向构造函数F的原型:Object&#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.prototype);<span class=\"comment\">//Object&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.prototype);<span class=\"comment\">//prototype是方法的属性,f是个普通的对象,没有prototype属性</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>constructor：constructor不需要手动创建，它是对象原型上的一个属性。Object.prototype.constructor，返回一个<strong>指向创建了该对象原型的函数引用</strong>。需要注意的是，该属性的值是那个函数本身，该属性为只读。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对于上面的例子：</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.constructor)</span><br><span class=\"line\"><span class=\"comment\">//Function() &#123; [native code] &#125;</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(f.constructor);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5. 其他\"></a>5. 其他</h2><ul>\n<li>构造函数的首字母一般大写</li>\n<li>值类型赋值是值的复制</li>\n<li>对象类型的赋值不仅是值的复制也是引用的复制<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\">b.push(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">//a[1,2,3,4] b[1,2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    b = a;<span class=\"comment\">//值和引用都给了b</span></span><br><span class=\"line\">    b = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];<span class=\"comment\">// a[1,2,3] b[1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-new操作做了哪些\"><a href=\"#1-new操作做了哪些\" class=\"headerlink\" title=\"1. new操作做了哪些\"></a>1. new操作做了哪些</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      a:<span class=\"number\">1</span>,</span><br><span class=\"line\">      b:<span class=\"number\">2</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(f);</span><br></pre></td></tr></table></figure>\n<p>new调用函数（实例化）执行了5项操作</p>\n<h4 id=\"1-1-第一步：创建一个新的对象\"><a href=\"#1-1-第一步：创建一个新的对象\" class=\"headerlink\" title=\"1.1 第一步：创建一个新的对象\"></a>1.1 第一步：创建一个新的对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2-第二步：创建原型链接\"><a href=\"#1-2-第二步：创建原型链接\" class=\"headerlink\" title=\"1.2 第二步：创建原型链接\"></a>1.2 第二步：创建原型链接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f._proto_ = F.prototyte;</span><br><span class=\"line\">f._proto_ === F.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-第三步：绑定this\"><a href=\"#1-3-第三步：绑定this\" class=\"headerlink\" title=\"1.3 第三步：绑定this\"></a>1.3 第三步：绑定this</h4><p>让F中的的this指向f上</p>\n<h4 id=\"1-4-第四步：执行构造函数中的代码，也就是为新对象添加属性\"><a href=\"#1-4-第四步：执行构造函数中的代码，也就是为新对象添加属性\" class=\"headerlink\" title=\"1.4 第四步：执行构造函数中的代码，也就是为新对象添加属性\"></a>1.4 第四步：执行构造函数中的代码，也就是为新对象添加属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.name = <span class=\"literal\">undefined</span>, </span><br><span class=\"line\">   f.age = <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">   f.say= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)<span class=\"comment\">//这里this指向f</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-5-第五步：返回新对象\"><a href=\"#1-5-第五步：返回新对象\" class=\"headerlink\" title=\"1.5 第五步：返回新对象\"></a>1.5 第五步：返回新对象</h4><ul>\n<li>如果返回的对象是值类型，就丢弃，返回这个新对象<br> return 1;是无效的，控制台打印的是对象f</li>\n<li>如果是引用类型，这返回这个引用类型，取代新对象<br> return {a:1,b:2}会取代f</li>\n</ul>\n<h2 id=\"2-call、apply、bind\"><a href=\"#2-call、apply、bind\" class=\"headerlink\" title=\"2. call、apply、bind\"></a>2. call、apply、bind</h2><p>三者的作用都是改变this指向的，并且参第一个参数都是this要指向的对象，都可以利用后续参数传参</p>\n<h3 id=\"2-1-区别在于：\"><a href=\"#2-1-区别在于：\" class=\"headerlink\" title=\"2.1 区别在于：\"></a>2.1 区别在于：</h3><ul>\n<li>call和apply本质上功能一致，都是直接执行了，但是传参的方式不一样<ul>\n<li>obj.call(obj1,arg1,arg2),</li>\n<li>obj.apply(obj1,[arg1,arg2])</li>\n</ul>\n</li>\n<li>bind没有直接执行，而是返回一个函数，我们可以链式一直玩下去~</li>\n</ul>\n<h2 id=\"3-继承\"><a href=\"#3-继承\" class=\"headerlink\" title=\"3. 继承\"></a>3. 继承</h2><p>上面扯了那么多似乎都跟继承没什么关系，我理解的是，什么是继承，继承就是能够使用其他对象的属性和方法，管你用什么方法。<br>那么有几种方法可以让我们使用别的对象的方法和属性呢。</p>\n<ul>\n<li><p>看上面的new操作第四步做了什么，执行了构造函数里面的代码，相当于复制了一份，那么相当于可以使用F中的属性和方法了。<br>从这个层面上看，构造函数是实现继承的一个方式。</p>\n<ul>\n<li>问题是：如果每次继承父元素的属性和方法都得复制父元素的全部代码的话，似不似撒</li>\n<li>解决方法是什么，看new操作第二步干了什么，是的，<strong>proto</strong>属性指向了F的prototype，所以可以把F中通用的方法都移到F.prototype上，这就是传说中的基于原型的继承。</li>\n</ul>\n</li>\n<li><p>另一个关于继承的方法，是利用改变this指向实现的</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">xx</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    Person.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> xx(<span class=\"string\">\"我\"</span>,<span class=\"string\">\"18\"</span>);</span><br><span class=\"line\">b.say();</span><br></pre></td></tr></table></figure>\n<p>看到了吗  b是从xx的实例，可是它居然能使用parson的say方法，可不就是继承吗   </p>\n<h2 id=\"4-小知识\"><a href=\"#4-小知识\" class=\"headerlink\" title=\"4. 小知识\"></a>4. 小知识</h2><h3 id=\"4-1-Object-create-了解\"><a href=\"#4-1-Object-create-了解\" class=\"headerlink\" title=\"4.1 Object.create()了解\"></a>4.1 Object.create()了解</h3><ul>\n<li>是es5的新特性</li>\n<li>有两个参数，第二个参数可选（描述性）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以看下object.create的实现</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Object</span>.create) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;  <span class=\"comment\">//定义了一个隐式的构造函数</span></span><br><span class=\"line\">     F.prototype = o;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();  <span class=\"comment\">//其实还是通过new来实现的</span></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">object.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"comment\">//创建一个很空的对象，他的原型都是空的，区别new object</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"4-2-proto-和prototype的区别\"><a href=\"#4-2-proto-和prototype的区别\" class=\"headerlink\" title=\"4.2 _ proto _ 和prototype的区别\"></a>4.2 _ proto _ 和prototype的区别</h3><ul>\n<li><p><strong>JS中对象</strong>:具有属性<strong>proto</strong>，可称为隐式原型，一个对象的隐式原型指向构造该对象的<strong>构造函数的原型</strong>，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p>\n</li>\n<li><p>函数是个特殊的对象，除了和其他对象一样有上述<em>proto</em>属性之外，还有自己特有的属性——<strong>原型属性（prototype)</strong>，这个属性是一个指针，指向一个函数的原型对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫constructor，这个属性包含了一个指针，指回原构造函数。        </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.constructor === <span class=\"built_in\">Function</span>);<span class=\"comment\">//F的构造函数是Function</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype);<span class=\"comment\">//function()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.__proto__);<span class=\"comment\">//function()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.__proto__)<span class=\"comment\">//F.__proto__指向构造函数Function的原型prototype:function()&#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.constructor === F);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.prototype);<span class=\"comment\">//Object&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.__proto__);<span class=\"comment\">//f.__proto__指向构造函数F的原型:Object&#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.prototype);<span class=\"comment\">//Object&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.prototype);<span class=\"comment\">//prototype是方法的属性,f是个普通的对象,没有prototype属性</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>constructor：constructor不需要手动创建，它是对象原型上的一个属性。Object.prototype.constructor，返回一个<strong>指向创建了该对象原型的函数引用</strong>。需要注意的是，该属性的值是那个函数本身，该属性为只读。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对于上面的例子：</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(F.constructor)</span><br><span class=\"line\"><span class=\"comment\">//Function() &#123; [native code] &#125;</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(f.constructor);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\"/\"</span>+<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5. 其他\"></a>5. 其他</h2><ul>\n<li>构造函数的首字母一般大写</li>\n<li>值类型赋值是值的复制</li>\n<li>对象类型的赋值不仅是值的复制也是引用的复制<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\">b.push(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">//a[1,2,3,4] b[1,2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    b = a;<span class=\"comment\">//值和引用都给了b</span></span><br><span class=\"line\">    b = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];<span class=\"comment\">// a[1,2,3] b[1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n"},{"title":"原生js实现class筛选器","date":"2017-03-29T16:00:00.000Z","_content":"\n可以从[can i use](http://caniuse.com/)网站查到getElementsByClassName方法兼容到IE9+（包含IE9），所以我们在前端面试中会经常被问到如何用原生的js去实现这个借口。\n\n\n## 1. 思考\n\n1. 我希望接口使用的方式如：getElementsByClassName(classname,parentId,tagname); \n    + classname为我们要筛选的class值，数组类型，如[\"tab\",\"tab-item\"]\n    + parentId为父元素的id，可选参数\n    + tagname为标签名，可选参数\n    + 返回一个包含匹配成功的节点的数组\n \n2. 尽可能多的使用已经存在的方法\n    + getElementsByTagName\n    + getElementById\n\n## 2. 思路\n\n1. 获取到符合要求的dom节点（node下的tag），是一个HTML Collection，是一个类数组，length属性缓存下来，查找代价比较大\n2. 我们获取到dom节点的className通常是一个string类型的。并且class容许顺序不一致。如“tab tab-item tab-active”与\"tab tab-active tab-item\"可以匹配的一样的css规则\n3. 我们使用正则匹配，将className拆成多个className正则。因为我们匹配css时需要每个className都必须匹配通过。（拆开也是因为class书写可以无序）\n4. dom节点的className进行正则匹配，通过所有匹配的则返回该节点\n\n## 3. 实现和效果\n\n```javascript\n    function getElementsByClassName(classname,parentId,tag){\n        var parentNode = parentId && document.getElementById(parentId) || document,\n                tagName = tag || '*',\n                classLength = classname.length,//获取我们需要筛选class的个数\n                classReg = [];//匹配class的正则\n    \n        for(var i=0;i<classLength;i++){\n            classReg[i] = new RegExp(\"(^|\\\\s)\"+classname[i]+\"(\\\\s|$)\",\"g\");//生成class匹配正则\n        }\n    \n        var elems = parentNode.getElementsByTagName(tagName),//获取到所有满足要求的dom节点\n                elemLength = elems.length,//elems是类数组，获取length属性代价比较大，所以缓存下来 3\n                result = [];//用于保存匹配成功的节点\n    \n        for(var j = 0;j < elemLength;j++){\n    \n            var elemTest = elems[j],//获取当前测试的节点\n                    elemTestClassName = elemTest.className;//获取当前测试节点的class属性，className兼容IE6+\n            //接下来开始对elemTestClassName进行匹配，看它是否匹配classReg中所有的规则\n    \n            var k=0;\n            while(classReg[k] && (classReg[k].test(elemTestClassName))){\n                console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n                //测试成功进来\n                if(k === classLength-1){\n                    //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n                    result[result.length] = elemTest;\n                    break;\n                }\n                k++;\n            }\n        }\n    \n        return result;\n    }\n```\n\n## 4. 问题总结\n\n#### 4.1 关于while{}循环的问题\n\n```javascript\n        var k=0;\n        while(classReg[k].test(elemTestClassName)){\n            console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n            //测试成功进来\n            if(k === classLength-1){\n                //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n                result[result.length] = elemTest;\n                break;\n            }\n            k++;\n        }\n        \n```\n\n上面的逻辑在执行过程中报错了`Uncaught TypeError: Cannot read property 'test' of undefined`，原因在于，循环结束时while还是执行一遍classReg[k].test(elemTestClassName)，而此时classReg[k]已经是undefined了。\n所以应该在while加上判断\n\n```javascript\n      var k=0;\n      while(classReg[k] && classReg[k].test(elemTestClassName)){\n          console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n          //测试成功进来\n          if(k === classLength-1){\n              //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n              result[result.length] = elemTest;\n              break;\n          }\n          k++;\n      }\n```\n\n#### 4.2 实例\n\n```html\n<div id=\"container\">\n    <span class=\"aaa zzz ccc\">1</span>\n    <div id=\"div1\" class=\"aaa    bbb   ccc\">2</div>\n</div>\n\n<div id=\"div2\" class=\"aaa ccc bbb\">3</div>\n```\n当我们使用上面的方法时会出现一个奇怪的现象，我现在还没搞明白，生气~~~\n\n```javascript\nvar a = getElementsByClassName([\"aaa\",\"ccc\"],document,\"div\");\nconsole.log(a);\n\n```\n\n看到while循环体中的`console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)))`了吗？加上这个console时，就能正确打印出两个dom节点[div#div1.aaa.bbb.ccc, div#div2.aaa.ccc.bbb]，注释掉的话，就只能找到[div#div1.aaa.bbb.ccc]。已疯！！！\n\n## 5. 关于上面问题的解决\n\n非常感谢小宁宝宝的推荐，一个人思考真的容易陷入死胡同。\n\n因为我在实例化正则的时候，加了全局标志“g”,那么第一次查找成功后，下一次匹配就从成功后的位置开始。而我的console里面改变了lastIndex的值，所以解决方案有两个\n\n1. 删除全局标志“g”。这是最根本的原因\n2. 不删除的话，那么就手动将每次的lastIndex置为0\n\n```javascript\n    while(classReg[k] && (classReg[k].test(elemTestClassName))){\n      // console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n        classReg[k].lastIndex = 0;\n        //测试成功进来\n        if(k === classLength-1){\n            //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n            result[result.length] = elemTest;\n            break;\n        }\n        k++;\n    }\n```\n\n## 6. 推荐阅读：\n\n+ [RegExp.test() returns different result for same str](http://stackoverflow.com/questions/13586786/regexp-test-returns-different-result-for-same-str-depending-on-how-where-i)\n+ [JavaScript RegExp.test() 函数详解](http://www.365mini.com/page/javascript-regexp-test.htm)\n\n--------------------------\n做一个勤于思考的人\n\n","source":"_posts/JS/原生js实现class筛选器.md","raw":"---\ntitle: 原生js实现class筛选器\ndate: 2017-03-30\ntags:\n  - 前端开发\n  - 个人成长\n  - JS\ncategories: JS\n---\n\n可以从[can i use](http://caniuse.com/)网站查到getElementsByClassName方法兼容到IE9+（包含IE9），所以我们在前端面试中会经常被问到如何用原生的js去实现这个借口。\n\n\n## 1. 思考\n\n1. 我希望接口使用的方式如：getElementsByClassName(classname,parentId,tagname); \n    + classname为我们要筛选的class值，数组类型，如[\"tab\",\"tab-item\"]\n    + parentId为父元素的id，可选参数\n    + tagname为标签名，可选参数\n    + 返回一个包含匹配成功的节点的数组\n \n2. 尽可能多的使用已经存在的方法\n    + getElementsByTagName\n    + getElementById\n\n## 2. 思路\n\n1. 获取到符合要求的dom节点（node下的tag），是一个HTML Collection，是一个类数组，length属性缓存下来，查找代价比较大\n2. 我们获取到dom节点的className通常是一个string类型的。并且class容许顺序不一致。如“tab tab-item tab-active”与\"tab tab-active tab-item\"可以匹配的一样的css规则\n3. 我们使用正则匹配，将className拆成多个className正则。因为我们匹配css时需要每个className都必须匹配通过。（拆开也是因为class书写可以无序）\n4. dom节点的className进行正则匹配，通过所有匹配的则返回该节点\n\n## 3. 实现和效果\n\n```javascript\n    function getElementsByClassName(classname,parentId,tag){\n        var parentNode = parentId && document.getElementById(parentId) || document,\n                tagName = tag || '*',\n                classLength = classname.length,//获取我们需要筛选class的个数\n                classReg = [];//匹配class的正则\n    \n        for(var i=0;i<classLength;i++){\n            classReg[i] = new RegExp(\"(^|\\\\s)\"+classname[i]+\"(\\\\s|$)\",\"g\");//生成class匹配正则\n        }\n    \n        var elems = parentNode.getElementsByTagName(tagName),//获取到所有满足要求的dom节点\n                elemLength = elems.length,//elems是类数组，获取length属性代价比较大，所以缓存下来 3\n                result = [];//用于保存匹配成功的节点\n    \n        for(var j = 0;j < elemLength;j++){\n    \n            var elemTest = elems[j],//获取当前测试的节点\n                    elemTestClassName = elemTest.className;//获取当前测试节点的class属性，className兼容IE6+\n            //接下来开始对elemTestClassName进行匹配，看它是否匹配classReg中所有的规则\n    \n            var k=0;\n            while(classReg[k] && (classReg[k].test(elemTestClassName))){\n                console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n                //测试成功进来\n                if(k === classLength-1){\n                    //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n                    result[result.length] = elemTest;\n                    break;\n                }\n                k++;\n            }\n        }\n    \n        return result;\n    }\n```\n\n## 4. 问题总结\n\n#### 4.1 关于while{}循环的问题\n\n```javascript\n        var k=0;\n        while(classReg[k].test(elemTestClassName)){\n            console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n            //测试成功进来\n            if(k === classLength-1){\n                //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n                result[result.length] = elemTest;\n                break;\n            }\n            k++;\n        }\n        \n```\n\n上面的逻辑在执行过程中报错了`Uncaught TypeError: Cannot read property 'test' of undefined`，原因在于，循环结束时while还是执行一遍classReg[k].test(elemTestClassName)，而此时classReg[k]已经是undefined了。\n所以应该在while加上判断\n\n```javascript\n      var k=0;\n      while(classReg[k] && classReg[k].test(elemTestClassName)){\n          console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n          //测试成功进来\n          if(k === classLength-1){\n              //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n              result[result.length] = elemTest;\n              break;\n          }\n          k++;\n      }\n```\n\n#### 4.2 实例\n\n```html\n<div id=\"container\">\n    <span class=\"aaa zzz ccc\">1</span>\n    <div id=\"div1\" class=\"aaa    bbb   ccc\">2</div>\n</div>\n\n<div id=\"div2\" class=\"aaa ccc bbb\">3</div>\n```\n当我们使用上面的方法时会出现一个奇怪的现象，我现在还没搞明白，生气~~~\n\n```javascript\nvar a = getElementsByClassName([\"aaa\",\"ccc\"],document,\"div\");\nconsole.log(a);\n\n```\n\n看到while循环体中的`console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)))`了吗？加上这个console时，就能正确打印出两个dom节点[div#div1.aaa.bbb.ccc, div#div2.aaa.ccc.bbb]，注释掉的话，就只能找到[div#div1.aaa.bbb.ccc]。已疯！！！\n\n## 5. 关于上面问题的解决\n\n非常感谢小宁宝宝的推荐，一个人思考真的容易陷入死胡同。\n\n因为我在实例化正则的时候，加了全局标志“g”,那么第一次查找成功后，下一次匹配就从成功后的位置开始。而我的console里面改变了lastIndex的值，所以解决方案有两个\n\n1. 删除全局标志“g”。这是最根本的原因\n2. 不删除的话，那么就手动将每次的lastIndex置为0\n\n```javascript\n    while(classReg[k] && (classReg[k].test(elemTestClassName))){\n      // console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));\n        classReg[k].lastIndex = 0;\n        //测试成功进来\n        if(k === classLength-1){\n            //如果通过所有测试，说明这个dom结果满足要求，我们push到结果中\n            result[result.length] = elemTest;\n            break;\n        }\n        k++;\n    }\n```\n\n## 6. 推荐阅读：\n\n+ [RegExp.test() returns different result for same str](http://stackoverflow.com/questions/13586786/regexp-test-returns-different-result-for-same-str-depending-on-how-where-i)\n+ [JavaScript RegExp.test() 函数详解](http://www.365mini.com/page/javascript-regexp-test.htm)\n\n--------------------------\n做一个勤于思考的人\n\n","slug":"JS/原生js实现class筛选器","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2m00099oxz5e57vzh6","content":"<p>可以从<a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\">can i use</a>网站查到getElementsByClassName方法兼容到IE9+（包含IE9），所以我们在前端面试中会经常被问到如何用原生的js去实现这个借口。</p>\n<h2 id=\"1-思考\"><a href=\"#1-思考\" class=\"headerlink\" title=\"1. 思考\"></a>1. 思考</h2><ol>\n<li><p>我希望接口使用的方式如：getElementsByClassName(classname,parentId,tagname); </p>\n<ul>\n<li>classname为我们要筛选的class值，数组类型，如[“tab”,”tab-item”]</li>\n<li>parentId为父元素的id，可选参数</li>\n<li>tagname为标签名，可选参数</li>\n<li>返回一个包含匹配成功的节点的数组</li>\n</ul>\n</li>\n<li><p>尽可能多的使用已经存在的方法</p>\n<ul>\n<li>getElementsByTagName</li>\n<li>getElementById</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-思路\"><a href=\"#2-思路\" class=\"headerlink\" title=\"2. 思路\"></a>2. 思路</h2><ol>\n<li>获取到符合要求的dom节点（node下的tag），是一个HTML Collection，是一个类数组，length属性缓存下来，查找代价比较大</li>\n<li>我们获取到dom节点的className通常是一个string类型的。并且class容许顺序不一致。如“tab tab-item tab-active”与”tab tab-active tab-item”可以匹配的一样的css规则</li>\n<li>我们使用正则匹配，将className拆成多个className正则。因为我们匹配css时需要每个className都必须匹配通过。（拆开也是因为class书写可以无序）</li>\n<li>dom节点的className进行正则匹配，通过所有匹配的则返回该节点</li>\n</ol>\n<h2 id=\"3-实现和效果\"><a href=\"#3-实现和效果\" class=\"headerlink\" title=\"3. 实现和效果\"></a>3. 实现和效果</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getElementsByClassName</span>(<span class=\"params\">classname,parentId,tag</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parentNode = parentId &amp;&amp; <span class=\"built_in\">document</span>.getElementById(parentId) || <span class=\"built_in\">document</span>,</span><br><span class=\"line\">            tagName = tag || <span class=\"string\">'*'</span>,</span><br><span class=\"line\">            classLength = classname.length,<span class=\"comment\">//获取我们需要筛选class的个数</span></span><br><span class=\"line\">            classReg = [];<span class=\"comment\">//匹配class的正则</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;classLength;i++)&#123;</span><br><span class=\"line\">        classReg[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|\\\\s)\"</span>+classname[i]+<span class=\"string\">\"(\\\\s|$)\"</span>,<span class=\"string\">\"g\"</span>);<span class=\"comment\">//生成class匹配正则</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> elems = parentNode.getElementsByTagName(tagName),<span class=\"comment\">//获取到所有满足要求的dom节点</span></span><br><span class=\"line\">            elemLength = elems.length,<span class=\"comment\">//elems是类数组，获取length属性代价比较大，所以缓存下来 3</span></span><br><span class=\"line\">            result = [];<span class=\"comment\">//用于保存匹配成功的节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>;j &lt; elemLength;j++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> elemTest = elems[j],<span class=\"comment\">//获取当前测试的节点</span></span><br><span class=\"line\">                elemTestClassName = elemTest.className;<span class=\"comment\">//获取当前测试节点的class属性，className兼容IE6+</span></span><br><span class=\"line\">        <span class=\"comment\">//接下来开始对elemTestClassName进行匹配，看它是否匹配classReg中所有的规则</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(classReg[k] &amp;&amp; (classReg[k].test(elemTestClassName)))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(classReg[k]+<span class=\"string\">\":\"</span>+elemTestClassName+<span class=\"string\">\":\"</span>+(classReg[k].test(elemTestClassName)));</span><br><span class=\"line\">            <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">                result[result.length] = elemTest;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-问题总结\"><a href=\"#4-问题总结\" class=\"headerlink\" title=\"4. 问题总结\"></a>4. 问题总结</h2><h4 id=\"4-1-关于while-循环的问题\"><a href=\"#4-1-关于while-循环的问题\" class=\"headerlink\" title=\"4.1 关于while{}循环的问题\"></a>4.1 关于while{}循环的问题</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(classReg[k].test(elemTestClassName))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(classReg[k]+<span class=\"string\">\":\"</span>+elemTestClassName+<span class=\"string\">\":\"</span>+(classReg[k].test(elemTestClassName)));</span><br><span class=\"line\">    <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">        result[result.length] = elemTest;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑在执行过程中报错了<code>Uncaught TypeError: Cannot read property &#39;test&#39; of undefined</code>，原因在于，循环结束时while还是执行一遍classReg[k].test(elemTestClassName)，而此时classReg[k]已经是undefined了。<br>所以应该在while加上判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(classReg[k] &amp;&amp; classReg[k].test(elemTestClassName))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(classReg[k]+<span class=\"string\">\":\"</span>+elemTestClassName+<span class=\"string\">\":\"</span>+(classReg[k].test(elemTestClassName)));</span><br><span class=\"line\">    <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">        result[result.length] = elemTest;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-实例\"><a href=\"#4-2-实例\" class=\"headerlink\" title=\"4.2 实例\"></a>4.2 实例</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa zzz ccc\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"div1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa    bbb   ccc\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"div2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa ccc bbb\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们使用上面的方法时会出现一个奇怪的现象，我现在还没搞明白，生气~~~</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = getElementsByClassName([<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"ccc\"</span>],<span class=\"built_in\">document</span>,<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>看到while循环体中的<code>console.log(classReg[k]+&quot;:&quot;+elemTestClassName+&quot;:&quot;+(classReg[k].test(elemTestClassName)))</code>了吗？加上这个console时，就能正确打印出两个dom节点[div#div1.aaa.bbb.ccc, div#div2.aaa.ccc.bbb]，注释掉的话，就只能找到[div#div1.aaa.bbb.ccc]。已疯！！！</p>\n<h2 id=\"5-关于上面问题的解决\"><a href=\"#5-关于上面问题的解决\" class=\"headerlink\" title=\"5. 关于上面问题的解决\"></a>5. 关于上面问题的解决</h2><p>非常感谢小宁宝宝的推荐，一个人思考真的容易陷入死胡同。</p>\n<p>因为我在实例化正则的时候，加了全局标志“g”,那么第一次查找成功后，下一次匹配就从成功后的位置开始。而我的console里面改变了lastIndex的值，所以解决方案有两个</p>\n<ol>\n<li>删除全局标志“g”。这是最根本的原因</li>\n<li>不删除的话，那么就手动将每次的lastIndex置为0</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(classReg[k] &amp;&amp; (classReg[k].test(elemTestClassName)))&#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));</span></span><br><span class=\"line\">    classReg[k].lastIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">        result[result.length] = elemTest;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-推荐阅读：\"><a href=\"#6-推荐阅读：\" class=\"headerlink\" title=\"6. 推荐阅读：\"></a>6. 推荐阅读：</h2><ul>\n<li><a href=\"http://stackoverflow.com/questions/13586786/regexp-test-returns-different-result-for-same-str-depending-on-how-where-i\" target=\"_blank\" rel=\"noopener\">RegExp.test() returns different result for same str</a></li>\n<li><a href=\"http://www.365mini.com/page/javascript-regexp-test.htm\" target=\"_blank\" rel=\"noopener\">JavaScript RegExp.test() 函数详解</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n","site":{"data":{}},"excerpt":"","more":"<p>可以从<a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\">can i use</a>网站查到getElementsByClassName方法兼容到IE9+（包含IE9），所以我们在前端面试中会经常被问到如何用原生的js去实现这个借口。</p>\n<h2 id=\"1-思考\"><a href=\"#1-思考\" class=\"headerlink\" title=\"1. 思考\"></a>1. 思考</h2><ol>\n<li><p>我希望接口使用的方式如：getElementsByClassName(classname,parentId,tagname); </p>\n<ul>\n<li>classname为我们要筛选的class值，数组类型，如[“tab”,”tab-item”]</li>\n<li>parentId为父元素的id，可选参数</li>\n<li>tagname为标签名，可选参数</li>\n<li>返回一个包含匹配成功的节点的数组</li>\n</ul>\n</li>\n<li><p>尽可能多的使用已经存在的方法</p>\n<ul>\n<li>getElementsByTagName</li>\n<li>getElementById</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-思路\"><a href=\"#2-思路\" class=\"headerlink\" title=\"2. 思路\"></a>2. 思路</h2><ol>\n<li>获取到符合要求的dom节点（node下的tag），是一个HTML Collection，是一个类数组，length属性缓存下来，查找代价比较大</li>\n<li>我们获取到dom节点的className通常是一个string类型的。并且class容许顺序不一致。如“tab tab-item tab-active”与”tab tab-active tab-item”可以匹配的一样的css规则</li>\n<li>我们使用正则匹配，将className拆成多个className正则。因为我们匹配css时需要每个className都必须匹配通过。（拆开也是因为class书写可以无序）</li>\n<li>dom节点的className进行正则匹配，通过所有匹配的则返回该节点</li>\n</ol>\n<h2 id=\"3-实现和效果\"><a href=\"#3-实现和效果\" class=\"headerlink\" title=\"3. 实现和效果\"></a>3. 实现和效果</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getElementsByClassName</span>(<span class=\"params\">classname,parentId,tag</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parentNode = parentId &amp;&amp; <span class=\"built_in\">document</span>.getElementById(parentId) || <span class=\"built_in\">document</span>,</span><br><span class=\"line\">            tagName = tag || <span class=\"string\">'*'</span>,</span><br><span class=\"line\">            classLength = classname.length,<span class=\"comment\">//获取我们需要筛选class的个数</span></span><br><span class=\"line\">            classReg = [];<span class=\"comment\">//匹配class的正则</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;classLength;i++)&#123;</span><br><span class=\"line\">        classReg[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|\\\\s)\"</span>+classname[i]+<span class=\"string\">\"(\\\\s|$)\"</span>,<span class=\"string\">\"g\"</span>);<span class=\"comment\">//生成class匹配正则</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> elems = parentNode.getElementsByTagName(tagName),<span class=\"comment\">//获取到所有满足要求的dom节点</span></span><br><span class=\"line\">            elemLength = elems.length,<span class=\"comment\">//elems是类数组，获取length属性代价比较大，所以缓存下来 3</span></span><br><span class=\"line\">            result = [];<span class=\"comment\">//用于保存匹配成功的节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>;j &lt; elemLength;j++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> elemTest = elems[j],<span class=\"comment\">//获取当前测试的节点</span></span><br><span class=\"line\">                elemTestClassName = elemTest.className;<span class=\"comment\">//获取当前测试节点的class属性，className兼容IE6+</span></span><br><span class=\"line\">        <span class=\"comment\">//接下来开始对elemTestClassName进行匹配，看它是否匹配classReg中所有的规则</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(classReg[k] &amp;&amp; (classReg[k].test(elemTestClassName)))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(classReg[k]+<span class=\"string\">\":\"</span>+elemTestClassName+<span class=\"string\">\":\"</span>+(classReg[k].test(elemTestClassName)));</span><br><span class=\"line\">            <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">                result[result.length] = elemTest;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-问题总结\"><a href=\"#4-问题总结\" class=\"headerlink\" title=\"4. 问题总结\"></a>4. 问题总结</h2><h4 id=\"4-1-关于while-循环的问题\"><a href=\"#4-1-关于while-循环的问题\" class=\"headerlink\" title=\"4.1 关于while{}循环的问题\"></a>4.1 关于while{}循环的问题</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(classReg[k].test(elemTestClassName))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(classReg[k]+<span class=\"string\">\":\"</span>+elemTestClassName+<span class=\"string\">\":\"</span>+(classReg[k].test(elemTestClassName)));</span><br><span class=\"line\">    <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">        result[result.length] = elemTest;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑在执行过程中报错了<code>Uncaught TypeError: Cannot read property &#39;test&#39; of undefined</code>，原因在于，循环结束时while还是执行一遍classReg[k].test(elemTestClassName)，而此时classReg[k]已经是undefined了。<br>所以应该在while加上判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(classReg[k] &amp;&amp; classReg[k].test(elemTestClassName))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(classReg[k]+<span class=\"string\">\":\"</span>+elemTestClassName+<span class=\"string\">\":\"</span>+(classReg[k].test(elemTestClassName)));</span><br><span class=\"line\">    <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">        result[result.length] = elemTest;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-实例\"><a href=\"#4-2-实例\" class=\"headerlink\" title=\"4.2 实例\"></a>4.2 实例</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa zzz ccc\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"div1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa    bbb   ccc\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"div2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa ccc bbb\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们使用上面的方法时会出现一个奇怪的现象，我现在还没搞明白，生气~~~</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = getElementsByClassName([<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"ccc\"</span>],<span class=\"built_in\">document</span>,<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>看到while循环体中的<code>console.log(classReg[k]+&quot;:&quot;+elemTestClassName+&quot;:&quot;+(classReg[k].test(elemTestClassName)))</code>了吗？加上这个console时，就能正确打印出两个dom节点[div#div1.aaa.bbb.ccc, div#div2.aaa.ccc.bbb]，注释掉的话，就只能找到[div#div1.aaa.bbb.ccc]。已疯！！！</p>\n<h2 id=\"5-关于上面问题的解决\"><a href=\"#5-关于上面问题的解决\" class=\"headerlink\" title=\"5. 关于上面问题的解决\"></a>5. 关于上面问题的解决</h2><p>非常感谢小宁宝宝的推荐，一个人思考真的容易陷入死胡同。</p>\n<p>因为我在实例化正则的时候，加了全局标志“g”,那么第一次查找成功后，下一次匹配就从成功后的位置开始。而我的console里面改变了lastIndex的值，所以解决方案有两个</p>\n<ol>\n<li>删除全局标志“g”。这是最根本的原因</li>\n<li>不删除的话，那么就手动将每次的lastIndex置为0</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(classReg[k] &amp;&amp; (classReg[k].test(elemTestClassName)))&#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(classReg[k]+\":\"+elemTestClassName+\":\"+(classReg[k].test(elemTestClassName)));</span></span><br><span class=\"line\">    classReg[k].lastIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//测试成功进来</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k === classLength<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果通过所有测试，说明这个dom结果满足要求，我们push到结果中</span></span><br><span class=\"line\">        result[result.length] = elemTest;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-推荐阅读：\"><a href=\"#6-推荐阅读：\" class=\"headerlink\" title=\"6. 推荐阅读：\"></a>6. 推荐阅读：</h2><ul>\n<li><a href=\"http://stackoverflow.com/questions/13586786/regexp-test-returns-different-result-for-same-str-depending-on-how-where-i\" target=\"_blank\" rel=\"noopener\">RegExp.test() returns different result for same str</a></li>\n<li><a href=\"http://www.365mini.com/page/javascript-regexp-test.htm\" target=\"_blank\" rel=\"noopener\">JavaScript RegExp.test() 函数详解</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n"},{"title":"2017个人规划","date":"2017-01-13T14:48:53.000Z","_content":"\n#### 种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\n\n\n#### 没有清楚的自身定位,才会在做选择的时候犹豫,才会经常迷茫,需要向别人求助。\n\n\n#### 之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\n\n#### 毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\n\n\n\n-----\n\n做个会思考的人~","source":"_posts/个人成长/2017-01-13-plan.md","raw":"---\ntitle: 2017个人规划\ndate: 2017-01-13 22:48:53\ntags:\n  - 前端开发\n  - 个人成长\ncategories: 个人成长\n---\n\n#### 种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\n\n\n#### 没有清楚的自身定位,才会在做选择的时候犹豫,才会经常迷茫,需要向别人求助。\n\n\n#### 之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\n\n#### 毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\n\n\n\n-----\n\n做个会思考的人~","slug":"个人成长/2017-01-13-plan","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2n000a9oxzy1we6l0t","content":"<h4 id=\"种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\"><a href=\"#种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\" class=\"headerlink\" title=\"种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\"></a>种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！</h4><h4 id=\"没有清楚的自身定位-才会在做选择的时候犹豫-才会经常迷茫-需要向别人求助。\"><a href=\"#没有清楚的自身定位-才会在做选择的时候犹豫-才会经常迷茫-需要向别人求助。\" class=\"headerlink\" title=\"没有清楚的自身定位,才会在做选择的时候犹豫,才会经常迷茫,需要向别人求助。\"></a>没有清楚的自身定位,才会在做选择的时候犹豫,才会经常迷茫,需要向别人求助。</h4><h4 id=\"之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\"><a href=\"#之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\" class=\"headerlink\" title=\"之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\"></a>之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。</h4><h4 id=\"毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\"><a href=\"#毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\" class=\"headerlink\" title=\"毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\"></a>毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。</h4><hr>\n<p>做个会思考的人~</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\"><a href=\"#种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\" class=\"headerlink\" title=\"种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！\"></a>种树最好的时间不是10年前，而是现在！那么从现在开始，要给自己的2017一个规划，每天都要有成长！</h4><h4 id=\"没有清楚的自身定位-才会在做选择的时候犹豫-才会经常迷茫-需要向别人求助。\"><a href=\"#没有清楚的自身定位-才会在做选择的时候犹豫-才会经常迷茫-需要向别人求助。\" class=\"headerlink\" title=\"没有清楚的自身定位,才会在做选择的时候犹豫,才会经常迷茫,需要向别人求助。\"></a>没有清楚的自身定位,才会在做选择的时候犹豫,才会经常迷茫,需要向别人求助。</h4><h4 id=\"之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\"><a href=\"#之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\" class=\"headerlink\" title=\"之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。\"></a>之前的一年里没有系统的知识管理，一直零零散散的记录不成体系。接下来的17年给自己一个新的规划，有计划有体系的成长。</h4><h4 id=\"毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\"><a href=\"#毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\" class=\"headerlink\" title=\"毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。\"></a>毕业也快2年了，如果3年内知识结构缺口很大的话，很快会被淘汰，要有危机意识。</h4><hr>\n<p>做个会思考的人~</p>\n"},{"title":"前端资料总结","date":"2017-02-20T16:00:00.000Z","_content":"\n\n## 1. 移动端\n\n+ [js中flexible.js实现淘宝弹性布局方案](http://www.jb51.net/article/76893.htm)\n+ [Zepto中文API](http://www.bootcss.com/p/zeptojs/)\n+ [从淘宝适配布局谈移动端适配](http://www.qdfuns.com/notes/23659/5e3cd2904a56f5e6b86c4d49e90e0f34.html?winzoom=1)\n\n\n## 2. HTML\n\n+ [HTML5的文档节段和纲要](https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document)\n+ [HTML占位符对照表](http://tool.oschina.net/commons?type=2)\n\n\n## 3. JS\n\n+ [ECMAScript 6 入门](http://es6.ruanyifeng.com/)\n+ [js插件编写规范](http://www.cnblogs.com/fingerdancing/archive/2013/04/30/jsPlugin.html)\n+ [jQuery插件开发入门](http://www.css88.com/archives/4821)\n+ [gulp编写插件](http://www.gulpjs.com.cn/docs/writing-a-plugin/)\n+ [jQuery插件开发入门](http://www.css88.com/archives/4821)\n+ [gulpjs官网](http://www.gulpjs.com.cn/)\n+ [EcmaScript5.1](http://lzw.me/pages/ecmascript/)\n+ [https://segmentfault.com/a/1190000005128101](https://segmentfault.com/a/1190000005128101)\n+ [gulp学习资料整理](https://github.com/Platform-CUF/use-gulp)\n+ [webpack中文指南](http://webpackdoc.com/)\n\n### 4. 模块化\n+ [CommonJS 模块规范 1.1.1](http://www.cnblogs.com/ifantastic/p/4648329.html)\n+ [使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript](http://justineo.github.io/singles/writing-modular-js/)\n+ [why amd](http://requirejs.org/docs/whyamd.html)\n+ [浏览器加载 CommonJS 模块的原理与实现](http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html)\n+ [JavaSript模块规范 - AMD规范与CMD规范介绍 ](http://blog.chinaunix.net/uid-26672038-id-4112229.html)\n\n\n\n## 5. 浏览器\n\n+ [从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/?qq-pf-to=pcqq.c2c)\n+ [Chrome 开发者工具中文指南](http://www.jianshu.com/p/cf36d48652f4)\n+ [How Rendering Work (in WebKit and Blink)](http://blog.csdn.net/rogeryi/article/details/23686609)\n+ [浏览器渲染发展的一些思考](http://blog.csdn.net/rogeryi/article/details/17657779)\n+ [Chromium网页Render Object Tree创建过程分析](http://blog.csdn.net/luoshengyang/article/details/50615628)\n+ [Chromium网页Render Layer Tree创建过程分析](http://blog.csdn.net/luoshengyang/article/details/50648792)\n+ [Chromium网页Graphics Layer Tree创建过程分析](http://blog.csdn.net/luoshengyang/article/details/50661553)\n\n\n\n## 6. React\n\n+ [RN中文网](http://reactnative.cn/)\n\n## 7. node\n\n+ [nodeschool](http://nodeschool.io/zh-cn/)\n+ [如何系统地学习Node.js？](https://www.zhihu.com/question/21567720)\n+ [node-interview-questions](https://github.com/jimuyouyou/node-interview-questions#%E8%B5%B7%E6%BA%90)\n+ [Node.js 教程](http://www.runoob.com/nodejs/nodejs-tutorial.html)\n+ [express API](http://expressjs.jser.us/api)\n+ [Mongoose学习参考文档](https://cnodejs.org/topic/504b4924e2b84515770103dd)\n+ [8天学通MongoDB——第一天 基础入门](http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html)\n+ [在express站点中使用ejs模板引擎](http://www.cnblogs.com/xuanhun/p/3922847.html)\n\n\n\n## 8. CSS\n+ [bootcss](http://www.bootcss.com/)\n+ [WEB安全色](http://www.bootcss.com/p/websafecolors/)\n\n## 9. 个人\n\n+ [github](https://github.com/xujiao1989)\n+ [个人博客](http://www.xujiaosite.com/)\n\n\n## 10. 其他\n\n+ [淘宝 NPM 镜像](http://npm.taobao.org/)\n+ [leetcode](https://leetcode.com/)\n+ [can i use](http://caniuse.com/)\n+ [阿里巴巴的iconfont](http://www.iconfont.cn/plus)\n\n## 11. 图片素材\n+ [千图网](http://www.58pic.com/)\n+ [千库网](http://588ku.com/?h=bd)\n\n### 12. 博客搭建\n\n+ [NexT使用文档](http://theme-next.iissnan.com/)\n+ [如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2)\n+ [手把手教你使用Hexo + Github Pages搭建个人独立博客](https://segmentfault.com/a/1190000004947261)\n+ [为NexT主题添加文章阅读量统计功能](https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud)\n+ [godaddy域名购买](https://cart.godaddy.com/EmptyCart.aspx?isc=cjc2off30)\n+ [DNS注册](https://www.dnspod.cn/Login)\n\n\n\n## 牛人博客\n\n+ [Haorooms](http://www.haorooms.com/)\n+ [前端网址导航](http://www.whycss.com/)\n+ [廖雪峰的官方网站](http://www.liaoxuefeng.com/)\n+ [前端网址导航](http://www.whycss.com/)\n+ [Haorooms](http://www.haorooms.com/)\n+ [前端网址导航](http://www.whycss.com/)\n+ [前端网](http://www.qdfuns.com/)\n+ [百度FEX](http://fex.baidu.com/)\n+ [美团FE博客](http://fe.meituan.com/)\n+ [YUI3在美团的实践](http://fe.meituan.com/yui3-practice.html)\n+ [scrat的webapp模块化开发体系](http://scrat.io/#!/index)\n+ [阮一峰个人博客](http://www.ruanyifeng.com/home.html)\n+ [史蒂夫周-mac软件破解](http://www.sdifenzhou.com/)\n+ [妙味课堂](http://2017.miaov.com/)\n+ [百度FEX](http://fex.baidu.com/)\n+ [玉伯的博客](https://lifesinger.wordpress.com/)\n+ [好用的工具导航](https://blog.thankbabe.com/collection/)\n\n\n","source":"_posts/个人成长/前端资料总结.md","raw":"---\ntitle: 前端资料总结\ndate: 2017-02-21 \ntags:\n  - 前端开发\n  - 前端资料总结\n  - JavaScript、HTML、CSS、Node\ncategories: 个人成长\n---\n\n\n## 1. 移动端\n\n+ [js中flexible.js实现淘宝弹性布局方案](http://www.jb51.net/article/76893.htm)\n+ [Zepto中文API](http://www.bootcss.com/p/zeptojs/)\n+ [从淘宝适配布局谈移动端适配](http://www.qdfuns.com/notes/23659/5e3cd2904a56f5e6b86c4d49e90e0f34.html?winzoom=1)\n\n\n## 2. HTML\n\n+ [HTML5的文档节段和纲要](https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document)\n+ [HTML占位符对照表](http://tool.oschina.net/commons?type=2)\n\n\n## 3. JS\n\n+ [ECMAScript 6 入门](http://es6.ruanyifeng.com/)\n+ [js插件编写规范](http://www.cnblogs.com/fingerdancing/archive/2013/04/30/jsPlugin.html)\n+ [jQuery插件开发入门](http://www.css88.com/archives/4821)\n+ [gulp编写插件](http://www.gulpjs.com.cn/docs/writing-a-plugin/)\n+ [jQuery插件开发入门](http://www.css88.com/archives/4821)\n+ [gulpjs官网](http://www.gulpjs.com.cn/)\n+ [EcmaScript5.1](http://lzw.me/pages/ecmascript/)\n+ [https://segmentfault.com/a/1190000005128101](https://segmentfault.com/a/1190000005128101)\n+ [gulp学习资料整理](https://github.com/Platform-CUF/use-gulp)\n+ [webpack中文指南](http://webpackdoc.com/)\n\n### 4. 模块化\n+ [CommonJS 模块规范 1.1.1](http://www.cnblogs.com/ifantastic/p/4648329.html)\n+ [使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript](http://justineo.github.io/singles/writing-modular-js/)\n+ [why amd](http://requirejs.org/docs/whyamd.html)\n+ [浏览器加载 CommonJS 模块的原理与实现](http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html)\n+ [JavaSript模块规范 - AMD规范与CMD规范介绍 ](http://blog.chinaunix.net/uid-26672038-id-4112229.html)\n\n\n\n## 5. 浏览器\n\n+ [从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/?qq-pf-to=pcqq.c2c)\n+ [Chrome 开发者工具中文指南](http://www.jianshu.com/p/cf36d48652f4)\n+ [How Rendering Work (in WebKit and Blink)](http://blog.csdn.net/rogeryi/article/details/23686609)\n+ [浏览器渲染发展的一些思考](http://blog.csdn.net/rogeryi/article/details/17657779)\n+ [Chromium网页Render Object Tree创建过程分析](http://blog.csdn.net/luoshengyang/article/details/50615628)\n+ [Chromium网页Render Layer Tree创建过程分析](http://blog.csdn.net/luoshengyang/article/details/50648792)\n+ [Chromium网页Graphics Layer Tree创建过程分析](http://blog.csdn.net/luoshengyang/article/details/50661553)\n\n\n\n## 6. React\n\n+ [RN中文网](http://reactnative.cn/)\n\n## 7. node\n\n+ [nodeschool](http://nodeschool.io/zh-cn/)\n+ [如何系统地学习Node.js？](https://www.zhihu.com/question/21567720)\n+ [node-interview-questions](https://github.com/jimuyouyou/node-interview-questions#%E8%B5%B7%E6%BA%90)\n+ [Node.js 教程](http://www.runoob.com/nodejs/nodejs-tutorial.html)\n+ [express API](http://expressjs.jser.us/api)\n+ [Mongoose学习参考文档](https://cnodejs.org/topic/504b4924e2b84515770103dd)\n+ [8天学通MongoDB——第一天 基础入门](http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html)\n+ [在express站点中使用ejs模板引擎](http://www.cnblogs.com/xuanhun/p/3922847.html)\n\n\n\n## 8. CSS\n+ [bootcss](http://www.bootcss.com/)\n+ [WEB安全色](http://www.bootcss.com/p/websafecolors/)\n\n## 9. 个人\n\n+ [github](https://github.com/xujiao1989)\n+ [个人博客](http://www.xujiaosite.com/)\n\n\n## 10. 其他\n\n+ [淘宝 NPM 镜像](http://npm.taobao.org/)\n+ [leetcode](https://leetcode.com/)\n+ [can i use](http://caniuse.com/)\n+ [阿里巴巴的iconfont](http://www.iconfont.cn/plus)\n\n## 11. 图片素材\n+ [千图网](http://www.58pic.com/)\n+ [千库网](http://588ku.com/?h=bd)\n\n### 12. 博客搭建\n\n+ [NexT使用文档](http://theme-next.iissnan.com/)\n+ [如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2)\n+ [手把手教你使用Hexo + Github Pages搭建个人独立博客](https://segmentfault.com/a/1190000004947261)\n+ [为NexT主题添加文章阅读量统计功能](https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud)\n+ [godaddy域名购买](https://cart.godaddy.com/EmptyCart.aspx?isc=cjc2off30)\n+ [DNS注册](https://www.dnspod.cn/Login)\n\n\n\n## 牛人博客\n\n+ [Haorooms](http://www.haorooms.com/)\n+ [前端网址导航](http://www.whycss.com/)\n+ [廖雪峰的官方网站](http://www.liaoxuefeng.com/)\n+ [前端网址导航](http://www.whycss.com/)\n+ [Haorooms](http://www.haorooms.com/)\n+ [前端网址导航](http://www.whycss.com/)\n+ [前端网](http://www.qdfuns.com/)\n+ [百度FEX](http://fex.baidu.com/)\n+ [美团FE博客](http://fe.meituan.com/)\n+ [YUI3在美团的实践](http://fe.meituan.com/yui3-practice.html)\n+ [scrat的webapp模块化开发体系](http://scrat.io/#!/index)\n+ [阮一峰个人博客](http://www.ruanyifeng.com/home.html)\n+ [史蒂夫周-mac软件破解](http://www.sdifenzhou.com/)\n+ [妙味课堂](http://2017.miaov.com/)\n+ [百度FEX](http://fex.baidu.com/)\n+ [玉伯的博客](https://lifesinger.wordpress.com/)\n+ [好用的工具导航](https://blog.thankbabe.com/collection/)\n\n\n","slug":"个人成长/前端资料总结","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2s000d9oxz7ez4pnrw","content":"<h2 id=\"1-移动端\"><a href=\"#1-移动端\" class=\"headerlink\" title=\"1. 移动端\"></a>1. 移动端</h2><ul>\n<li><a href=\"http://www.jb51.net/article/76893.htm\" target=\"_blank\" rel=\"noopener\">js中flexible.js实现淘宝弹性布局方案</a></li>\n<li><a href=\"http://www.bootcss.com/p/zeptojs/\" target=\"_blank\" rel=\"noopener\">Zepto中文API</a></li>\n<li><a href=\"http://www.qdfuns.com/notes/23659/5e3cd2904a56f5e6b86c4d49e90e0f34.html?winzoom=1\" target=\"_blank\" rel=\"noopener\">从淘宝适配布局谈移动端适配</a></li>\n</ul>\n<h2 id=\"2-HTML\"><a href=\"#2-HTML\" class=\"headerlink\" title=\"2. HTML\"></a>2. HTML</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document\" target=\"_blank\" rel=\"noopener\">HTML5的文档节段和纲要</a></li>\n<li><a href=\"http://tool.oschina.net/commons?type=2\" target=\"_blank\" rel=\"noopener\">HTML占位符对照表</a></li>\n</ul>\n<h2 id=\"3-JS\"><a href=\"#3-JS\" class=\"headerlink\" title=\"3. JS\"></a>3. JS</h2><ul>\n<li><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a></li>\n<li><a href=\"http://www.cnblogs.com/fingerdancing/archive/2013/04/30/jsPlugin.html\" target=\"_blank\" rel=\"noopener\">js插件编写规范</a></li>\n<li><a href=\"http://www.css88.com/archives/4821\" target=\"_blank\" rel=\"noopener\">jQuery插件开发入门</a></li>\n<li><a href=\"http://www.gulpjs.com.cn/docs/writing-a-plugin/\" target=\"_blank\" rel=\"noopener\">gulp编写插件</a></li>\n<li><a href=\"http://www.css88.com/archives/4821\" target=\"_blank\" rel=\"noopener\">jQuery插件开发入门</a></li>\n<li><a href=\"http://www.gulpjs.com.cn/\" target=\"_blank\" rel=\"noopener\">gulpjs官网</a></li>\n<li><a href=\"http://lzw.me/pages/ecmascript/\" target=\"_blank\" rel=\"noopener\">EcmaScript5.1</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000005128101\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000005128101</a></li>\n<li><a href=\"https://github.com/Platform-CUF/use-gulp\" target=\"_blank\" rel=\"noopener\">gulp学习资料整理</a></li>\n<li><a href=\"http://webpackdoc.com/\" target=\"_blank\" rel=\"noopener\">webpack中文指南</a></li>\n</ul>\n<h3 id=\"4-模块化\"><a href=\"#4-模块化\" class=\"headerlink\" title=\"4. 模块化\"></a>4. 模块化</h3><ul>\n<li><a href=\"http://www.cnblogs.com/ifantastic/p/4648329.html\" target=\"_blank\" rel=\"noopener\">CommonJS 模块规范 1.1.1</a></li>\n<li><a href=\"http://justineo.github.io/singles/writing-modular-js/\" target=\"_blank\" rel=\"noopener\">使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript</a></li>\n<li><a href=\"http://requirejs.org/docs/whyamd.html\" target=\"_blank\" rel=\"noopener\">why amd</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html\" target=\"_blank\" rel=\"noopener\">浏览器加载 CommonJS 模块的原理与实现</a></li>\n<li><a href=\"http://blog.chinaunix.net/uid-26672038-id-4112229.html\" target=\"_blank\" rel=\"noopener\">JavaSript模块规范 - AMD规范与CMD规范介绍 </a></li>\n</ul>\n<h2 id=\"5-浏览器\"><a href=\"#5-浏览器\" class=\"headerlink\" title=\"5. 浏览器\"></a>5. 浏览器</h2><ul>\n<li><a href=\"http://fex.baidu.com/blog/2014/05/what-happen/?qq-pf-to=pcqq.c2c\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li>\n<li><a href=\"http://www.jianshu.com/p/cf36d48652f4\" target=\"_blank\" rel=\"noopener\">Chrome 开发者工具中文指南</a></li>\n<li><a href=\"http://blog.csdn.net/rogeryi/article/details/23686609\" target=\"_blank\" rel=\"noopener\">How Rendering Work (in WebKit and Blink)</a></li>\n<li><a href=\"http://blog.csdn.net/rogeryi/article/details/17657779\" target=\"_blank\" rel=\"noopener\">浏览器渲染发展的一些思考</a></li>\n<li><a href=\"http://blog.csdn.net/luoshengyang/article/details/50615628\" target=\"_blank\" rel=\"noopener\">Chromium网页Render Object Tree创建过程分析</a></li>\n<li><a href=\"http://blog.csdn.net/luoshengyang/article/details/50648792\" target=\"_blank\" rel=\"noopener\">Chromium网页Render Layer Tree创建过程分析</a></li>\n<li><a href=\"http://blog.csdn.net/luoshengyang/article/details/50661553\" target=\"_blank\" rel=\"noopener\">Chromium网页Graphics Layer Tree创建过程分析</a></li>\n</ul>\n<h2 id=\"6-React\"><a href=\"#6-React\" class=\"headerlink\" title=\"6. React\"></a>6. React</h2><ul>\n<li><a href=\"http://reactnative.cn/\" target=\"_blank\" rel=\"noopener\">RN中文网</a></li>\n</ul>\n<h2 id=\"7-node\"><a href=\"#7-node\" class=\"headerlink\" title=\"7. node\"></a>7. node</h2><ul>\n<li><a href=\"http://nodeschool.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">nodeschool</a></li>\n<li><a href=\"https://www.zhihu.com/question/21567720\" target=\"_blank\" rel=\"noopener\">如何系统地学习Node.js？</a></li>\n<li><a href=\"https://github.com/jimuyouyou/node-interview-questions#%E8%B5%B7%E6%BA%90\" target=\"_blank\" rel=\"noopener\">node-interview-questions</a></li>\n<li><a href=\"http://www.runoob.com/nodejs/nodejs-tutorial.html\" target=\"_blank\" rel=\"noopener\">Node.js 教程</a></li>\n<li><a href=\"http://expressjs.jser.us/api\" target=\"_blank\" rel=\"noopener\">express API</a></li>\n<li><a href=\"https://cnodejs.org/topic/504b4924e2b84515770103dd\" target=\"_blank\" rel=\"noopener\">Mongoose学习参考文档</a></li>\n<li><a href=\"http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html\" target=\"_blank\" rel=\"noopener\">8天学通MongoDB——第一天 基础入门</a></li>\n<li><a href=\"http://www.cnblogs.com/xuanhun/p/3922847.html\" target=\"_blank\" rel=\"noopener\">在express站点中使用ejs模板引擎</a></li>\n</ul>\n<h2 id=\"8-CSS\"><a href=\"#8-CSS\" class=\"headerlink\" title=\"8. CSS\"></a>8. CSS</h2><ul>\n<li><a href=\"http://www.bootcss.com/\" target=\"_blank\" rel=\"noopener\">bootcss</a></li>\n<li><a href=\"http://www.bootcss.com/p/websafecolors/\" target=\"_blank\" rel=\"noopener\">WEB安全色</a></li>\n</ul>\n<h2 id=\"9-个人\"><a href=\"#9-个人\" class=\"headerlink\" title=\"9. 个人\"></a>9. 个人</h2><ul>\n<li><a href=\"https://github.com/xujiao1989\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li><a href=\"http://www.xujiaosite.com/\" target=\"_blank\" rel=\"noopener\">个人博客</a></li>\n</ul>\n<h2 id=\"10-其他\"><a href=\"#10-其他\" class=\"headerlink\" title=\"10. 其他\"></a>10. 其他</h2><ul>\n<li><a href=\"http://npm.taobao.org/\" target=\"_blank\" rel=\"noopener\">淘宝 NPM 镜像</a></li>\n<li><a href=\"https://leetcode.com/\" target=\"_blank\" rel=\"noopener\">leetcode</a></li>\n<li><a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\">can i use</a></li>\n<li><a href=\"http://www.iconfont.cn/plus\" target=\"_blank\" rel=\"noopener\">阿里巴巴的iconfont</a></li>\n</ul>\n<h2 id=\"11-图片素材\"><a href=\"#11-图片素材\" class=\"headerlink\" title=\"11. 图片素材\"></a>11. 图片素材</h2><ul>\n<li><a href=\"http://www.58pic.com/\" target=\"_blank\" rel=\"noopener\">千图网</a></li>\n<li><a href=\"http://588ku.com/?h=bd\" target=\"_blank\" rel=\"noopener\">千库网</a></li>\n</ul>\n<h3 id=\"12-博客搭建\"><a href=\"#12-博客搭建\" class=\"headerlink\" title=\"12. 博客搭建\"></a>12. 博客搭建</h3><ul>\n<li><a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">NexT使用文档</a></li>\n<li><a href=\"http://www.jianshu.com/p/05289a4bc8b2\" target=\"_blank\" rel=\"noopener\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004947261\" target=\"_blank\" rel=\"noopener\">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></li>\n<li><a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\" target=\"_blank\" rel=\"noopener\">为NexT主题添加文章阅读量统计功能</a></li>\n<li><a href=\"https://cart.godaddy.com/EmptyCart.aspx?isc=cjc2off30\" target=\"_blank\" rel=\"noopener\">godaddy域名购买</a></li>\n<li><a href=\"https://www.dnspod.cn/Login\" target=\"_blank\" rel=\"noopener\">DNS注册</a></li>\n</ul>\n<h2 id=\"牛人博客\"><a href=\"#牛人博客\" class=\"headerlink\" title=\"牛人博客\"></a>牛人博客</h2><ul>\n<li><a href=\"http://www.haorooms.com/\" target=\"_blank\" rel=\"noopener\">Haorooms</a></li>\n<li><a href=\"http://www.whycss.com/\" target=\"_blank\" rel=\"noopener\">前端网址导航</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"noopener\">廖雪峰的官方网站</a></li>\n<li><a href=\"http://www.whycss.com/\" target=\"_blank\" rel=\"noopener\">前端网址导航</a></li>\n<li><a href=\"http://www.haorooms.com/\" target=\"_blank\" rel=\"noopener\">Haorooms</a></li>\n<li><a href=\"http://www.whycss.com/\" target=\"_blank\" rel=\"noopener\">前端网址导航</a></li>\n<li><a href=\"http://www.qdfuns.com/\" target=\"_blank\" rel=\"noopener\">前端网</a></li>\n<li><a href=\"http://fex.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度FEX</a></li>\n<li><a href=\"http://fe.meituan.com/\" target=\"_blank\" rel=\"noopener\">美团FE博客</a></li>\n<li><a href=\"http://fe.meituan.com/yui3-practice.html\" target=\"_blank\" rel=\"noopener\">YUI3在美团的实践</a></li>\n<li><a href=\"http://scrat.io/#!/index\" target=\"_blank\" rel=\"noopener\">scrat的webapp模块化开发体系</a></li>\n<li><a href=\"http://www.ruanyifeng.com/home.html\" target=\"_blank\" rel=\"noopener\">阮一峰个人博客</a></li>\n<li><a href=\"http://www.sdifenzhou.com/\" target=\"_blank\" rel=\"noopener\">史蒂夫周-mac软件破解</a></li>\n<li><a href=\"http://2017.miaov.com/\" target=\"_blank\" rel=\"noopener\">妙味课堂</a></li>\n<li><a href=\"http://fex.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度FEX</a></li>\n<li><a href=\"https://lifesinger.wordpress.com/\" target=\"_blank\" rel=\"noopener\">玉伯的博客</a></li>\n<li><a href=\"https://blog.thankbabe.com/collection/\" target=\"_blank\" rel=\"noopener\">好用的工具导航</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-移动端\"><a href=\"#1-移动端\" class=\"headerlink\" title=\"1. 移动端\"></a>1. 移动端</h2><ul>\n<li><a href=\"http://www.jb51.net/article/76893.htm\" target=\"_blank\" rel=\"noopener\">js中flexible.js实现淘宝弹性布局方案</a></li>\n<li><a href=\"http://www.bootcss.com/p/zeptojs/\" target=\"_blank\" rel=\"noopener\">Zepto中文API</a></li>\n<li><a href=\"http://www.qdfuns.com/notes/23659/5e3cd2904a56f5e6b86c4d49e90e0f34.html?winzoom=1\" target=\"_blank\" rel=\"noopener\">从淘宝适配布局谈移动端适配</a></li>\n</ul>\n<h2 id=\"2-HTML\"><a href=\"#2-HTML\" class=\"headerlink\" title=\"2. HTML\"></a>2. HTML</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document\" target=\"_blank\" rel=\"noopener\">HTML5的文档节段和纲要</a></li>\n<li><a href=\"http://tool.oschina.net/commons?type=2\" target=\"_blank\" rel=\"noopener\">HTML占位符对照表</a></li>\n</ul>\n<h2 id=\"3-JS\"><a href=\"#3-JS\" class=\"headerlink\" title=\"3. JS\"></a>3. JS</h2><ul>\n<li><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a></li>\n<li><a href=\"http://www.cnblogs.com/fingerdancing/archive/2013/04/30/jsPlugin.html\" target=\"_blank\" rel=\"noopener\">js插件编写规范</a></li>\n<li><a href=\"http://www.css88.com/archives/4821\" target=\"_blank\" rel=\"noopener\">jQuery插件开发入门</a></li>\n<li><a href=\"http://www.gulpjs.com.cn/docs/writing-a-plugin/\" target=\"_blank\" rel=\"noopener\">gulp编写插件</a></li>\n<li><a href=\"http://www.css88.com/archives/4821\" target=\"_blank\" rel=\"noopener\">jQuery插件开发入门</a></li>\n<li><a href=\"http://www.gulpjs.com.cn/\" target=\"_blank\" rel=\"noopener\">gulpjs官网</a></li>\n<li><a href=\"http://lzw.me/pages/ecmascript/\" target=\"_blank\" rel=\"noopener\">EcmaScript5.1</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000005128101\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000005128101</a></li>\n<li><a href=\"https://github.com/Platform-CUF/use-gulp\" target=\"_blank\" rel=\"noopener\">gulp学习资料整理</a></li>\n<li><a href=\"http://webpackdoc.com/\" target=\"_blank\" rel=\"noopener\">webpack中文指南</a></li>\n</ul>\n<h3 id=\"4-模块化\"><a href=\"#4-模块化\" class=\"headerlink\" title=\"4. 模块化\"></a>4. 模块化</h3><ul>\n<li><a href=\"http://www.cnblogs.com/ifantastic/p/4648329.html\" target=\"_blank\" rel=\"noopener\">CommonJS 模块规范 1.1.1</a></li>\n<li><a href=\"http://justineo.github.io/singles/writing-modular-js/\" target=\"_blank\" rel=\"noopener\">使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript</a></li>\n<li><a href=\"http://requirejs.org/docs/whyamd.html\" target=\"_blank\" rel=\"noopener\">why amd</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html\" target=\"_blank\" rel=\"noopener\">浏览器加载 CommonJS 模块的原理与实现</a></li>\n<li><a href=\"http://blog.chinaunix.net/uid-26672038-id-4112229.html\" target=\"_blank\" rel=\"noopener\">JavaSript模块规范 - AMD规范与CMD规范介绍 </a></li>\n</ul>\n<h2 id=\"5-浏览器\"><a href=\"#5-浏览器\" class=\"headerlink\" title=\"5. 浏览器\"></a>5. 浏览器</h2><ul>\n<li><a href=\"http://fex.baidu.com/blog/2014/05/what-happen/?qq-pf-to=pcqq.c2c\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li>\n<li><a href=\"http://www.jianshu.com/p/cf36d48652f4\" target=\"_blank\" rel=\"noopener\">Chrome 开发者工具中文指南</a></li>\n<li><a href=\"http://blog.csdn.net/rogeryi/article/details/23686609\" target=\"_blank\" rel=\"noopener\">How Rendering Work (in WebKit and Blink)</a></li>\n<li><a href=\"http://blog.csdn.net/rogeryi/article/details/17657779\" target=\"_blank\" rel=\"noopener\">浏览器渲染发展的一些思考</a></li>\n<li><a href=\"http://blog.csdn.net/luoshengyang/article/details/50615628\" target=\"_blank\" rel=\"noopener\">Chromium网页Render Object Tree创建过程分析</a></li>\n<li><a href=\"http://blog.csdn.net/luoshengyang/article/details/50648792\" target=\"_blank\" rel=\"noopener\">Chromium网页Render Layer Tree创建过程分析</a></li>\n<li><a href=\"http://blog.csdn.net/luoshengyang/article/details/50661553\" target=\"_blank\" rel=\"noopener\">Chromium网页Graphics Layer Tree创建过程分析</a></li>\n</ul>\n<h2 id=\"6-React\"><a href=\"#6-React\" class=\"headerlink\" title=\"6. React\"></a>6. React</h2><ul>\n<li><a href=\"http://reactnative.cn/\" target=\"_blank\" rel=\"noopener\">RN中文网</a></li>\n</ul>\n<h2 id=\"7-node\"><a href=\"#7-node\" class=\"headerlink\" title=\"7. node\"></a>7. node</h2><ul>\n<li><a href=\"http://nodeschool.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">nodeschool</a></li>\n<li><a href=\"https://www.zhihu.com/question/21567720\" target=\"_blank\" rel=\"noopener\">如何系统地学习Node.js？</a></li>\n<li><a href=\"https://github.com/jimuyouyou/node-interview-questions#%E8%B5%B7%E6%BA%90\" target=\"_blank\" rel=\"noopener\">node-interview-questions</a></li>\n<li><a href=\"http://www.runoob.com/nodejs/nodejs-tutorial.html\" target=\"_blank\" rel=\"noopener\">Node.js 教程</a></li>\n<li><a href=\"http://expressjs.jser.us/api\" target=\"_blank\" rel=\"noopener\">express API</a></li>\n<li><a href=\"https://cnodejs.org/topic/504b4924e2b84515770103dd\" target=\"_blank\" rel=\"noopener\">Mongoose学习参考文档</a></li>\n<li><a href=\"http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html\" target=\"_blank\" rel=\"noopener\">8天学通MongoDB——第一天 基础入门</a></li>\n<li><a href=\"http://www.cnblogs.com/xuanhun/p/3922847.html\" target=\"_blank\" rel=\"noopener\">在express站点中使用ejs模板引擎</a></li>\n</ul>\n<h2 id=\"8-CSS\"><a href=\"#8-CSS\" class=\"headerlink\" title=\"8. CSS\"></a>8. CSS</h2><ul>\n<li><a href=\"http://www.bootcss.com/\" target=\"_blank\" rel=\"noopener\">bootcss</a></li>\n<li><a href=\"http://www.bootcss.com/p/websafecolors/\" target=\"_blank\" rel=\"noopener\">WEB安全色</a></li>\n</ul>\n<h2 id=\"9-个人\"><a href=\"#9-个人\" class=\"headerlink\" title=\"9. 个人\"></a>9. 个人</h2><ul>\n<li><a href=\"https://github.com/xujiao1989\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li><a href=\"http://www.xujiaosite.com/\" target=\"_blank\" rel=\"noopener\">个人博客</a></li>\n</ul>\n<h2 id=\"10-其他\"><a href=\"#10-其他\" class=\"headerlink\" title=\"10. 其他\"></a>10. 其他</h2><ul>\n<li><a href=\"http://npm.taobao.org/\" target=\"_blank\" rel=\"noopener\">淘宝 NPM 镜像</a></li>\n<li><a href=\"https://leetcode.com/\" target=\"_blank\" rel=\"noopener\">leetcode</a></li>\n<li><a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\">can i use</a></li>\n<li><a href=\"http://www.iconfont.cn/plus\" target=\"_blank\" rel=\"noopener\">阿里巴巴的iconfont</a></li>\n</ul>\n<h2 id=\"11-图片素材\"><a href=\"#11-图片素材\" class=\"headerlink\" title=\"11. 图片素材\"></a>11. 图片素材</h2><ul>\n<li><a href=\"http://www.58pic.com/\" target=\"_blank\" rel=\"noopener\">千图网</a></li>\n<li><a href=\"http://588ku.com/?h=bd\" target=\"_blank\" rel=\"noopener\">千库网</a></li>\n</ul>\n<h3 id=\"12-博客搭建\"><a href=\"#12-博客搭建\" class=\"headerlink\" title=\"12. 博客搭建\"></a>12. 博客搭建</h3><ul>\n<li><a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">NexT使用文档</a></li>\n<li><a href=\"http://www.jianshu.com/p/05289a4bc8b2\" target=\"_blank\" rel=\"noopener\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004947261\" target=\"_blank\" rel=\"noopener\">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></li>\n<li><a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\" target=\"_blank\" rel=\"noopener\">为NexT主题添加文章阅读量统计功能</a></li>\n<li><a href=\"https://cart.godaddy.com/EmptyCart.aspx?isc=cjc2off30\" target=\"_blank\" rel=\"noopener\">godaddy域名购买</a></li>\n<li><a href=\"https://www.dnspod.cn/Login\" target=\"_blank\" rel=\"noopener\">DNS注册</a></li>\n</ul>\n<h2 id=\"牛人博客\"><a href=\"#牛人博客\" class=\"headerlink\" title=\"牛人博客\"></a>牛人博客</h2><ul>\n<li><a href=\"http://www.haorooms.com/\" target=\"_blank\" rel=\"noopener\">Haorooms</a></li>\n<li><a href=\"http://www.whycss.com/\" target=\"_blank\" rel=\"noopener\">前端网址导航</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"noopener\">廖雪峰的官方网站</a></li>\n<li><a href=\"http://www.whycss.com/\" target=\"_blank\" rel=\"noopener\">前端网址导航</a></li>\n<li><a href=\"http://www.haorooms.com/\" target=\"_blank\" rel=\"noopener\">Haorooms</a></li>\n<li><a href=\"http://www.whycss.com/\" target=\"_blank\" rel=\"noopener\">前端网址导航</a></li>\n<li><a href=\"http://www.qdfuns.com/\" target=\"_blank\" rel=\"noopener\">前端网</a></li>\n<li><a href=\"http://fex.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度FEX</a></li>\n<li><a href=\"http://fe.meituan.com/\" target=\"_blank\" rel=\"noopener\">美团FE博客</a></li>\n<li><a href=\"http://fe.meituan.com/yui3-practice.html\" target=\"_blank\" rel=\"noopener\">YUI3在美团的实践</a></li>\n<li><a href=\"http://scrat.io/#!/index\" target=\"_blank\" rel=\"noopener\">scrat的webapp模块化开发体系</a></li>\n<li><a href=\"http://www.ruanyifeng.com/home.html\" target=\"_blank\" rel=\"noopener\">阮一峰个人博客</a></li>\n<li><a href=\"http://www.sdifenzhou.com/\" target=\"_blank\" rel=\"noopener\">史蒂夫周-mac软件破解</a></li>\n<li><a href=\"http://2017.miaov.com/\" target=\"_blank\" rel=\"noopener\">妙味课堂</a></li>\n<li><a href=\"http://fex.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度FEX</a></li>\n<li><a href=\"https://lifesinger.wordpress.com/\" target=\"_blank\" rel=\"noopener\">玉伯的博客</a></li>\n<li><a href=\"https://blog.thankbabe.com/collection/\" target=\"_blank\" rel=\"noopener\">好用的工具导航</a></li>\n</ul>\n"},{"title":"gulp小白文","date":"2017-03-20T16:00:00.000Z","_content":"\n## 1. 关于gulp\n\n### 1.1 gulp是什么\n\ngulp是一款提高我们开发效率的工具。比如：\n\n+ 自动帮我们添加浏览器兼容前缀\n+ 自动刷新浏览器\n+ 我们想要使用ES6，gulp还可以帮我们把ES6代码编译转换成浏览器可以用的js\n\n而这一切并不是gulp本身完成的，而是一系列的gulp插件来帮忙完成的。\n\n\n### 1.2 gulp环境简单配置\n\n+ 首先你得有node环境（去下载node并安装好，内置了npm包管理工具）\n+ 切到工程目录下，npm init 根据提示初始化package.json文件，如下图所示操作，会在项目目录下生成一个package.json文件(package.json文件也可以手动添加)\n\t\n    ![package.json](..//images/gulp1.png)\n    \n\t生成的package.json文件如下图所示\n\t\n\t![package.json](..//images/gulp2.png)\n\n+ 安装gulp \n\n\t\tnpm install gulp -g //全局安装\n\t\tnpm install gulp --save-dev //工程目录下会生成一个node_modules文件，里面保存着开发所需要的依赖\n\n\t当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（devDependencies）--摘自网络\n\n\t+ -save和save-dev可以省掉你手动修改package.json文件的步骤。\n\t+ -save 自动把模块和版本号添加到dependencies部分\n\t+ -save-dve 自动把模块和版本号添加到devdependencies部分\n\t\n\t至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 devDepandencies主要是配置测试框架\n\n+ 开始使用\n\n\t在项目目录下创建一个gulpfile.js文件，这个文件就gulp任务的入口文件,在gulpfile.js文件中添加以下代码段，在项目目录下执行gulp,可以看出命令行输出了“gulp任务执行啦~~~”\n\n\t```javascript\n\t\t\n\t\tvar gulp = require('gulp');\n\t\tgulp.task(\"default\",function(){\n\t\t    console.log(\"gulp任务执行啦~~~\");\n\t\t})\n\t```\n\n好吧，关于gulp的接口只有那么几个，自己去看一看\n\n### 1.3 我自己的学习经验就是：\n\n+ 正确认识gulp: 它并不是一个什么多么难的新知识，只要我们根据要求配合插件可以实现非常强大的功能。\n\n+ 重要的是我们要知道有哪些插件，最好的就是我们在使用过程中想要用什么功能（压缩js，合并js，拷贝文件，简直不要太多）就去网上搜一下，各种插件就出来了\n\n+ 自己可以根据任务搭建一套手脚架，提高开发效率\n\n\n\t\n## 1.4 比较好的gulp插件\n\n+ autoprefixer: 自动添加css兼容前缀\n+ run-sequence：让任务船型执行\n+ [这里很多资料，不骗你](https://github.com/Platform-CUF/use-gulp)\n\n## 2. 项目中使用ES6的模块\n\n```javascript\nbuildjs :(fromPath,toPath,name)=>{\n    return browserify({\n        entries: [fromPath],\n        debug: true, // 告知Browserify在运行同时生成内联sourcemap用于调试\n    }).transform(\"babelify\", {presets: [\"es2015\"]})//转为ES5\n        .bundle()//打包\n        .pipe(source(name ? name : \"app.js\" ))\n        .pipe(buffer()) // 缓存文件内容\n        .pipe(gulp.dest(toPath));\n}\n```\n\n\n\n## 3. 参考文章\n\n+ [使用 gulp 搭建前端环境之CommonJs & ES6 模块化(中级篇)](http://div.io/topic/1506)\n\n\n---\n做一个勤于思考的人","source":"_posts/其他/gulp小白文.md","raw":"---\ntitle: gulp小白文\ndate: 2017-03-21\ntags:\n  - 前端开发\n  - 个人成长\n  - 其他\n  - 自动化构建\ncategories: 其他\n---\n\n## 1. 关于gulp\n\n### 1.1 gulp是什么\n\ngulp是一款提高我们开发效率的工具。比如：\n\n+ 自动帮我们添加浏览器兼容前缀\n+ 自动刷新浏览器\n+ 我们想要使用ES6，gulp还可以帮我们把ES6代码编译转换成浏览器可以用的js\n\n而这一切并不是gulp本身完成的，而是一系列的gulp插件来帮忙完成的。\n\n\n### 1.2 gulp环境简单配置\n\n+ 首先你得有node环境（去下载node并安装好，内置了npm包管理工具）\n+ 切到工程目录下，npm init 根据提示初始化package.json文件，如下图所示操作，会在项目目录下生成一个package.json文件(package.json文件也可以手动添加)\n\t\n    ![package.json](..//images/gulp1.png)\n    \n\t生成的package.json文件如下图所示\n\t\n\t![package.json](..//images/gulp2.png)\n\n+ 安装gulp \n\n\t\tnpm install gulp -g //全局安装\n\t\tnpm install gulp --save-dev //工程目录下会生成一个node_modules文件，里面保存着开发所需要的依赖\n\n\t当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（devDependencies）--摘自网络\n\n\t+ -save和save-dev可以省掉你手动修改package.json文件的步骤。\n\t+ -save 自动把模块和版本号添加到dependencies部分\n\t+ -save-dve 自动把模块和版本号添加到devdependencies部分\n\t\n\t至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 devDepandencies主要是配置测试框架\n\n+ 开始使用\n\n\t在项目目录下创建一个gulpfile.js文件，这个文件就gulp任务的入口文件,在gulpfile.js文件中添加以下代码段，在项目目录下执行gulp,可以看出命令行输出了“gulp任务执行啦~~~”\n\n\t```javascript\n\t\t\n\t\tvar gulp = require('gulp');\n\t\tgulp.task(\"default\",function(){\n\t\t    console.log(\"gulp任务执行啦~~~\");\n\t\t})\n\t```\n\n好吧，关于gulp的接口只有那么几个，自己去看一看\n\n### 1.3 我自己的学习经验就是：\n\n+ 正确认识gulp: 它并不是一个什么多么难的新知识，只要我们根据要求配合插件可以实现非常强大的功能。\n\n+ 重要的是我们要知道有哪些插件，最好的就是我们在使用过程中想要用什么功能（压缩js，合并js，拷贝文件，简直不要太多）就去网上搜一下，各种插件就出来了\n\n+ 自己可以根据任务搭建一套手脚架，提高开发效率\n\n\n\t\n## 1.4 比较好的gulp插件\n\n+ autoprefixer: 自动添加css兼容前缀\n+ run-sequence：让任务船型执行\n+ [这里很多资料，不骗你](https://github.com/Platform-CUF/use-gulp)\n\n## 2. 项目中使用ES6的模块\n\n```javascript\nbuildjs :(fromPath,toPath,name)=>{\n    return browserify({\n        entries: [fromPath],\n        debug: true, // 告知Browserify在运行同时生成内联sourcemap用于调试\n    }).transform(\"babelify\", {presets: [\"es2015\"]})//转为ES5\n        .bundle()//打包\n        .pipe(source(name ? name : \"app.js\" ))\n        .pipe(buffer()) // 缓存文件内容\n        .pipe(gulp.dest(toPath));\n}\n```\n\n\n\n## 3. 参考文章\n\n+ [使用 gulp 搭建前端环境之CommonJs & ES6 模块化(中级篇)](http://div.io/topic/1506)\n\n\n---\n做一个勤于思考的人","slug":"其他/gulp小白文","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2v000e9oxz0cq4kk35","content":"<h2 id=\"1-关于gulp\"><a href=\"#1-关于gulp\" class=\"headerlink\" title=\"1. 关于gulp\"></a>1. 关于gulp</h2><h3 id=\"1-1-gulp是什么\"><a href=\"#1-1-gulp是什么\" class=\"headerlink\" title=\"1.1 gulp是什么\"></a>1.1 gulp是什么</h3><p>gulp是一款提高我们开发效率的工具。比如：</p>\n<ul>\n<li>自动帮我们添加浏览器兼容前缀</li>\n<li>自动刷新浏览器</li>\n<li>我们想要使用ES6，gulp还可以帮我们把ES6代码编译转换成浏览器可以用的js</li>\n</ul>\n<p>而这一切并不是gulp本身完成的，而是一系列的gulp插件来帮忙完成的。</p>\n<h3 id=\"1-2-gulp环境简单配置\"><a href=\"#1-2-gulp环境简单配置\" class=\"headerlink\" title=\"1.2 gulp环境简单配置\"></a>1.2 gulp环境简单配置</h3><ul>\n<li>首先你得有node环境（去下载node并安装好，内置了npm包管理工具）</li>\n<li><p>切到工程目录下，npm init 根据提示初始化package.json文件，如下图所示操作，会在项目目录下生成一个package.json文件(package.json文件也可以手动添加)</p>\n<p>  <img src=\"..//images/gulp1.png\" alt=\"package.json\"></p>\n<p>  生成的package.json文件如下图所示</p>\n<p>  <img src=\"..//images/gulp2.png\" alt=\"package.json\"></p>\n</li>\n<li><p>安装gulp </p>\n<pre><code>npm install gulp -g //全局安装\nnpm install gulp --save-dev //工程目录下会生成一个node_modules文件，里面保存着开发所需要的依赖\n</code></pre><p>  当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（devDependencies）–摘自网络</p>\n<ul>\n<li>-save和save-dev可以省掉你手动修改package.json文件的步骤。</li>\n<li>-save 自动把模块和版本号添加到dependencies部分</li>\n<li><p>-save-dve 自动把模块和版本号添加到devdependencies部分</p>\n<p>至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 devDepandencies主要是配置测试框架</p>\n</li>\n</ul>\n</li>\n<li><p>开始使用</p>\n<p>  在项目目录下创建一个gulpfile.js文件，这个文件就gulp任务的入口文件,在gulpfile.js文件中添加以下代码段，在项目目录下执行gulp,可以看出命令行输出了“gulp任务执行啦~~~”</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"gulp任务执行啦~~~\"</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>好吧，关于gulp的接口只有那么几个，自己去看一看</p>\n<h3 id=\"1-3-我自己的学习经验就是：\"><a href=\"#1-3-我自己的学习经验就是：\" class=\"headerlink\" title=\"1.3 我自己的学习经验就是：\"></a>1.3 我自己的学习经验就是：</h3><ul>\n<li><p>正确认识gulp: 它并不是一个什么多么难的新知识，只要我们根据要求配合插件可以实现非常强大的功能。</p>\n</li>\n<li><p>重要的是我们要知道有哪些插件，最好的就是我们在使用过程中想要用什么功能（压缩js，合并js，拷贝文件，简直不要太多）就去网上搜一下，各种插件就出来了</p>\n</li>\n<li><p>自己可以根据任务搭建一套手脚架，提高开发效率</p>\n</li>\n</ul>\n<h2 id=\"1-4-比较好的gulp插件\"><a href=\"#1-4-比较好的gulp插件\" class=\"headerlink\" title=\"1.4 比较好的gulp插件\"></a>1.4 比较好的gulp插件</h2><ul>\n<li>autoprefixer: 自动添加css兼容前缀</li>\n<li>run-sequence：让任务船型执行</li>\n<li><a href=\"https://github.com/Platform-CUF/use-gulp\" target=\"_blank\" rel=\"noopener\">这里很多资料，不骗你</a></li>\n</ul>\n<h2 id=\"2-项目中使用ES6的模块\"><a href=\"#2-项目中使用ES6的模块\" class=\"headerlink\" title=\"2. 项目中使用ES6的模块\"></a>2. 项目中使用ES6的模块</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildjs :<span class=\"function\">(<span class=\"params\">fromPath,toPath,name</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> browserify(&#123;</span><br><span class=\"line\">        entries: [fromPath],</span><br><span class=\"line\">        debug: <span class=\"literal\">true</span>, <span class=\"comment\">// 告知Browserify在运行同时生成内联sourcemap用于调试</span></span><br><span class=\"line\">    &#125;).transform(<span class=\"string\">\"babelify\"</span>, &#123;<span class=\"attr\">presets</span>: [<span class=\"string\">\"es2015\"</span>]&#125;)<span class=\"comment\">//转为ES5</span></span><br><span class=\"line\">        .bundle()<span class=\"comment\">//打包</span></span><br><span class=\"line\">        .pipe(source(name ? name : <span class=\"string\">\"app.js\"</span> ))</span><br><span class=\"line\">        .pipe(buffer()) <span class=\"comment\">// 缓存文件内容</span></span><br><span class=\"line\">        .pipe(gulp.dest(toPath));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-参考文章\"><a href=\"#3-参考文章\" class=\"headerlink\" title=\"3. 参考文章\"></a>3. 参考文章</h2><ul>\n<li><a href=\"http://div.io/topic/1506\" target=\"_blank\" rel=\"noopener\">使用 gulp 搭建前端环境之CommonJs &amp; ES6 模块化(中级篇)</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-关于gulp\"><a href=\"#1-关于gulp\" class=\"headerlink\" title=\"1. 关于gulp\"></a>1. 关于gulp</h2><h3 id=\"1-1-gulp是什么\"><a href=\"#1-1-gulp是什么\" class=\"headerlink\" title=\"1.1 gulp是什么\"></a>1.1 gulp是什么</h3><p>gulp是一款提高我们开发效率的工具。比如：</p>\n<ul>\n<li>自动帮我们添加浏览器兼容前缀</li>\n<li>自动刷新浏览器</li>\n<li>我们想要使用ES6，gulp还可以帮我们把ES6代码编译转换成浏览器可以用的js</li>\n</ul>\n<p>而这一切并不是gulp本身完成的，而是一系列的gulp插件来帮忙完成的。</p>\n<h3 id=\"1-2-gulp环境简单配置\"><a href=\"#1-2-gulp环境简单配置\" class=\"headerlink\" title=\"1.2 gulp环境简单配置\"></a>1.2 gulp环境简单配置</h3><ul>\n<li>首先你得有node环境（去下载node并安装好，内置了npm包管理工具）</li>\n<li><p>切到工程目录下，npm init 根据提示初始化package.json文件，如下图所示操作，会在项目目录下生成一个package.json文件(package.json文件也可以手动添加)</p>\n<p>  <img src=\"..//images/gulp1.png\" alt=\"package.json\"></p>\n<p>  生成的package.json文件如下图所示</p>\n<p>  <img src=\"..//images/gulp2.png\" alt=\"package.json\"></p>\n</li>\n<li><p>安装gulp </p>\n<pre><code>npm install gulp -g //全局安装\nnpm install gulp --save-dev //工程目录下会生成一个node_modules文件，里面保存着开发所需要的依赖\n</code></pre><p>  当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（devDependencies）–摘自网络</p>\n<ul>\n<li>-save和save-dev可以省掉你手动修改package.json文件的步骤。</li>\n<li>-save 自动把模块和版本号添加到dependencies部分</li>\n<li><p>-save-dve 自动把模块和版本号添加到devdependencies部分</p>\n<p>至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 devDepandencies主要是配置测试框架</p>\n</li>\n</ul>\n</li>\n<li><p>开始使用</p>\n<p>  在项目目录下创建一个gulpfile.js文件，这个文件就gulp任务的入口文件,在gulpfile.js文件中添加以下代码段，在项目目录下执行gulp,可以看出命令行输出了“gulp任务执行啦~~~”</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"gulp任务执行啦~~~\"</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>好吧，关于gulp的接口只有那么几个，自己去看一看</p>\n<h3 id=\"1-3-我自己的学习经验就是：\"><a href=\"#1-3-我自己的学习经验就是：\" class=\"headerlink\" title=\"1.3 我自己的学习经验就是：\"></a>1.3 我自己的学习经验就是：</h3><ul>\n<li><p>正确认识gulp: 它并不是一个什么多么难的新知识，只要我们根据要求配合插件可以实现非常强大的功能。</p>\n</li>\n<li><p>重要的是我们要知道有哪些插件，最好的就是我们在使用过程中想要用什么功能（压缩js，合并js，拷贝文件，简直不要太多）就去网上搜一下，各种插件就出来了</p>\n</li>\n<li><p>自己可以根据任务搭建一套手脚架，提高开发效率</p>\n</li>\n</ul>\n<h2 id=\"1-4-比较好的gulp插件\"><a href=\"#1-4-比较好的gulp插件\" class=\"headerlink\" title=\"1.4 比较好的gulp插件\"></a>1.4 比较好的gulp插件</h2><ul>\n<li>autoprefixer: 自动添加css兼容前缀</li>\n<li>run-sequence：让任务船型执行</li>\n<li><a href=\"https://github.com/Platform-CUF/use-gulp\" target=\"_blank\" rel=\"noopener\">这里很多资料，不骗你</a></li>\n</ul>\n<h2 id=\"2-项目中使用ES6的模块\"><a href=\"#2-项目中使用ES6的模块\" class=\"headerlink\" title=\"2. 项目中使用ES6的模块\"></a>2. 项目中使用ES6的模块</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildjs :<span class=\"function\">(<span class=\"params\">fromPath,toPath,name</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> browserify(&#123;</span><br><span class=\"line\">        entries: [fromPath],</span><br><span class=\"line\">        debug: <span class=\"literal\">true</span>, <span class=\"comment\">// 告知Browserify在运行同时生成内联sourcemap用于调试</span></span><br><span class=\"line\">    &#125;).transform(<span class=\"string\">\"babelify\"</span>, &#123;<span class=\"attr\">presets</span>: [<span class=\"string\">\"es2015\"</span>]&#125;)<span class=\"comment\">//转为ES5</span></span><br><span class=\"line\">        .bundle()<span class=\"comment\">//打包</span></span><br><span class=\"line\">        .pipe(source(name ? name : <span class=\"string\">\"app.js\"</span> ))</span><br><span class=\"line\">        .pipe(buffer()) <span class=\"comment\">// 缓存文件内容</span></span><br><span class=\"line\">        .pipe(gulp.dest(toPath));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-参考文章\"><a href=\"#3-参考文章\" class=\"headerlink\" title=\"3. 参考文章\"></a>3. 参考文章</h2><ul>\n<li><a href=\"http://div.io/topic/1506\" target=\"_blank\" rel=\"noopener\">使用 gulp 搭建前端环境之CommonJs &amp; ES6 模块化(中级篇)</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n"},{"title":"前端面试题--第一套","date":"2017-03-27T16:00:00.000Z","_content":"\n####  1. 利用正则实现一个方法，取到\"isvip\"的cookie值\n\n> 实现思路：\n\n+ 获取本地的cookie：document.cookie;我们可以打印出来发现，cookie的格式为：name=xujiao; age=18; isVip=xsxdjc;\n+ 通过正则的exec()方法，匹配到isVip=xsxdjc这段文字\n+ 我们知道的是，正则中的小括号表示子匹配模式，匹配成功后保存到exec()返回的数组中\n\n```javascript\n\n/**需要注意：\n（1）利用RegExp动态创建正则\n (2)使用\\\\w转义\n (3)(\\\\w*)中*需要放到括号内，否则匹配到的只是一个字符\n (4) 需要使用^开头，否则可能会匹配到，scdsisVip=xsxdjc\n */\nfunction getCookie(name) {\n    var cookies = document.cookie,\n        reg = new RegExp(\"^\"+name+\"=(\\\\w*)\",\"ig\"),   \n        match = reg.exec(cookies);\n    return match && match[1];\n}\n```\n\n\n#### 2. 利用css实现垂直居中（兼容IE6）\n\n具体的实现可以查看：[css实现垂直居中的几种方法](http://www.xujiaosite.com/2017/03/CSS/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html#more)\n\n#### 3. 至少写出3中js的设计模式，并且做出详细说明（越多越好）\n\n具体可以参考：[JavaScript设计模式学习总结](http://www.xujiaosite.com/2017/04/JS/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html)\n\n#### 4. 详细说明TCP的三次握手，并配合手绘图(摘自网络)\n\n开放系统互连参考模型 (Open System Interconnect 简称OSI）--网络的7层模型，网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。而我们常见的IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。\nWEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。\n\n+ 什么是TCP连接的三次握手\n    + 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;\n    + 第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;\n    + 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)\n\n    ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1\n    SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。\n    FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n\n![TCP三次握手](/images/TCP.PNG)   \n\n+ HTTP链接的特点\n   + HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。\n   + HTTP连接最显著的特点是**客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接**。从建立连接到关闭连接的过程称为“一次连接”。\n\n#### 5. 实现一个函数function on(elem,type,handler){}完成事件注册，保证this指向始终是elem，要求兼容IE8\n\n我们事件注册的方式有两种：addEventListener，attachEvent。\n\n```javascript\nfunction on(elem,type,handle){\n    if(window.addEventListener){\n        elem.addEventListener(type,handle)\n    }else{\n        elem.attachEvent(\"on\"+type,function(){\n            handle.apply(elem);\n        })\n    }\n}\n```\n\n1. 需要注意的地方\n\n    一开始使用bind实现的，但是bind只支持IE9+，ff4+，chrome7+支持此方法，opera和safari不支持（MDN上的说明）。所以换了apply或者call实现。如果用bind就不需要外面在包一层function了，因为bind返回的就是一个函数\n\n2. addEventListener和attachEvent的区别\n\n+ `兼容性`： addEventListener：是DOM2级事件注册方式（标准），但是只支持IE9+(包含IE9)以及其他浏览器。attachEvent：IE事件注册方式，IE8-\n\n+ `this的指向`： 在addEventListener的处理函数中this指向被绑定元素，而attachEvent始终指向window\n\n+ `代码执行顺序`：addEventListener按照绑定事件的顺序执行，而attachEvent与绑定事件的顺序相反执行\n\n+ `参数个数`：addEventListener有三个参数，第三个参数表示在哪个阶段捕获事件（false表示冒泡阶段），而attachEvent只支持事件冒泡\n\n+ `事件类型`：addEventListener的事件类型如：click,attachEvent的事件类型是:\"on\"+click\n\n#### 6. 利用node实现一个服务器，端口8080，返回\"我是一台服务器\"\n\n在做笔试的时候看到这个题目差点没当场把自己砸死，送分题呀，可是我并不记得API。当时我就在卷子上认真的写着：\n\n我并没有用过node，我觉得首先node提供了一个http的核心模块，这个模块应该提供了一个类似于createServer的方法（没错，我猜对了方法），接下来我们应该提供一些参数，供服务器使用\n比如port:端口，url:拦截的链接，response就是返回数据\n\n我写的是\n\n```javascript\n    var http = require('http');\n    http.createServer({\n        port:8080,\n        url:\"127.0.0.1\",\n        response:\"我是一台服务器\"\n    });\n```\n\n为什么要把我的错误的答案写上呢，其实这说明了什么，我没有认真的思考过web服务器的角色和http请求的过程\n\n1. web服务器的角色是什么：\n用于处理用户的请求，并作出响应（拦截用户的http请求，根据请求所带来的一系列信息，给出一点的响应）\n2. http响应过程是什么\n在学习http的过程中，我们要学什么，请求报文呀，请求方法，响应头、状态码等等，为什么会有这些东西存在，说明这些在我http交流中充当着非常重要的角色，而我在上面的思考web服务器的时候\n却并没有考虑这些东西。\n\n+ 我的createServer只获取了参数，没做任何处理，你就是服务器呀，还准备让谁去做这件事情\n+ 你去取request了吗？并没有，那怎么分析请求呢\n+ 你返回数据的时候写响应头了吗？并没有，那怎么知道我的请求是否合法，你的状态码响应头什么的都怎么给呢\n\n正确的实现是：\n\n```javascript\n\n    var http = require('http');\n    http.createServer(function (request, response) {\n        response.writeHead(200, {'Content-Type': 'text/plain'});\n        response.end('我是一台服务器\\n');\n    }).listen(8080);\n    console.log('Server running at http://127.0.0.1:8080/');\n\n```\n\n#### 7. 实现一个函数function add(a,b){},能够处理超出js处理范围两个的和（可能是负数）\n\n---\n做一个勤于思考的人\n","source":"_posts/前端面试题/前端面试题-第一套.md","raw":"---\ntitle: 前端面试题--第一套\ndate: 2017-03-28\ntags:\n  - 前端开发\n  - 前端面试题\ncategories: 前端面试题\n---\n\n####  1. 利用正则实现一个方法，取到\"isvip\"的cookie值\n\n> 实现思路：\n\n+ 获取本地的cookie：document.cookie;我们可以打印出来发现，cookie的格式为：name=xujiao; age=18; isVip=xsxdjc;\n+ 通过正则的exec()方法，匹配到isVip=xsxdjc这段文字\n+ 我们知道的是，正则中的小括号表示子匹配模式，匹配成功后保存到exec()返回的数组中\n\n```javascript\n\n/**需要注意：\n（1）利用RegExp动态创建正则\n (2)使用\\\\w转义\n (3)(\\\\w*)中*需要放到括号内，否则匹配到的只是一个字符\n (4) 需要使用^开头，否则可能会匹配到，scdsisVip=xsxdjc\n */\nfunction getCookie(name) {\n    var cookies = document.cookie,\n        reg = new RegExp(\"^\"+name+\"=(\\\\w*)\",\"ig\"),   \n        match = reg.exec(cookies);\n    return match && match[1];\n}\n```\n\n\n#### 2. 利用css实现垂直居中（兼容IE6）\n\n具体的实现可以查看：[css实现垂直居中的几种方法](http://www.xujiaosite.com/2017/03/CSS/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html#more)\n\n#### 3. 至少写出3中js的设计模式，并且做出详细说明（越多越好）\n\n具体可以参考：[JavaScript设计模式学习总结](http://www.xujiaosite.com/2017/04/JS/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html)\n\n#### 4. 详细说明TCP的三次握手，并配合手绘图(摘自网络)\n\n开放系统互连参考模型 (Open System Interconnect 简称OSI）--网络的7层模型，网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。而我们常见的IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。\nWEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。\n\n+ 什么是TCP连接的三次握手\n    + 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;\n    + 第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;\n    + 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)\n\n    ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1\n    SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。\n    FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n\n![TCP三次握手](/images/TCP.PNG)   \n\n+ HTTP链接的特点\n   + HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。\n   + HTTP连接最显著的特点是**客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接**。从建立连接到关闭连接的过程称为“一次连接”。\n\n#### 5. 实现一个函数function on(elem,type,handler){}完成事件注册，保证this指向始终是elem，要求兼容IE8\n\n我们事件注册的方式有两种：addEventListener，attachEvent。\n\n```javascript\nfunction on(elem,type,handle){\n    if(window.addEventListener){\n        elem.addEventListener(type,handle)\n    }else{\n        elem.attachEvent(\"on\"+type,function(){\n            handle.apply(elem);\n        })\n    }\n}\n```\n\n1. 需要注意的地方\n\n    一开始使用bind实现的，但是bind只支持IE9+，ff4+，chrome7+支持此方法，opera和safari不支持（MDN上的说明）。所以换了apply或者call实现。如果用bind就不需要外面在包一层function了，因为bind返回的就是一个函数\n\n2. addEventListener和attachEvent的区别\n\n+ `兼容性`： addEventListener：是DOM2级事件注册方式（标准），但是只支持IE9+(包含IE9)以及其他浏览器。attachEvent：IE事件注册方式，IE8-\n\n+ `this的指向`： 在addEventListener的处理函数中this指向被绑定元素，而attachEvent始终指向window\n\n+ `代码执行顺序`：addEventListener按照绑定事件的顺序执行，而attachEvent与绑定事件的顺序相反执行\n\n+ `参数个数`：addEventListener有三个参数，第三个参数表示在哪个阶段捕获事件（false表示冒泡阶段），而attachEvent只支持事件冒泡\n\n+ `事件类型`：addEventListener的事件类型如：click,attachEvent的事件类型是:\"on\"+click\n\n#### 6. 利用node实现一个服务器，端口8080，返回\"我是一台服务器\"\n\n在做笔试的时候看到这个题目差点没当场把自己砸死，送分题呀，可是我并不记得API。当时我就在卷子上认真的写着：\n\n我并没有用过node，我觉得首先node提供了一个http的核心模块，这个模块应该提供了一个类似于createServer的方法（没错，我猜对了方法），接下来我们应该提供一些参数，供服务器使用\n比如port:端口，url:拦截的链接，response就是返回数据\n\n我写的是\n\n```javascript\n    var http = require('http');\n    http.createServer({\n        port:8080,\n        url:\"127.0.0.1\",\n        response:\"我是一台服务器\"\n    });\n```\n\n为什么要把我的错误的答案写上呢，其实这说明了什么，我没有认真的思考过web服务器的角色和http请求的过程\n\n1. web服务器的角色是什么：\n用于处理用户的请求，并作出响应（拦截用户的http请求，根据请求所带来的一系列信息，给出一点的响应）\n2. http响应过程是什么\n在学习http的过程中，我们要学什么，请求报文呀，请求方法，响应头、状态码等等，为什么会有这些东西存在，说明这些在我http交流中充当着非常重要的角色，而我在上面的思考web服务器的时候\n却并没有考虑这些东西。\n\n+ 我的createServer只获取了参数，没做任何处理，你就是服务器呀，还准备让谁去做这件事情\n+ 你去取request了吗？并没有，那怎么分析请求呢\n+ 你返回数据的时候写响应头了吗？并没有，那怎么知道我的请求是否合法，你的状态码响应头什么的都怎么给呢\n\n正确的实现是：\n\n```javascript\n\n    var http = require('http');\n    http.createServer(function (request, response) {\n        response.writeHead(200, {'Content-Type': 'text/plain'});\n        response.end('我是一台服务器\\n');\n    }).listen(8080);\n    console.log('Server running at http://127.0.0.1:8080/');\n\n```\n\n#### 7. 实现一个函数function add(a,b){},能够处理超出js处理范围两个的和（可能是负数）\n\n---\n做一个勤于思考的人\n","slug":"前端面试题/前端面试题-第一套","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2x000i9oxzr5nqemmc","content":"<h4 id=\"1-利用正则实现一个方法，取到”isvip”的cookie值\"><a href=\"#1-利用正则实现一个方法，取到”isvip”的cookie值\" class=\"headerlink\" title=\"1. 利用正则实现一个方法，取到”isvip”的cookie值\"></a>1. 利用正则实现一个方法，取到”isvip”的cookie值</h4><blockquote>\n<p>实现思路：</p>\n</blockquote>\n<ul>\n<li>获取本地的cookie：document.cookie;我们可以打印出来发现，cookie的格式为：name=xujiao; age=18; isVip=xsxdjc;</li>\n<li>通过正则的exec()方法，匹配到isVip=xsxdjc这段文字</li>\n<li>我们知道的是，正则中的小括号表示子匹配模式，匹配成功后保存到exec()返回的数组中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**需要注意：</span></span><br><span class=\"line\"><span class=\"comment\">（1）利用RegExp动态创建正则</span></span><br><span class=\"line\"><span class=\"comment\"> (2)使用\\\\w转义</span></span><br><span class=\"line\"><span class=\"comment\"> (3)(\\\\w*)中*需要放到括号内，否则匹配到的只是一个字符</span></span><br><span class=\"line\"><span class=\"comment\"> (4) 需要使用^开头，否则可能会匹配到，scdsisVip=xsxdjc</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCookie</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookies = <span class=\"built_in\">document</span>.cookie,</span><br><span class=\"line\">        reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"^\"</span>+name+<span class=\"string\">\"=(\\\\w*)\"</span>,<span class=\"string\">\"ig\"</span>),   </span><br><span class=\"line\">        match = reg.exec(cookies);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match &amp;&amp; match[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-利用css实现垂直居中（兼容IE6）\"><a href=\"#2-利用css实现垂直居中（兼容IE6）\" class=\"headerlink\" title=\"2. 利用css实现垂直居中（兼容IE6）\"></a>2. 利用css实现垂直居中（兼容IE6）</h4><p>具体的实现可以查看：<a href=\"http://www.xujiaosite.com/2017/03/CSS/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html#more\" target=\"_blank\" rel=\"noopener\">css实现垂直居中的几种方法</a></p>\n<h4 id=\"3-至少写出3中js的设计模式，并且做出详细说明（越多越好）\"><a href=\"#3-至少写出3中js的设计模式，并且做出详细说明（越多越好）\" class=\"headerlink\" title=\"3. 至少写出3中js的设计模式，并且做出详细说明（越多越好）\"></a>3. 至少写出3中js的设计模式，并且做出详细说明（越多越好）</h4><p>具体可以参考：<a href=\"http://www.xujiaosite.com/2017/04/JS/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html\" target=\"_blank\" rel=\"noopener\">JavaScript设计模式学习总结</a></p>\n<h4 id=\"4-详细说明TCP的三次握手，并配合手绘图-摘自网络\"><a href=\"#4-详细说明TCP的三次握手，并配合手绘图-摘自网络\" class=\"headerlink\" title=\"4. 详细说明TCP的三次握手，并配合手绘图(摘自网络)\"></a>4. 详细说明TCP的三次握手，并配合手绘图(摘自网络)</h4><p>开放系统互连参考模型 (Open System Interconnect 简称OSI）–网络的7层模型，网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。而我们常见的IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。<br>WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p>\n<ul>\n<li>什么是TCP连接的三次握手<ul>\n<li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;</li>\n<li>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</li>\n<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>\n</ul>\n</li>\n</ul>\n<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)</p>\n<pre><code>ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1\nSYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。\nFIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n</code></pre><p><img src=\"/images/TCP.PNG\" alt=\"TCP三次握手\">   </p>\n<ul>\n<li>HTTP链接的特点<ul>\n<li>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</li>\n<li>HTTP连接最显著的特点是<strong>客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接</strong>。从建立连接到关闭连接的过程称为“一次连接”。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-实现一个函数function-on-elem-type-handler-完成事件注册，保证this指向始终是elem，要求兼容IE8\"><a href=\"#5-实现一个函数function-on-elem-type-handler-完成事件注册，保证this指向始终是elem，要求兼容IE8\" class=\"headerlink\" title=\"5. 实现一个函数function on(elem,type,handler){}完成事件注册，保证this指向始终是elem，要求兼容IE8\"></a>5. 实现一个函数function on(elem,type,handler){}完成事件注册，保证this指向始终是elem，要求兼容IE8</h4><p>我们事件注册的方式有两种：addEventListener，attachEvent。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">on</span>(<span class=\"params\">elem,type,handle</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.addEventListener)&#123;</span><br><span class=\"line\">        elem.addEventListener(type,handle)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        elem.attachEvent(<span class=\"string\">\"on\"</span>+type,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            handle.apply(elem);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>需要注意的地方</p>\n<p> 一开始使用bind实现的，但是bind只支持IE9+，ff4+，chrome7+支持此方法，opera和safari不支持（MDN上的说明）。所以换了apply或者call实现。如果用bind就不需要外面在包一层function了，因为bind返回的就是一个函数</p>\n</li>\n<li><p>addEventListener和attachEvent的区别</p>\n</li>\n</ol>\n<ul>\n<li><p><code>兼容性</code>： addEventListener：是DOM2级事件注册方式（标准），但是只支持IE9+(包含IE9)以及其他浏览器。attachEvent：IE事件注册方式，IE8-</p>\n</li>\n<li><p><code>this的指向</code>： 在addEventListener的处理函数中this指向被绑定元素，而attachEvent始终指向window</p>\n</li>\n<li><p><code>代码执行顺序</code>：addEventListener按照绑定事件的顺序执行，而attachEvent与绑定事件的顺序相反执行</p>\n</li>\n<li><p><code>参数个数</code>：addEventListener有三个参数，第三个参数表示在哪个阶段捕获事件（false表示冒泡阶段），而attachEvent只支持事件冒泡</p>\n</li>\n<li><p><code>事件类型</code>：addEventListener的事件类型如：click,attachEvent的事件类型是:”on”+click</p>\n</li>\n</ul>\n<h4 id=\"6-利用node实现一个服务器，端口8080，返回”我是一台服务器”\"><a href=\"#6-利用node实现一个服务器，端口8080，返回”我是一台服务器”\" class=\"headerlink\" title=\"6. 利用node实现一个服务器，端口8080，返回”我是一台服务器”\"></a>6. 利用node实现一个服务器，端口8080，返回”我是一台服务器”</h4><p>在做笔试的时候看到这个题目差点没当场把自己砸死，送分题呀，可是我并不记得API。当时我就在卷子上认真的写着：</p>\n<p>我并没有用过node，我觉得首先node提供了一个http的核心模块，这个模块应该提供了一个类似于createServer的方法（没错，我猜对了方法），接下来我们应该提供一些参数，供服务器使用<br>比如port:端口，url:拦截的链接，response就是返回数据</p>\n<p>我写的是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.createServer(&#123;</span><br><span class=\"line\">    port:<span class=\"number\">8080</span>,</span><br><span class=\"line\">    url:<span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    response:<span class=\"string\">\"我是一台服务器\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>为什么要把我的错误的答案写上呢，其实这说明了什么，我没有认真的思考过web服务器的角色和http请求的过程</p>\n<ol>\n<li>web服务器的角色是什么：<br>用于处理用户的请求，并作出响应（拦截用户的http请求，根据请求所带来的一系列信息，给出一点的响应）</li>\n<li>http响应过程是什么<br>在学习http的过程中，我们要学什么，请求报文呀，请求方法，响应头、状态码等等，为什么会有这些东西存在，说明这些在我http交流中充当着非常重要的角色，而我在上面的思考web服务器的时候<br>却并没有考虑这些东西。</li>\n</ol>\n<ul>\n<li>我的createServer只获取了参数，没做任何处理，你就是服务器呀，还准备让谁去做这件事情</li>\n<li>你去取request了吗？并没有，那怎么分析请求呢</li>\n<li>你返回数据的时候写响应头了吗？并没有，那怎么知道我的请求是否合法，你的状态码响应头什么的都怎么给呢</li>\n</ul>\n<p>正确的实现是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</span><br><span class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</span><br><span class=\"line\">    response.end(<span class=\"string\">'我是一台服务器\\n'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-实现一个函数function-add-a-b-能够处理超出js处理范围两个的和（可能是负数）\"><a href=\"#7-实现一个函数function-add-a-b-能够处理超出js处理范围两个的和（可能是负数）\" class=\"headerlink\" title=\"7. 实现一个函数function add(a,b){},能够处理超出js处理范围两个的和（可能是负数）\"></a>7. 实现一个函数function add(a,b){},能够处理超出js处理范围两个的和（可能是负数）</h4><hr>\n<p>做一个勤于思考的人</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-利用正则实现一个方法，取到”isvip”的cookie值\"><a href=\"#1-利用正则实现一个方法，取到”isvip”的cookie值\" class=\"headerlink\" title=\"1. 利用正则实现一个方法，取到”isvip”的cookie值\"></a>1. 利用正则实现一个方法，取到”isvip”的cookie值</h4><blockquote>\n<p>实现思路：</p>\n</blockquote>\n<ul>\n<li>获取本地的cookie：document.cookie;我们可以打印出来发现，cookie的格式为：name=xujiao; age=18; isVip=xsxdjc;</li>\n<li>通过正则的exec()方法，匹配到isVip=xsxdjc这段文字</li>\n<li>我们知道的是，正则中的小括号表示子匹配模式，匹配成功后保存到exec()返回的数组中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**需要注意：</span></span><br><span class=\"line\"><span class=\"comment\">（1）利用RegExp动态创建正则</span></span><br><span class=\"line\"><span class=\"comment\"> (2)使用\\\\w转义</span></span><br><span class=\"line\"><span class=\"comment\"> (3)(\\\\w*)中*需要放到括号内，否则匹配到的只是一个字符</span></span><br><span class=\"line\"><span class=\"comment\"> (4) 需要使用^开头，否则可能会匹配到，scdsisVip=xsxdjc</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCookie</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookies = <span class=\"built_in\">document</span>.cookie,</span><br><span class=\"line\">        reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"^\"</span>+name+<span class=\"string\">\"=(\\\\w*)\"</span>,<span class=\"string\">\"ig\"</span>),   </span><br><span class=\"line\">        match = reg.exec(cookies);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match &amp;&amp; match[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-利用css实现垂直居中（兼容IE6）\"><a href=\"#2-利用css实现垂直居中（兼容IE6）\" class=\"headerlink\" title=\"2. 利用css实现垂直居中（兼容IE6）\"></a>2. 利用css实现垂直居中（兼容IE6）</h4><p>具体的实现可以查看：<a href=\"http://www.xujiaosite.com/2017/03/CSS/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html#more\" target=\"_blank\" rel=\"noopener\">css实现垂直居中的几种方法</a></p>\n<h4 id=\"3-至少写出3中js的设计模式，并且做出详细说明（越多越好）\"><a href=\"#3-至少写出3中js的设计模式，并且做出详细说明（越多越好）\" class=\"headerlink\" title=\"3. 至少写出3中js的设计模式，并且做出详细说明（越多越好）\"></a>3. 至少写出3中js的设计模式，并且做出详细说明（越多越好）</h4><p>具体可以参考：<a href=\"http://www.xujiaosite.com/2017/04/JS/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html\" target=\"_blank\" rel=\"noopener\">JavaScript设计模式学习总结</a></p>\n<h4 id=\"4-详细说明TCP的三次握手，并配合手绘图-摘自网络\"><a href=\"#4-详细说明TCP的三次握手，并配合手绘图-摘自网络\" class=\"headerlink\" title=\"4. 详细说明TCP的三次握手，并配合手绘图(摘自网络)\"></a>4. 详细说明TCP的三次握手，并配合手绘图(摘自网络)</h4><p>开放系统互连参考模型 (Open System Interconnect 简称OSI）–网络的7层模型，网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。而我们常见的IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。<br>WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p>\n<ul>\n<li>什么是TCP连接的三次握手<ul>\n<li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;</li>\n<li>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</li>\n<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>\n</ul>\n</li>\n</ul>\n<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)</p>\n<pre><code>ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1\nSYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。\nFIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n</code></pre><p><img src=\"/images/TCP.PNG\" alt=\"TCP三次握手\">   </p>\n<ul>\n<li>HTTP链接的特点<ul>\n<li>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</li>\n<li>HTTP连接最显著的特点是<strong>客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接</strong>。从建立连接到关闭连接的过程称为“一次连接”。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-实现一个函数function-on-elem-type-handler-完成事件注册，保证this指向始终是elem，要求兼容IE8\"><a href=\"#5-实现一个函数function-on-elem-type-handler-完成事件注册，保证this指向始终是elem，要求兼容IE8\" class=\"headerlink\" title=\"5. 实现一个函数function on(elem,type,handler){}完成事件注册，保证this指向始终是elem，要求兼容IE8\"></a>5. 实现一个函数function on(elem,type,handler){}完成事件注册，保证this指向始终是elem，要求兼容IE8</h4><p>我们事件注册的方式有两种：addEventListener，attachEvent。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">on</span>(<span class=\"params\">elem,type,handle</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.addEventListener)&#123;</span><br><span class=\"line\">        elem.addEventListener(type,handle)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        elem.attachEvent(<span class=\"string\">\"on\"</span>+type,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            handle.apply(elem);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>需要注意的地方</p>\n<p> 一开始使用bind实现的，但是bind只支持IE9+，ff4+，chrome7+支持此方法，opera和safari不支持（MDN上的说明）。所以换了apply或者call实现。如果用bind就不需要外面在包一层function了，因为bind返回的就是一个函数</p>\n</li>\n<li><p>addEventListener和attachEvent的区别</p>\n</li>\n</ol>\n<ul>\n<li><p><code>兼容性</code>： addEventListener：是DOM2级事件注册方式（标准），但是只支持IE9+(包含IE9)以及其他浏览器。attachEvent：IE事件注册方式，IE8-</p>\n</li>\n<li><p><code>this的指向</code>： 在addEventListener的处理函数中this指向被绑定元素，而attachEvent始终指向window</p>\n</li>\n<li><p><code>代码执行顺序</code>：addEventListener按照绑定事件的顺序执行，而attachEvent与绑定事件的顺序相反执行</p>\n</li>\n<li><p><code>参数个数</code>：addEventListener有三个参数，第三个参数表示在哪个阶段捕获事件（false表示冒泡阶段），而attachEvent只支持事件冒泡</p>\n</li>\n<li><p><code>事件类型</code>：addEventListener的事件类型如：click,attachEvent的事件类型是:”on”+click</p>\n</li>\n</ul>\n<h4 id=\"6-利用node实现一个服务器，端口8080，返回”我是一台服务器”\"><a href=\"#6-利用node实现一个服务器，端口8080，返回”我是一台服务器”\" class=\"headerlink\" title=\"6. 利用node实现一个服务器，端口8080，返回”我是一台服务器”\"></a>6. 利用node实现一个服务器，端口8080，返回”我是一台服务器”</h4><p>在做笔试的时候看到这个题目差点没当场把自己砸死，送分题呀，可是我并不记得API。当时我就在卷子上认真的写着：</p>\n<p>我并没有用过node，我觉得首先node提供了一个http的核心模块，这个模块应该提供了一个类似于createServer的方法（没错，我猜对了方法），接下来我们应该提供一些参数，供服务器使用<br>比如port:端口，url:拦截的链接，response就是返回数据</p>\n<p>我写的是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.createServer(&#123;</span><br><span class=\"line\">    port:<span class=\"number\">8080</span>,</span><br><span class=\"line\">    url:<span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    response:<span class=\"string\">\"我是一台服务器\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>为什么要把我的错误的答案写上呢，其实这说明了什么，我没有认真的思考过web服务器的角色和http请求的过程</p>\n<ol>\n<li>web服务器的角色是什么：<br>用于处理用户的请求，并作出响应（拦截用户的http请求，根据请求所带来的一系列信息，给出一点的响应）</li>\n<li>http响应过程是什么<br>在学习http的过程中，我们要学什么，请求报文呀，请求方法，响应头、状态码等等，为什么会有这些东西存在，说明这些在我http交流中充当着非常重要的角色，而我在上面的思考web服务器的时候<br>却并没有考虑这些东西。</li>\n</ol>\n<ul>\n<li>我的createServer只获取了参数，没做任何处理，你就是服务器呀，还准备让谁去做这件事情</li>\n<li>你去取request了吗？并没有，那怎么分析请求呢</li>\n<li>你返回数据的时候写响应头了吗？并没有，那怎么知道我的请求是否合法，你的状态码响应头什么的都怎么给呢</li>\n</ul>\n<p>正确的实现是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</span><br><span class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</span><br><span class=\"line\">    response.end(<span class=\"string\">'我是一台服务器\\n'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-实现一个函数function-add-a-b-能够处理超出js处理范围两个的和（可能是负数）\"><a href=\"#7-实现一个函数function-add-a-b-能够处理超出js处理范围两个的和（可能是负数）\" class=\"headerlink\" title=\"7. 实现一个函数function add(a,b){},能够处理超出js处理范围两个的和（可能是负数）\"></a>7. 实现一个函数function add(a,b){},能够处理超出js处理范围两个的和（可能是负数）</h4><hr>\n<p>做一个勤于思考的人</p>\n"},{"title":"前端面试题-第二套","date":"2017-02-13T07:10:00.000Z","_content":"\n\n\n#### 1. 使用正则表达式精确匹配出如下字符串中加粗部分的 \"3052202501\"。ptui_loginuin=3052202501%20;pt2gguin=o3052202501;uin=o**3052202501**;ptisp=ctc\n  \n```javascript\n// 如果配合其他的字符的话,可以知道,加粗的那个\"3052202501\"\nvar rg1 = /uin=o(\\d{10})/g;\nvar match = rg1.exec(str);\nvar index = parseInt(match.index)+5\nconsole.log(\"匹配的字符串的位置在:\"+index);\nconsole.log(\"匹配到的字符串为:\"+match[1]);\n```\n        \n        \n#### 2. 完成方法count(str)，传入字符串，返回字符串中出现次数最多的字符及次数\n \n```javascript\n function count(str){\n                var length = str.length;\n                if(length ==0){\n                    return;\n                }\n                var max = 1;\n                var maxChar = str[0];\n                var obj = {};\n                for(var i = 0;i<length;i++){\n                    if(str[i] in obj){\n                        obj[str[i]] ++;\n                        if(max < obj[str[i]]){\n                            max = obj[str[i]];\n                            maxChar = str[i];\n                        }\n                    }else{\n                        obj[str[i]] = 1;\n                    }\n                }\n               return {\n                   maxNum : max,\n                   maxChar :maxChar\n               }\n            }\n```\n       \n \n \n#### 3. 假设你有一个函数rand5()，产生[0, 5)之间的随机整数，每个数字概率1/5，如何使用这个函数产生[0, 7)之间的随机整数，每个数字概率1/7\n    \n\n正确的方法是利用rand5()函数生成1-25之间的数字，然后将其中的1-21映射成1-7，丢弃22-25。\n\n    \n#### 4. 完成方法subset(arr1,arr2)，传入两个数组，判断数组arr1是否为数组arr2的子集\n \n#### 5. 现在有一个基准数组 records，先要求你维护其子集 selection 数组（初始为空），维护操作包含删除和插入。 插入：给定 records 数组中的一个元素，插入到 selection 中。删除：给定 records 数组中的一个元素，把它从 selection 中删除。现在要求你：实现 insert() 和 remove() 方法来实现以上操作。设计一个算法，保证每次维护操作后，保持 selection 数组中的元素的偏序关系与 records 数组中的保持一致，分析你算法的复杂度。\n \n\n \n \n\n\n","source":"_posts/前端面试题/前端面试题-第二套.md","raw":"---\ntitle: 前端面试题-第二套\ndate: 2017-02-13 15:10\ntags:\n  - 前端开发\n  - 前端面试题\n  - HTML5简介\ncategories: HTML5学习笔记\n---\n\n\n\n#### 1. 使用正则表达式精确匹配出如下字符串中加粗部分的 \"3052202501\"。ptui_loginuin=3052202501%20;pt2gguin=o3052202501;uin=o**3052202501**;ptisp=ctc\n  \n```javascript\n// 如果配合其他的字符的话,可以知道,加粗的那个\"3052202501\"\nvar rg1 = /uin=o(\\d{10})/g;\nvar match = rg1.exec(str);\nvar index = parseInt(match.index)+5\nconsole.log(\"匹配的字符串的位置在:\"+index);\nconsole.log(\"匹配到的字符串为:\"+match[1]);\n```\n        \n        \n#### 2. 完成方法count(str)，传入字符串，返回字符串中出现次数最多的字符及次数\n \n```javascript\n function count(str){\n                var length = str.length;\n                if(length ==0){\n                    return;\n                }\n                var max = 1;\n                var maxChar = str[0];\n                var obj = {};\n                for(var i = 0;i<length;i++){\n                    if(str[i] in obj){\n                        obj[str[i]] ++;\n                        if(max < obj[str[i]]){\n                            max = obj[str[i]];\n                            maxChar = str[i];\n                        }\n                    }else{\n                        obj[str[i]] = 1;\n                    }\n                }\n               return {\n                   maxNum : max,\n                   maxChar :maxChar\n               }\n            }\n```\n       \n \n \n#### 3. 假设你有一个函数rand5()，产生[0, 5)之间的随机整数，每个数字概率1/5，如何使用这个函数产生[0, 7)之间的随机整数，每个数字概率1/7\n    \n\n正确的方法是利用rand5()函数生成1-25之间的数字，然后将其中的1-21映射成1-7，丢弃22-25。\n\n    \n#### 4. 完成方法subset(arr1,arr2)，传入两个数组，判断数组arr1是否为数组arr2的子集\n \n#### 5. 现在有一个基准数组 records，先要求你维护其子集 selection 数组（初始为空），维护操作包含删除和插入。 插入：给定 records 数组中的一个元素，插入到 selection 中。删除：给定 records 数组中的一个元素，把它从 selection 中删除。现在要求你：实现 insert() 和 remove() 方法来实现以上操作。设计一个算法，保证每次维护操作后，保持 selection 数组中的元素的偏序关系与 records 数组中的保持一致，分析你算法的复杂度。\n \n\n \n \n\n\n","slug":"前端面试题/前端面试题-第二套","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj2z000j9oxz7uyyug5m","content":"<h4 id=\"1-使用正则表达式精确匹配出如下字符串中加粗部分的-“3052202501”。ptui-loginuin-3052202501-20-pt2gguin-o3052202501-uin-o3052202501-ptisp-ctc\"><a href=\"#1-使用正则表达式精确匹配出如下字符串中加粗部分的-“3052202501”。ptui-loginuin-3052202501-20-pt2gguin-o3052202501-uin-o3052202501-ptisp-ctc\" class=\"headerlink\" title=\"1. 使用正则表达式精确匹配出如下字符串中加粗部分的 “3052202501”。ptui_loginuin=3052202501%20;pt2gguin=o3052202501;uin=o3052202501;ptisp=ctc\"></a>1. 使用正则表达式精确匹配出如下字符串中加粗部分的 “3052202501”。ptui_loginuin=3052202501%20;pt2gguin=o3052202501;uin=o<strong>3052202501</strong>;ptisp=ctc</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果配合其他的字符的话,可以知道,加粗的那个\"3052202501\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rg1 = <span class=\"regexp\">/uin=o(\\d&#123;10&#125;)/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> match = rg1.exec(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"built_in\">parseInt</span>(match.index)+<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"匹配的字符串的位置在:\"</span>+index);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"匹配到的字符串为:\"</span>+match[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-完成方法count-str-，传入字符串，返回字符串中出现次数最多的字符及次数\"><a href=\"#2-完成方法count-str-，传入字符串，返回字符串中出现次数最多的字符及次数\" class=\"headerlink\" title=\"2. 完成方法count(str)，传入字符串，返回字符串中出现次数最多的字符及次数\"></a>2. 完成方法count(str)，传入字符串，返回字符串中出现次数最多的字符及次数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> length = str.length;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(length ==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> max = <span class=\"number\">1</span>;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> maxChar = str[<span class=\"number\">0</span>];</span><br><span class=\"line\">               <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">               <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;length;i++)&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">if</span>(str[i] <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">                       obj[str[i]] ++;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span>(max &lt; obj[str[i]])&#123;</span><br><span class=\"line\">                           max = obj[str[i]];</span><br><span class=\"line\">                           maxChar = str[i];</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                       obj[str[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                  maxNum : max,</span><br><span class=\"line\">                  maxChar :maxChar</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-假设你有一个函数rand5-，产生-0-5-之间的随机整数，每个数字概率1-5，如何使用这个函数产生-0-7-之间的随机整数，每个数字概率1-7\"><a href=\"#3-假设你有一个函数rand5-，产生-0-5-之间的随机整数，每个数字概率1-5，如何使用这个函数产生-0-7-之间的随机整数，每个数字概率1-7\" class=\"headerlink\" title=\"3. 假设你有一个函数rand5()，产生[0, 5)之间的随机整数，每个数字概率1/5，如何使用这个函数产生[0, 7)之间的随机整数，每个数字概率1/7\"></a>3. 假设你有一个函数rand5()，产生[0, 5)之间的随机整数，每个数字概率1/5，如何使用这个函数产生[0, 7)之间的随机整数，每个数字概率1/7</h4><p>正确的方法是利用rand5()函数生成1-25之间的数字，然后将其中的1-21映射成1-7，丢弃22-25。</p>\n<h4 id=\"4-完成方法subset-arr1-arr2-，传入两个数组，判断数组arr1是否为数组arr2的子集\"><a href=\"#4-完成方法subset-arr1-arr2-，传入两个数组，判断数组arr1是否为数组arr2的子集\" class=\"headerlink\" title=\"4. 完成方法subset(arr1,arr2)，传入两个数组，判断数组arr1是否为数组arr2的子集\"></a>4. 完成方法subset(arr1,arr2)，传入两个数组，判断数组arr1是否为数组arr2的子集</h4><h4 id=\"5-现在有一个基准数组-records，先要求你维护其子集-selection-数组（初始为空），维护操作包含删除和插入。-插入：给定-records-数组中的一个元素，插入到-selection-中。删除：给定-records-数组中的一个元素，把它从-selection-中删除。现在要求你：实现-insert-和-remove-方法来实现以上操作。设计一个算法，保证每次维护操作后，保持-selection-数组中的元素的偏序关系与-records-数组中的保持一致，分析你算法的复杂度。\"><a href=\"#5-现在有一个基准数组-records，先要求你维护其子集-selection-数组（初始为空），维护操作包含删除和插入。-插入：给定-records-数组中的一个元素，插入到-selection-中。删除：给定-records-数组中的一个元素，把它从-selection-中删除。现在要求你：实现-insert-和-remove-方法来实现以上操作。设计一个算法，保证每次维护操作后，保持-selection-数组中的元素的偏序关系与-records-数组中的保持一致，分析你算法的复杂度。\" class=\"headerlink\" title=\"5. 现在有一个基准数组 records，先要求你维护其子集 selection 数组（初始为空），维护操作包含删除和插入。 插入：给定 records 数组中的一个元素，插入到 selection 中。删除：给定 records 数组中的一个元素，把它从 selection 中删除。现在要求你：实现 insert() 和 remove() 方法来实现以上操作。设计一个算法，保证每次维护操作后，保持 selection 数组中的元素的偏序关系与 records 数组中的保持一致，分析你算法的复杂度。\"></a>5. 现在有一个基准数组 records，先要求你维护其子集 selection 数组（初始为空），维护操作包含删除和插入。 插入：给定 records 数组中的一个元素，插入到 selection 中。删除：给定 records 数组中的一个元素，把它从 selection 中删除。现在要求你：实现 insert() 和 remove() 方法来实现以上操作。设计一个算法，保证每次维护操作后，保持 selection 数组中的元素的偏序关系与 records 数组中的保持一致，分析你算法的复杂度。</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-使用正则表达式精确匹配出如下字符串中加粗部分的-“3052202501”。ptui-loginuin-3052202501-20-pt2gguin-o3052202501-uin-o3052202501-ptisp-ctc\"><a href=\"#1-使用正则表达式精确匹配出如下字符串中加粗部分的-“3052202501”。ptui-loginuin-3052202501-20-pt2gguin-o3052202501-uin-o3052202501-ptisp-ctc\" class=\"headerlink\" title=\"1. 使用正则表达式精确匹配出如下字符串中加粗部分的 “3052202501”。ptui_loginuin=3052202501%20;pt2gguin=o3052202501;uin=o3052202501;ptisp=ctc\"></a>1. 使用正则表达式精确匹配出如下字符串中加粗部分的 “3052202501”。ptui_loginuin=3052202501%20;pt2gguin=o3052202501;uin=o<strong>3052202501</strong>;ptisp=ctc</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果配合其他的字符的话,可以知道,加粗的那个\"3052202501\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rg1 = <span class=\"regexp\">/uin=o(\\d&#123;10&#125;)/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> match = rg1.exec(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"built_in\">parseInt</span>(match.index)+<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"匹配的字符串的位置在:\"</span>+index);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"匹配到的字符串为:\"</span>+match[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-完成方法count-str-，传入字符串，返回字符串中出现次数最多的字符及次数\"><a href=\"#2-完成方法count-str-，传入字符串，返回字符串中出现次数最多的字符及次数\" class=\"headerlink\" title=\"2. 完成方法count(str)，传入字符串，返回字符串中出现次数最多的字符及次数\"></a>2. 完成方法count(str)，传入字符串，返回字符串中出现次数最多的字符及次数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> length = str.length;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(length ==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> max = <span class=\"number\">1</span>;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> maxChar = str[<span class=\"number\">0</span>];</span><br><span class=\"line\">               <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">               <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;length;i++)&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">if</span>(str[i] <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">                       obj[str[i]] ++;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span>(max &lt; obj[str[i]])&#123;</span><br><span class=\"line\">                           max = obj[str[i]];</span><br><span class=\"line\">                           maxChar = str[i];</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                       obj[str[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                  maxNum : max,</span><br><span class=\"line\">                  maxChar :maxChar</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-假设你有一个函数rand5-，产生-0-5-之间的随机整数，每个数字概率1-5，如何使用这个函数产生-0-7-之间的随机整数，每个数字概率1-7\"><a href=\"#3-假设你有一个函数rand5-，产生-0-5-之间的随机整数，每个数字概率1-5，如何使用这个函数产生-0-7-之间的随机整数，每个数字概率1-7\" class=\"headerlink\" title=\"3. 假设你有一个函数rand5()，产生[0, 5)之间的随机整数，每个数字概率1/5，如何使用这个函数产生[0, 7)之间的随机整数，每个数字概率1/7\"></a>3. 假设你有一个函数rand5()，产生[0, 5)之间的随机整数，每个数字概率1/5，如何使用这个函数产生[0, 7)之间的随机整数，每个数字概率1/7</h4><p>正确的方法是利用rand5()函数生成1-25之间的数字，然后将其中的1-21映射成1-7，丢弃22-25。</p>\n<h4 id=\"4-完成方法subset-arr1-arr2-，传入两个数组，判断数组arr1是否为数组arr2的子集\"><a href=\"#4-完成方法subset-arr1-arr2-，传入两个数组，判断数组arr1是否为数组arr2的子集\" class=\"headerlink\" title=\"4. 完成方法subset(arr1,arr2)，传入两个数组，判断数组arr1是否为数组arr2的子集\"></a>4. 完成方法subset(arr1,arr2)，传入两个数组，判断数组arr1是否为数组arr2的子集</h4><h4 id=\"5-现在有一个基准数组-records，先要求你维护其子集-selection-数组（初始为空），维护操作包含删除和插入。-插入：给定-records-数组中的一个元素，插入到-selection-中。删除：给定-records-数组中的一个元素，把它从-selection-中删除。现在要求你：实现-insert-和-remove-方法来实现以上操作。设计一个算法，保证每次维护操作后，保持-selection-数组中的元素的偏序关系与-records-数组中的保持一致，分析你算法的复杂度。\"><a href=\"#5-现在有一个基准数组-records，先要求你维护其子集-selection-数组（初始为空），维护操作包含删除和插入。-插入：给定-records-数组中的一个元素，插入到-selection-中。删除：给定-records-数组中的一个元素，把它从-selection-中删除。现在要求你：实现-insert-和-remove-方法来实现以上操作。设计一个算法，保证每次维护操作后，保持-selection-数组中的元素的偏序关系与-records-数组中的保持一致，分析你算法的复杂度。\" class=\"headerlink\" title=\"5. 现在有一个基准数组 records，先要求你维护其子集 selection 数组（初始为空），维护操作包含删除和插入。 插入：给定 records 数组中的一个元素，插入到 selection 中。删除：给定 records 数组中的一个元素，把它从 selection 中删除。现在要求你：实现 insert() 和 remove() 方法来实现以上操作。设计一个算法，保证每次维护操作后，保持 selection 数组中的元素的偏序关系与 records 数组中的保持一致，分析你算法的复杂度。\"></a>5. 现在有一个基准数组 records，先要求你维护其子集 selection 数组（初始为空），维护操作包含删除和插入。 插入：给定 records 数组中的一个元素，插入到 selection 中。删除：给定 records 数组中的一个元素，把它从 selection 中删除。现在要求你：实现 insert() 和 remove() 方法来实现以上操作。设计一个算法，保证每次维护操作后，保持 selection 数组中的元素的偏序关系与 records 数组中的保持一致，分析你算法的复杂度。</h4>"},{"title":"git学习笔记","date":"2017-02-13T07:49:00.000Z","_content":"\n\n### 1. 强制从远程拉取最新代码\n\ngit reset --hard remote remote address\n    \n### 2. 已经拉取远程代码，现在需要clone某一个分支\n\ngit checkout remote/branch-name\n\n### 3. 将本地创建的分支提交至远程\n\n+ 远程新分支: git push origin new branch name,可以是本地分支名\n+ 远程老分支: git push origin 本地分支名：远程分支名(也可以用于创建新分支)\n    \n### 4. git init \n \n将当前的文件夹加入git的版本控制,该文件夹下默认会生成一个隐藏的.git文件夹,里面保存着各个分支各个版本的代码\n\n### 5. git status\n\n查看文件是否被修改\n\n### 6. git diff\n\n查看文件修改内容\n\n### 7. git reflog\n\n用来记录每一次的提交 \n\n### 8. 撤销工作区的修改(未add和commit的)\n\ngit checkout --file / git checkout -- .\n\n### 9. 回退版本-git reset\n+ 参数\n    + hard\n    + soft\n    + mixed\n    \n+ git reset --hard commit_id  \n   \n   git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容\n   \n### 10. git rm file \n \n 删除一个文件\n \n### 11. git 分支\n\n+ 在本地,工作区只有一个,所以工作区所有的修改,只要没有提交到对应的分支上,会体现在所有的分支\n+ git add 将工作区的内容提交到暂存区\n+ git commit 将暂存区的内容提交到当前分支\n+ 常用分支命令\n    + git branch:查看分支\n    + git branch -a：查看远程分支\n    + git checkout branch-name: 切换分支\n    + git checkout -b name: 创建并且切换分支\n    + git branch -d branch-name: 删除分支\n    + git merge xxx:  将xxx分支的内容合并到当前分支\n\n### 12. git stash\n\n+ 暂时存储当前工区的内容\n+ 存储后,任何分支都没有之前的修改,因为没有add commit\n+ git stash操作的区域仍然是工作区,所以所有的分支都能读到暂存的内容\n+ 暂存的常用命令\n    + git stash list: 查看所有的stash内容\n    + git stash apply: 恢复stash内容\n    + git stash drop: 删除stash的内容\n    + git stash pop: 恢复并且删除stash的内容\n    \n### 13. git tag\n\n打标签,方便回滚,这个主要哦针对一个完整功能上线时打一个tag,方便回滚到上一个功能(类似于-m的作用,只是-m针对每一次的提交)\n\n+ git tag: 控制台打印所有的标签\n+ git tag -l 'V0.1*': 搜索符合模式的tag\n+ 打标签的常用命令\n    + 切换标签: git checkout tagname\n    + git tag -g v0.1.1.9fbc3d0 :给特定的commit打tag\n    + 标签的发布: git push origin -tags # 说明\n    \n    \n### 14. 将本地文件夹关联远程仓库\n\ngit remote add origin git@http://xujiao1989/xxx\n\n\n \n### 15. 关于.gitignore\n+ 只能忽略那些原来没有被trace的文件\n+ 如何解决添加规则后不生效的问题\n    \n     git rm --cached file\n     \n     忽略整个文件夹下： git rm --cached file_path -r\n\n### 16. 查看git配置等\n\ngit config -l\n\n### 17. TIPS\n\n+ git跟踪的是修改,而不是文件\n+ 在git当中,HEAD表示的是当前版本,上一个版本是HEAD^,上上个版本是HEAD^^,所以回退到上一个版本可以是git reset --hard HEAD^(这里也可以是特定的提交)\n\n    ","source":"_posts/版本控制/2017-02-13-git学习笔记.md","raw":"---\ntitle: git学习笔记\ndate: 2017-02-13 15:49\ntags:\n  - 前端开发\n  - 代码版本控制\n  - git\ncategories: 代码版本控制\n---\n\n\n### 1. 强制从远程拉取最新代码\n\ngit reset --hard remote remote address\n    \n### 2. 已经拉取远程代码，现在需要clone某一个分支\n\ngit checkout remote/branch-name\n\n### 3. 将本地创建的分支提交至远程\n\n+ 远程新分支: git push origin new branch name,可以是本地分支名\n+ 远程老分支: git push origin 本地分支名：远程分支名(也可以用于创建新分支)\n    \n### 4. git init \n \n将当前的文件夹加入git的版本控制,该文件夹下默认会生成一个隐藏的.git文件夹,里面保存着各个分支各个版本的代码\n\n### 5. git status\n\n查看文件是否被修改\n\n### 6. git diff\n\n查看文件修改内容\n\n### 7. git reflog\n\n用来记录每一次的提交 \n\n### 8. 撤销工作区的修改(未add和commit的)\n\ngit checkout --file / git checkout -- .\n\n### 9. 回退版本-git reset\n+ 参数\n    + hard\n    + soft\n    + mixed\n    \n+ git reset --hard commit_id  \n   \n   git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容\n   \n### 10. git rm file \n \n 删除一个文件\n \n### 11. git 分支\n\n+ 在本地,工作区只有一个,所以工作区所有的修改,只要没有提交到对应的分支上,会体现在所有的分支\n+ git add 将工作区的内容提交到暂存区\n+ git commit 将暂存区的内容提交到当前分支\n+ 常用分支命令\n    + git branch:查看分支\n    + git branch -a：查看远程分支\n    + git checkout branch-name: 切换分支\n    + git checkout -b name: 创建并且切换分支\n    + git branch -d branch-name: 删除分支\n    + git merge xxx:  将xxx分支的内容合并到当前分支\n\n### 12. git stash\n\n+ 暂时存储当前工区的内容\n+ 存储后,任何分支都没有之前的修改,因为没有add commit\n+ git stash操作的区域仍然是工作区,所以所有的分支都能读到暂存的内容\n+ 暂存的常用命令\n    + git stash list: 查看所有的stash内容\n    + git stash apply: 恢复stash内容\n    + git stash drop: 删除stash的内容\n    + git stash pop: 恢复并且删除stash的内容\n    \n### 13. git tag\n\n打标签,方便回滚,这个主要哦针对一个完整功能上线时打一个tag,方便回滚到上一个功能(类似于-m的作用,只是-m针对每一次的提交)\n\n+ git tag: 控制台打印所有的标签\n+ git tag -l 'V0.1*': 搜索符合模式的tag\n+ 打标签的常用命令\n    + 切换标签: git checkout tagname\n    + git tag -g v0.1.1.9fbc3d0 :给特定的commit打tag\n    + 标签的发布: git push origin -tags # 说明\n    \n    \n### 14. 将本地文件夹关联远程仓库\n\ngit remote add origin git@http://xujiao1989/xxx\n\n\n \n### 15. 关于.gitignore\n+ 只能忽略那些原来没有被trace的文件\n+ 如何解决添加规则后不生效的问题\n    \n     git rm --cached file\n     \n     忽略整个文件夹下： git rm --cached file_path -r\n\n### 16. 查看git配置等\n\ngit config -l\n\n### 17. TIPS\n\n+ git跟踪的是修改,而不是文件\n+ 在git当中,HEAD表示的是当前版本,上一个版本是HEAD^,上上个版本是HEAD^^,所以回退到上一个版本可以是git reset --hard HEAD^(这里也可以是特定的提交)\n\n    ","slug":"版本控制/2017-02-13-git学习笔记","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj31000n9oxz4otq9hal","content":"<h3 id=\"1-强制从远程拉取最新代码\"><a href=\"#1-强制从远程拉取最新代码\" class=\"headerlink\" title=\"1. 强制从远程拉取最新代码\"></a>1. 强制从远程拉取最新代码</h3><p>git reset –hard remote remote address</p>\n<h3 id=\"2-已经拉取远程代码，现在需要clone某一个分支\"><a href=\"#2-已经拉取远程代码，现在需要clone某一个分支\" class=\"headerlink\" title=\"2. 已经拉取远程代码，现在需要clone某一个分支\"></a>2. 已经拉取远程代码，现在需要clone某一个分支</h3><p>git checkout remote/branch-name</p>\n<h3 id=\"3-将本地创建的分支提交至远程\"><a href=\"#3-将本地创建的分支提交至远程\" class=\"headerlink\" title=\"3. 将本地创建的分支提交至远程\"></a>3. 将本地创建的分支提交至远程</h3><ul>\n<li>远程新分支: git push origin new branch name,可以是本地分支名</li>\n<li>远程老分支: git push origin 本地分支名：远程分支名(也可以用于创建新分支)</li>\n</ul>\n<h3 id=\"4-git-init\"><a href=\"#4-git-init\" class=\"headerlink\" title=\"4. git init\"></a>4. git init</h3><p>将当前的文件夹加入git的版本控制,该文件夹下默认会生成一个隐藏的.git文件夹,里面保存着各个分支各个版本的代码</p>\n<h3 id=\"5-git-status\"><a href=\"#5-git-status\" class=\"headerlink\" title=\"5. git status\"></a>5. git status</h3><p>查看文件是否被修改</p>\n<h3 id=\"6-git-diff\"><a href=\"#6-git-diff\" class=\"headerlink\" title=\"6. git diff\"></a>6. git diff</h3><p>查看文件修改内容</p>\n<h3 id=\"7-git-reflog\"><a href=\"#7-git-reflog\" class=\"headerlink\" title=\"7. git reflog\"></a>7. git reflog</h3><p>用来记录每一次的提交 </p>\n<h3 id=\"8-撤销工作区的修改-未add和commit的\"><a href=\"#8-撤销工作区的修改-未add和commit的\" class=\"headerlink\" title=\"8. 撤销工作区的修改(未add和commit的)\"></a>8. 撤销工作区的修改(未add和commit的)</h3><p>git checkout –file / git checkout – .</p>\n<h3 id=\"9-回退版本-git-reset\"><a href=\"#9-回退版本-git-reset\" class=\"headerlink\" title=\"9. 回退版本-git reset\"></a>9. 回退版本-git reset</h3><ul>\n<li><p>参数</p>\n<ul>\n<li>hard</li>\n<li>soft</li>\n<li>mixed</li>\n</ul>\n</li>\n<li><p>git reset –hard commit_id  </p>\n<p> git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p>\n</li>\n</ul>\n<h3 id=\"10-git-rm-file\"><a href=\"#10-git-rm-file\" class=\"headerlink\" title=\"10. git rm file\"></a>10. git rm file</h3><p> 删除一个文件</p>\n<h3 id=\"11-git-分支\"><a href=\"#11-git-分支\" class=\"headerlink\" title=\"11. git 分支\"></a>11. git 分支</h3><ul>\n<li>在本地,工作区只有一个,所以工作区所有的修改,只要没有提交到对应的分支上,会体现在所有的分支</li>\n<li>git add 将工作区的内容提交到暂存区</li>\n<li>git commit 将暂存区的内容提交到当前分支</li>\n<li>常用分支命令<ul>\n<li>git branch:查看分支</li>\n<li>git branch -a：查看远程分支</li>\n<li>git checkout branch-name: 切换分支</li>\n<li>git checkout -b name: 创建并且切换分支</li>\n<li>git branch -d branch-name: 删除分支</li>\n<li>git merge xxx:  将xxx分支的内容合并到当前分支</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-git-stash\"><a href=\"#12-git-stash\" class=\"headerlink\" title=\"12. git stash\"></a>12. git stash</h3><ul>\n<li>暂时存储当前工区的内容</li>\n<li>存储后,任何分支都没有之前的修改,因为没有add commit</li>\n<li>git stash操作的区域仍然是工作区,所以所有的分支都能读到暂存的内容</li>\n<li>暂存的常用命令<ul>\n<li>git stash list: 查看所有的stash内容</li>\n<li>git stash apply: 恢复stash内容</li>\n<li>git stash drop: 删除stash的内容</li>\n<li>git stash pop: 恢复并且删除stash的内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-git-tag\"><a href=\"#13-git-tag\" class=\"headerlink\" title=\"13. git tag\"></a>13. git tag</h3><p>打标签,方便回滚,这个主要哦针对一个完整功能上线时打一个tag,方便回滚到上一个功能(类似于-m的作用,只是-m针对每一次的提交)</p>\n<ul>\n<li>git tag: 控制台打印所有的标签</li>\n<li>git tag -l ‘V0.1*’: 搜索符合模式的tag</li>\n<li>打标签的常用命令<ul>\n<li>切换标签: git checkout tagname</li>\n<li>git tag -g v0.1.1.9fbc3d0 :给特定的commit打tag</li>\n<li>标签的发布: git push origin -tags # 说明</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-将本地文件夹关联远程仓库\"><a href=\"#14-将本地文件夹关联远程仓库\" class=\"headerlink\" title=\"14. 将本地文件夹关联远程仓库\"></a>14. 将本地文件夹关联远程仓库</h3><p>git remote add origin git@<a href=\"http://xujiao1989/xxx\" target=\"_blank\" rel=\"noopener\">http://xujiao1989/xxx</a></p>\n<h3 id=\"15-关于-gitignore\"><a href=\"#15-关于-gitignore\" class=\"headerlink\" title=\"15. 关于.gitignore\"></a>15. 关于.gitignore</h3><ul>\n<li>只能忽略那些原来没有被trace的文件</li>\n<li><p>如何解决添加规则后不生效的问题</p>\n<p>   git rm –cached file</p>\n<p>   忽略整个文件夹下： git rm –cached file_path -r</p>\n</li>\n</ul>\n<h3 id=\"16-查看git配置等\"><a href=\"#16-查看git配置等\" class=\"headerlink\" title=\"16. 查看git配置等\"></a>16. 查看git配置等</h3><p>git config -l</p>\n<h3 id=\"17-TIPS\"><a href=\"#17-TIPS\" class=\"headerlink\" title=\"17. TIPS\"></a>17. TIPS</h3><ul>\n<li>git跟踪的是修改,而不是文件</li>\n<li>在git当中,HEAD表示的是当前版本,上一个版本是HEAD^,上上个版本是HEAD^^,所以回退到上一个版本可以是git reset –hard HEAD^(这里也可以是特定的提交)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-强制从远程拉取最新代码\"><a href=\"#1-强制从远程拉取最新代码\" class=\"headerlink\" title=\"1. 强制从远程拉取最新代码\"></a>1. 强制从远程拉取最新代码</h3><p>git reset –hard remote remote address</p>\n<h3 id=\"2-已经拉取远程代码，现在需要clone某一个分支\"><a href=\"#2-已经拉取远程代码，现在需要clone某一个分支\" class=\"headerlink\" title=\"2. 已经拉取远程代码，现在需要clone某一个分支\"></a>2. 已经拉取远程代码，现在需要clone某一个分支</h3><p>git checkout remote/branch-name</p>\n<h3 id=\"3-将本地创建的分支提交至远程\"><a href=\"#3-将本地创建的分支提交至远程\" class=\"headerlink\" title=\"3. 将本地创建的分支提交至远程\"></a>3. 将本地创建的分支提交至远程</h3><ul>\n<li>远程新分支: git push origin new branch name,可以是本地分支名</li>\n<li>远程老分支: git push origin 本地分支名：远程分支名(也可以用于创建新分支)</li>\n</ul>\n<h3 id=\"4-git-init\"><a href=\"#4-git-init\" class=\"headerlink\" title=\"4. git init\"></a>4. git init</h3><p>将当前的文件夹加入git的版本控制,该文件夹下默认会生成一个隐藏的.git文件夹,里面保存着各个分支各个版本的代码</p>\n<h3 id=\"5-git-status\"><a href=\"#5-git-status\" class=\"headerlink\" title=\"5. git status\"></a>5. git status</h3><p>查看文件是否被修改</p>\n<h3 id=\"6-git-diff\"><a href=\"#6-git-diff\" class=\"headerlink\" title=\"6. git diff\"></a>6. git diff</h3><p>查看文件修改内容</p>\n<h3 id=\"7-git-reflog\"><a href=\"#7-git-reflog\" class=\"headerlink\" title=\"7. git reflog\"></a>7. git reflog</h3><p>用来记录每一次的提交 </p>\n<h3 id=\"8-撤销工作区的修改-未add和commit的\"><a href=\"#8-撤销工作区的修改-未add和commit的\" class=\"headerlink\" title=\"8. 撤销工作区的修改(未add和commit的)\"></a>8. 撤销工作区的修改(未add和commit的)</h3><p>git checkout –file / git checkout – .</p>\n<h3 id=\"9-回退版本-git-reset\"><a href=\"#9-回退版本-git-reset\" class=\"headerlink\" title=\"9. 回退版本-git reset\"></a>9. 回退版本-git reset</h3><ul>\n<li><p>参数</p>\n<ul>\n<li>hard</li>\n<li>soft</li>\n<li>mixed</li>\n</ul>\n</li>\n<li><p>git reset –hard commit_id  </p>\n<p> git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p>\n</li>\n</ul>\n<h3 id=\"10-git-rm-file\"><a href=\"#10-git-rm-file\" class=\"headerlink\" title=\"10. git rm file\"></a>10. git rm file</h3><p> 删除一个文件</p>\n<h3 id=\"11-git-分支\"><a href=\"#11-git-分支\" class=\"headerlink\" title=\"11. git 分支\"></a>11. git 分支</h3><ul>\n<li>在本地,工作区只有一个,所以工作区所有的修改,只要没有提交到对应的分支上,会体现在所有的分支</li>\n<li>git add 将工作区的内容提交到暂存区</li>\n<li>git commit 将暂存区的内容提交到当前分支</li>\n<li>常用分支命令<ul>\n<li>git branch:查看分支</li>\n<li>git branch -a：查看远程分支</li>\n<li>git checkout branch-name: 切换分支</li>\n<li>git checkout -b name: 创建并且切换分支</li>\n<li>git branch -d branch-name: 删除分支</li>\n<li>git merge xxx:  将xxx分支的内容合并到当前分支</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-git-stash\"><a href=\"#12-git-stash\" class=\"headerlink\" title=\"12. git stash\"></a>12. git stash</h3><ul>\n<li>暂时存储当前工区的内容</li>\n<li>存储后,任何分支都没有之前的修改,因为没有add commit</li>\n<li>git stash操作的区域仍然是工作区,所以所有的分支都能读到暂存的内容</li>\n<li>暂存的常用命令<ul>\n<li>git stash list: 查看所有的stash内容</li>\n<li>git stash apply: 恢复stash内容</li>\n<li>git stash drop: 删除stash的内容</li>\n<li>git stash pop: 恢复并且删除stash的内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-git-tag\"><a href=\"#13-git-tag\" class=\"headerlink\" title=\"13. git tag\"></a>13. git tag</h3><p>打标签,方便回滚,这个主要哦针对一个完整功能上线时打一个tag,方便回滚到上一个功能(类似于-m的作用,只是-m针对每一次的提交)</p>\n<ul>\n<li>git tag: 控制台打印所有的标签</li>\n<li>git tag -l ‘V0.1*’: 搜索符合模式的tag</li>\n<li>打标签的常用命令<ul>\n<li>切换标签: git checkout tagname</li>\n<li>git tag -g v0.1.1.9fbc3d0 :给特定的commit打tag</li>\n<li>标签的发布: git push origin -tags # 说明</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-将本地文件夹关联远程仓库\"><a href=\"#14-将本地文件夹关联远程仓库\" class=\"headerlink\" title=\"14. 将本地文件夹关联远程仓库\"></a>14. 将本地文件夹关联远程仓库</h3><p>git remote add origin git@<a href=\"http://xujiao1989/xxx\" target=\"_blank\" rel=\"noopener\">http://xujiao1989/xxx</a></p>\n<h3 id=\"15-关于-gitignore\"><a href=\"#15-关于-gitignore\" class=\"headerlink\" title=\"15. 关于.gitignore\"></a>15. 关于.gitignore</h3><ul>\n<li>只能忽略那些原来没有被trace的文件</li>\n<li><p>如何解决添加规则后不生效的问题</p>\n<p>   git rm –cached file</p>\n<p>   忽略整个文件夹下： git rm –cached file_path -r</p>\n</li>\n</ul>\n<h3 id=\"16-查看git配置等\"><a href=\"#16-查看git配置等\" class=\"headerlink\" title=\"16. 查看git配置等\"></a>16. 查看git配置等</h3><p>git config -l</p>\n<h3 id=\"17-TIPS\"><a href=\"#17-TIPS\" class=\"headerlink\" title=\"17. TIPS\"></a>17. TIPS</h3><ul>\n<li>git跟踪的是修改,而不是文件</li>\n<li>在git当中,HEAD表示的是当前版本,上一个版本是HEAD^,上上个版本是HEAD^^,所以回退到上一个版本可以是git reset –hard HEAD^(这里也可以是特定的提交)</li>\n</ul>\n"},{"title":"前端性能优化--学习总结","date":"2017-04-04T16:00:00.000Z","_content":"\n本文主要是自己在了解前端性能优化过程觉得比较好的文章的总结。\n\n## 一、雅虎军规14条\n前端的性能优化已经是老生常谈的话题，面试和实际工作中都会遇到如何去做前端优化。在做优化之前，我们至少要熟知雅虎的14条军规：\n\n![雅虎军规35条](/images/雅虎35.PNG)\n\n#### 1.1 尽可能的减少http请求\n网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。\n\n+ 合并文件（js、css、雪碧图等),并使用css的background-image和background-position属性来实现所需部分的图片\n+ Inline images: 通过编码的字符串将图片内嵌到网页文本中。例如下面的inline image的显示效果为一个勾选的checkbox。\n```css\n.sample-inline-png {\n    padding-left: 20px;\n    background: white url('data:image/png;base64,iVBOR....') no-repeat scroll left top;\n}\n```\n+ 减少http请求次数是性能优化的起点！对提高首次访问效率起到很重要的作用。\n\n#### 1.2 使用CDN\n\n通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，杭州的用户访问近杭州服务器上的内容，北京的访问 近北京服务器上的内容。这样可以有效减少数据在网络上传输的时间，提高速度。\n\n\n#### 1.3 添加Expires或者cache-control\n\n合理使用浏览器缓存来减少http请求次数和大小，使得网页加速装载。\n\n#### 1.4 启用Gzip压缩\n\nGzip的思想就是把文件先在服务器端进行压缩，然后再传输。这样可以显著减少文件传输的大小。传输完毕后浏览器会 重新对压缩过的内容进行解压缩，并执行。目前的浏览器都能“良好”地支持 gzip。不仅浏览器可以识别，而且各大“爬虫”也同样可以识别，各位seoer可以放下心了。而且gzip的压缩比例非常大，一般压缩率为85%，就是 说服务器端100K的页面可以压缩到25K左右再发送到客户端。\n\n#### 1.5 将css放在页面的上方\n\n将css放在页面最上面，这是为什么？因为 ie，firefox等浏览器在css全部传输完全之前不会去渲染任何的东西。理由诚如小马哥说得那样很简单。css，全称Cascading Style Sheets (层叠样式表单)。层叠即意味这后面的css可以覆盖前面的css，级别高的css可以覆盖级别低的css。既然前面的可以被覆盖，浏览器在他完全加载完毕之后再去渲染无疑也是合情合理的很多浏览器下，如IE，把样式表放在页面的底部的问题在于它禁止了网页内容的顺序显示。浏览器阻止显示以免重画页面元素，那用户只能看到空白页了。Firefox不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需要重画，这导致闪烁问题。所以我们应该尽快让css加载完毕\n\n#### 1.6 将脚本移动到底部（包括内联的）\n\n+ 因为防止script脚本的执行阻塞页面的下载。在页面loading的过程中，当浏览器读到js执行语句的时候一定会把它全部解释完毕后在会接下来读下面的内容。不信你可以写一个js死循环看看页面下面的东西还会不会出来。（setTimeout 和 setInterval的执行有点类似于多线程，在相应的响应时间之前也会继续下面的内容渲染。）浏览器这么做的逻辑是因为js随时可能执行 location.href或是其他可能完全中断此页面过程的函数，即如此，当然得等他执行完毕之后再加载咯。所以放在页面最后，可以有效减少页面可视元素的加载时间。\n+ 脚本引起的第二个问题是它阻塞并行下载数量。HTTP/1.1规范建议浏览器每个主机的并行下载数不超过2个（IE只能为2个，其他浏览器如ff等都是默认设置为2个，不过新出的ie8可以达6个）。因此如果您把图像文件分布到多台机器的话，您可以达到超过2个的并行下载。但是当脚本文件下载时，浏览器不会启动其他的并行下载。\n\n#### 1.7 避免使用CSS中的expression\n\n“为了确保有效性，CSS 表达式会进行频繁的求值”，到底有多频繁？就是在你改变窗口大小，滚动页面甚至移动鼠标都会触发表达式进行求值，如此频繁的求值以至于浏览器的性能收到严重的影响；\n\n#### 1.8 将JavaScript和css独立成外部文件\n\n这点我想还是很容易理解的。不仅从性能优化上会这么做，用代码易于维护的角度看也应该这么做。把css和js写在页面内容可以减少2次请求，但也增 大了页面的大小。如果已经对css和js做了缓存，那也就没有2次多余的http请求了。当然，我在前面中也说过，有些特殊的页面开发人员还是会选择内联 的css和js文件。\n\n#### 1.9 减少DNS查询\n\n在 Internet上域名与IP地址之间是一一对应的，域名（kuqin.com）很好记，但计算机不认识，计算机之间的“相认”还要转成ip地址。在网络 上每台计算机都对应有一个独立的ip地址。在域名和ip地址之间的转换工作称为域名解析，也称DNS查询。一次DNS的解析过程会消耗20-120毫秒的 时间,在dns查询结束之前，浏览器不会下载该域名下的任何东西。所以减少dns查询的时间可以加快页面的加载速度。yahoo的建议一个页面所包含的域 名数尽量控制在2-4个。这就需要对页面整体有一个很好的规划。\n\n#### 1.10  压缩JavaScript和CSS\n\n压缩js和css的左右很显然，减少页面字节数。容量小页面加载速度自然也就快。而且压缩除了减少体积以外还可以起到一定的保护左右。\n#### 1.11 避免重定向\n\n每增加一次重定向就会增加一次web请求，所以因该尽量减少。\n\n+ 301 Moved Permanently\n\n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。\n\n+ 302 Found\n\n请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。\n\n#### 1.12 移除重复的脚本\n\n不仅是从性能上考虑，代码规范上看也是这样。\n\n#### 1.13 配置实体标签ETags(也是从缓存的角度而言的)\n\nHTTP协议规格说明定义ETag为“被请求变量的实体值”, 是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端。\n聪明的服务器开发者会把ETags和GET请求的“If-None-Match”头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。\n\n其过程如下：\n\n+ 客户端请求一个页面（A）。\n+ 服务器返回页面A，并在给A加上一个ETag。\n+ 客户端展现该页面，并将页面连同ETag一起缓存。\n+ 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。\n+ 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。\n\n#### 1.14 使用ajax缓存\n\najax还要去缓存？做ajax请求的时候往往还要增加一个时间戳去避免他缓存。记住“异步”不是“瞬间”这一点很重要。记住，即使AJAX是动态产生的而且只对一个用户起作用，他们依然可以被缓存。\n\n\n> 雅虎14条总结起来其实就是以下几个方面：记住5432\n\n + 优化请求次数和请求路径（5个）\n\n 减少http请求、合并js和css代码、使用CDN、避免重定向、减少DNS查询\n\n + 合理利用缓存，减少请求次数（4个）\n\n 使用Expires和cache-control、配置ETags、使用ajax缓存，将js和css独立出来\n\n + 代码层面（3个）\n\n 避免使用css表达式、将css放在页面头部、将js放在页面底部\n\n + 减少文件的体积（2个）\n\n 启用GZip、删除重复代码\n## 二、我们在工作中如何做优化\n\n对于已有的项目，我们可以利用chrome的network查看页面中资源的加载速度和哪些资源特别的消耗了性能；利用chrome插件pagespeed分析页面，它会针对页面给出详细的分析和推荐解决方案。\n总的来说，还是要遵循雅虎14条。\n\n#### 1.1 其他需要考虑的地方\n+ 关于图片的优化\n\n    推荐读下面的几篇文章\n\n+ 关于css的优化\n    + 合理的合并css文件\n    + 不要使用css的表达式：\n    + 将样式表放在头部、使用link代替import\n    + 避免使用filters\n\n+ 关于js的优化\n\n    + 避免使用with\n    + 减少dom的访问\n    + js放在页面底部\n\n+ 减少repaint和reflow\n\n+ 根据域名划分内容\n浏览器一般对**同一个域的下载连接数有所限制，按照域名划分下载内容可以浏览器增大并行下载连接，**但是注意控制域名使用在2-4个之间，不然dns查询也是个问题。一般网站规划会将静态资源放在类似于static.example.com，动态内容放在www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。后面我们会在cookie的规则中提到。\n\n+ 减少iframe数量\n\n    > 优点：\n\n        可以用来加载速度较慢的内容，例如广告。\n        安全沙箱保护。浏览器会对iframe中的内容进行安全控制。\n        脚本可以并行下载\n\n    > 缺点：\n\n        即使iframe内容为空也消耗加载时间\n        会阻止页面加载\n        没有语义\n\n## 三、推荐阅读\n\n+ [dns-prefetch 对性能提升有多大](http://blog.sina.com.cn/s/blog_bf9440220102wwgo.html)\n+ [前端性能优化----yahoo前端性能团队总结的35条黄金定律](前端性能优化----yahoo前端性能团队总结的35条黄金定律)\n+ [Web性能优化：图片优化](http://www.cnblogs.com/wizcabbit/p/web-image-optimization.html)\n+ [前端开发中，对图片的优化技巧有哪些？](https://www.zhihu.com/question/21815101)\n+ [WebP 探寻之路](http://isux.tencent.com/introduction-of-webp.html)\n+ [CSS Expression用法总结](http://www.cnblogs.com/rubylouvre/archive/2009/07/29/1534330.html)\n+ [javascript性能优化-repaint和reflow](http://www.cnblogs.com/jiajiaobj/archive/2012/06/11/2545291.html)\n+ [回流与重绘：CSS性能让JavaScript变慢？](http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/)\n+ [[Web 性能] repaint and reflow (重绘和回流)](http://blog.csdn.net/oscar999/article/details/38379523)\n+ [优化TTFB](http://blog.csdn.net/fumier/article/details/50511174)\n+ [网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)\n+ [减少页面回流与重绘（Reflow & Repaint）](http://harttle.com/2015/08/11/reflow-repaint.html)\n---\n做一个勤于思考的人\n","source":"_posts/性能优化/前端性能优化--学习总结.md","raw":"---\ntitle: 前端性能优化--学习总结\ndate: 2017-04-05\ntags:\n  - 前端开发\n  - 个人成长\n  - 前端性能优化\ncategories: 性能优化\n---\n\n本文主要是自己在了解前端性能优化过程觉得比较好的文章的总结。\n\n## 一、雅虎军规14条\n前端的性能优化已经是老生常谈的话题，面试和实际工作中都会遇到如何去做前端优化。在做优化之前，我们至少要熟知雅虎的14条军规：\n\n![雅虎军规35条](/images/雅虎35.PNG)\n\n#### 1.1 尽可能的减少http请求\n网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。\n\n+ 合并文件（js、css、雪碧图等),并使用css的background-image和background-position属性来实现所需部分的图片\n+ Inline images: 通过编码的字符串将图片内嵌到网页文本中。例如下面的inline image的显示效果为一个勾选的checkbox。\n```css\n.sample-inline-png {\n    padding-left: 20px;\n    background: white url('data:image/png;base64,iVBOR....') no-repeat scroll left top;\n}\n```\n+ 减少http请求次数是性能优化的起点！对提高首次访问效率起到很重要的作用。\n\n#### 1.2 使用CDN\n\n通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，杭州的用户访问近杭州服务器上的内容，北京的访问 近北京服务器上的内容。这样可以有效减少数据在网络上传输的时间，提高速度。\n\n\n#### 1.3 添加Expires或者cache-control\n\n合理使用浏览器缓存来减少http请求次数和大小，使得网页加速装载。\n\n#### 1.4 启用Gzip压缩\n\nGzip的思想就是把文件先在服务器端进行压缩，然后再传输。这样可以显著减少文件传输的大小。传输完毕后浏览器会 重新对压缩过的内容进行解压缩，并执行。目前的浏览器都能“良好”地支持 gzip。不仅浏览器可以识别，而且各大“爬虫”也同样可以识别，各位seoer可以放下心了。而且gzip的压缩比例非常大，一般压缩率为85%，就是 说服务器端100K的页面可以压缩到25K左右再发送到客户端。\n\n#### 1.5 将css放在页面的上方\n\n将css放在页面最上面，这是为什么？因为 ie，firefox等浏览器在css全部传输完全之前不会去渲染任何的东西。理由诚如小马哥说得那样很简单。css，全称Cascading Style Sheets (层叠样式表单)。层叠即意味这后面的css可以覆盖前面的css，级别高的css可以覆盖级别低的css。既然前面的可以被覆盖，浏览器在他完全加载完毕之后再去渲染无疑也是合情合理的很多浏览器下，如IE，把样式表放在页面的底部的问题在于它禁止了网页内容的顺序显示。浏览器阻止显示以免重画页面元素，那用户只能看到空白页了。Firefox不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需要重画，这导致闪烁问题。所以我们应该尽快让css加载完毕\n\n#### 1.6 将脚本移动到底部（包括内联的）\n\n+ 因为防止script脚本的执行阻塞页面的下载。在页面loading的过程中，当浏览器读到js执行语句的时候一定会把它全部解释完毕后在会接下来读下面的内容。不信你可以写一个js死循环看看页面下面的东西还会不会出来。（setTimeout 和 setInterval的执行有点类似于多线程，在相应的响应时间之前也会继续下面的内容渲染。）浏览器这么做的逻辑是因为js随时可能执行 location.href或是其他可能完全中断此页面过程的函数，即如此，当然得等他执行完毕之后再加载咯。所以放在页面最后，可以有效减少页面可视元素的加载时间。\n+ 脚本引起的第二个问题是它阻塞并行下载数量。HTTP/1.1规范建议浏览器每个主机的并行下载数不超过2个（IE只能为2个，其他浏览器如ff等都是默认设置为2个，不过新出的ie8可以达6个）。因此如果您把图像文件分布到多台机器的话，您可以达到超过2个的并行下载。但是当脚本文件下载时，浏览器不会启动其他的并行下载。\n\n#### 1.7 避免使用CSS中的expression\n\n“为了确保有效性，CSS 表达式会进行频繁的求值”，到底有多频繁？就是在你改变窗口大小，滚动页面甚至移动鼠标都会触发表达式进行求值，如此频繁的求值以至于浏览器的性能收到严重的影响；\n\n#### 1.8 将JavaScript和css独立成外部文件\n\n这点我想还是很容易理解的。不仅从性能优化上会这么做，用代码易于维护的角度看也应该这么做。把css和js写在页面内容可以减少2次请求，但也增 大了页面的大小。如果已经对css和js做了缓存，那也就没有2次多余的http请求了。当然，我在前面中也说过，有些特殊的页面开发人员还是会选择内联 的css和js文件。\n\n#### 1.9 减少DNS查询\n\n在 Internet上域名与IP地址之间是一一对应的，域名（kuqin.com）很好记，但计算机不认识，计算机之间的“相认”还要转成ip地址。在网络 上每台计算机都对应有一个独立的ip地址。在域名和ip地址之间的转换工作称为域名解析，也称DNS查询。一次DNS的解析过程会消耗20-120毫秒的 时间,在dns查询结束之前，浏览器不会下载该域名下的任何东西。所以减少dns查询的时间可以加快页面的加载速度。yahoo的建议一个页面所包含的域 名数尽量控制在2-4个。这就需要对页面整体有一个很好的规划。\n\n#### 1.10  压缩JavaScript和CSS\n\n压缩js和css的左右很显然，减少页面字节数。容量小页面加载速度自然也就快。而且压缩除了减少体积以外还可以起到一定的保护左右。\n#### 1.11 避免重定向\n\n每增加一次重定向就会增加一次web请求，所以因该尽量减少。\n\n+ 301 Moved Permanently\n\n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。\n\n+ 302 Found\n\n请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。\n\n#### 1.12 移除重复的脚本\n\n不仅是从性能上考虑，代码规范上看也是这样。\n\n#### 1.13 配置实体标签ETags(也是从缓存的角度而言的)\n\nHTTP协议规格说明定义ETag为“被请求变量的实体值”, 是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端。\n聪明的服务器开发者会把ETags和GET请求的“If-None-Match”头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。\n\n其过程如下：\n\n+ 客户端请求一个页面（A）。\n+ 服务器返回页面A，并在给A加上一个ETag。\n+ 客户端展现该页面，并将页面连同ETag一起缓存。\n+ 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。\n+ 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。\n\n#### 1.14 使用ajax缓存\n\najax还要去缓存？做ajax请求的时候往往还要增加一个时间戳去避免他缓存。记住“异步”不是“瞬间”这一点很重要。记住，即使AJAX是动态产生的而且只对一个用户起作用，他们依然可以被缓存。\n\n\n> 雅虎14条总结起来其实就是以下几个方面：记住5432\n\n + 优化请求次数和请求路径（5个）\n\n 减少http请求、合并js和css代码、使用CDN、避免重定向、减少DNS查询\n\n + 合理利用缓存，减少请求次数（4个）\n\n 使用Expires和cache-control、配置ETags、使用ajax缓存，将js和css独立出来\n\n + 代码层面（3个）\n\n 避免使用css表达式、将css放在页面头部、将js放在页面底部\n\n + 减少文件的体积（2个）\n\n 启用GZip、删除重复代码\n## 二、我们在工作中如何做优化\n\n对于已有的项目，我们可以利用chrome的network查看页面中资源的加载速度和哪些资源特别的消耗了性能；利用chrome插件pagespeed分析页面，它会针对页面给出详细的分析和推荐解决方案。\n总的来说，还是要遵循雅虎14条。\n\n#### 1.1 其他需要考虑的地方\n+ 关于图片的优化\n\n    推荐读下面的几篇文章\n\n+ 关于css的优化\n    + 合理的合并css文件\n    + 不要使用css的表达式：\n    + 将样式表放在头部、使用link代替import\n    + 避免使用filters\n\n+ 关于js的优化\n\n    + 避免使用with\n    + 减少dom的访问\n    + js放在页面底部\n\n+ 减少repaint和reflow\n\n+ 根据域名划分内容\n浏览器一般对**同一个域的下载连接数有所限制，按照域名划分下载内容可以浏览器增大并行下载连接，**但是注意控制域名使用在2-4个之间，不然dns查询也是个问题。一般网站规划会将静态资源放在类似于static.example.com，动态内容放在www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。后面我们会在cookie的规则中提到。\n\n+ 减少iframe数量\n\n    > 优点：\n\n        可以用来加载速度较慢的内容，例如广告。\n        安全沙箱保护。浏览器会对iframe中的内容进行安全控制。\n        脚本可以并行下载\n\n    > 缺点：\n\n        即使iframe内容为空也消耗加载时间\n        会阻止页面加载\n        没有语义\n\n## 三、推荐阅读\n\n+ [dns-prefetch 对性能提升有多大](http://blog.sina.com.cn/s/blog_bf9440220102wwgo.html)\n+ [前端性能优化----yahoo前端性能团队总结的35条黄金定律](前端性能优化----yahoo前端性能团队总结的35条黄金定律)\n+ [Web性能优化：图片优化](http://www.cnblogs.com/wizcabbit/p/web-image-optimization.html)\n+ [前端开发中，对图片的优化技巧有哪些？](https://www.zhihu.com/question/21815101)\n+ [WebP 探寻之路](http://isux.tencent.com/introduction-of-webp.html)\n+ [CSS Expression用法总结](http://www.cnblogs.com/rubylouvre/archive/2009/07/29/1534330.html)\n+ [javascript性能优化-repaint和reflow](http://www.cnblogs.com/jiajiaobj/archive/2012/06/11/2545291.html)\n+ [回流与重绘：CSS性能让JavaScript变慢？](http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/)\n+ [[Web 性能] repaint and reflow (重绘和回流)](http://blog.csdn.net/oscar999/article/details/38379523)\n+ [优化TTFB](http://blog.csdn.net/fumier/article/details/50511174)\n+ [网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)\n+ [减少页面回流与重绘（Reflow & Repaint）](http://harttle.com/2015/08/11/reflow-repaint.html)\n---\n做一个勤于思考的人\n","slug":"性能优化/前端性能优化--学习总结","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj3i002g9oxz17asaaxb","content":"<p>本文主要是自己在了解前端性能优化过程觉得比较好的文章的总结。</p>\n<h2 id=\"一、雅虎军规14条\"><a href=\"#一、雅虎军规14条\" class=\"headerlink\" title=\"一、雅虎军规14条\"></a>一、雅虎军规14条</h2><p>前端的性能优化已经是老生常谈的话题，面试和实际工作中都会遇到如何去做前端优化。在做优化之前，我们至少要熟知雅虎的14条军规：</p>\n<p><img src=\"/images/雅虎35.PNG\" alt=\"雅虎军规35条\"></p>\n<h4 id=\"1-1-尽可能的减少http请求\"><a href=\"#1-1-尽可能的减少http请求\" class=\"headerlink\" title=\"1.1 尽可能的减少http请求\"></a>1.1 尽可能的减少http请求</h4><p>网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。</p>\n<ul>\n<li>合并文件（js、css、雪碧图等),并使用css的background-image和background-position属性来实现所需部分的图片</li>\n<li><p>Inline images: 通过编码的字符串将图片内嵌到网页文本中。例如下面的inline image的显示效果为一个勾选的checkbox。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.sample-inline-png</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-left</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: white <span class=\"built_in\">url</span>(<span class=\"string\">'data:image/png;base64,iVBOR....'</span>) no-repeat scroll left top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>减少http请求次数是性能优化的起点！对提高首次访问效率起到很重要的作用。</p>\n</li>\n</ul>\n<h4 id=\"1-2-使用CDN\"><a href=\"#1-2-使用CDN\" class=\"headerlink\" title=\"1.2 使用CDN\"></a>1.2 使用CDN</h4><p>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，杭州的用户访问近杭州服务器上的内容，北京的访问 近北京服务器上的内容。这样可以有效减少数据在网络上传输的时间，提高速度。</p>\n<h4 id=\"1-3-添加Expires或者cache-control\"><a href=\"#1-3-添加Expires或者cache-control\" class=\"headerlink\" title=\"1.3 添加Expires或者cache-control\"></a>1.3 添加Expires或者cache-control</h4><p>合理使用浏览器缓存来减少http请求次数和大小，使得网页加速装载。</p>\n<h4 id=\"1-4-启用Gzip压缩\"><a href=\"#1-4-启用Gzip压缩\" class=\"headerlink\" title=\"1.4 启用Gzip压缩\"></a>1.4 启用Gzip压缩</h4><p>Gzip的思想就是把文件先在服务器端进行压缩，然后再传输。这样可以显著减少文件传输的大小。传输完毕后浏览器会 重新对压缩过的内容进行解压缩，并执行。目前的浏览器都能“良好”地支持 gzip。不仅浏览器可以识别，而且各大“爬虫”也同样可以识别，各位seoer可以放下心了。而且gzip的压缩比例非常大，一般压缩率为85%，就是 说服务器端100K的页面可以压缩到25K左右再发送到客户端。</p>\n<h4 id=\"1-5-将css放在页面的上方\"><a href=\"#1-5-将css放在页面的上方\" class=\"headerlink\" title=\"1.5 将css放在页面的上方\"></a>1.5 将css放在页面的上方</h4><p>将css放在页面最上面，这是为什么？因为 ie，firefox等浏览器在css全部传输完全之前不会去渲染任何的东西。理由诚如小马哥说得那样很简单。css，全称Cascading Style Sheets (层叠样式表单)。层叠即意味这后面的css可以覆盖前面的css，级别高的css可以覆盖级别低的css。既然前面的可以被覆盖，浏览器在他完全加载完毕之后再去渲染无疑也是合情合理的很多浏览器下，如IE，把样式表放在页面的底部的问题在于它禁止了网页内容的顺序显示。浏览器阻止显示以免重画页面元素，那用户只能看到空白页了。Firefox不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需要重画，这导致闪烁问题。所以我们应该尽快让css加载完毕</p>\n<h4 id=\"1-6-将脚本移动到底部（包括内联的）\"><a href=\"#1-6-将脚本移动到底部（包括内联的）\" class=\"headerlink\" title=\"1.6 将脚本移动到底部（包括内联的）\"></a>1.6 将脚本移动到底部（包括内联的）</h4><ul>\n<li>因为防止script脚本的执行阻塞页面的下载。在页面loading的过程中，当浏览器读到js执行语句的时候一定会把它全部解释完毕后在会接下来读下面的内容。不信你可以写一个js死循环看看页面下面的东西还会不会出来。（setTimeout 和 setInterval的执行有点类似于多线程，在相应的响应时间之前也会继续下面的内容渲染。）浏览器这么做的逻辑是因为js随时可能执行 location.href或是其他可能完全中断此页面过程的函数，即如此，当然得等他执行完毕之后再加载咯。所以放在页面最后，可以有效减少页面可视元素的加载时间。</li>\n<li>脚本引起的第二个问题是它阻塞并行下载数量。HTTP/1.1规范建议浏览器每个主机的并行下载数不超过2个（IE只能为2个，其他浏览器如ff等都是默认设置为2个，不过新出的ie8可以达6个）。因此如果您把图像文件分布到多台机器的话，您可以达到超过2个的并行下载。但是当脚本文件下载时，浏览器不会启动其他的并行下载。</li>\n</ul>\n<h4 id=\"1-7-避免使用CSS中的expression\"><a href=\"#1-7-避免使用CSS中的expression\" class=\"headerlink\" title=\"1.7 避免使用CSS中的expression\"></a>1.7 避免使用CSS中的expression</h4><p>“为了确保有效性，CSS 表达式会进行频繁的求值”，到底有多频繁？就是在你改变窗口大小，滚动页面甚至移动鼠标都会触发表达式进行求值，如此频繁的求值以至于浏览器的性能收到严重的影响；</p>\n<h4 id=\"1-8-将JavaScript和css独立成外部文件\"><a href=\"#1-8-将JavaScript和css独立成外部文件\" class=\"headerlink\" title=\"1.8 将JavaScript和css独立成外部文件\"></a>1.8 将JavaScript和css独立成外部文件</h4><p>这点我想还是很容易理解的。不仅从性能优化上会这么做，用代码易于维护的角度看也应该这么做。把css和js写在页面内容可以减少2次请求，但也增 大了页面的大小。如果已经对css和js做了缓存，那也就没有2次多余的http请求了。当然，我在前面中也说过，有些特殊的页面开发人员还是会选择内联 的css和js文件。</p>\n<h4 id=\"1-9-减少DNS查询\"><a href=\"#1-9-减少DNS查询\" class=\"headerlink\" title=\"1.9 减少DNS查询\"></a>1.9 减少DNS查询</h4><p>在 Internet上域名与IP地址之间是一一对应的，域名（kuqin.com）很好记，但计算机不认识，计算机之间的“相认”还要转成ip地址。在网络 上每台计算机都对应有一个独立的ip地址。在域名和ip地址之间的转换工作称为域名解析，也称DNS查询。一次DNS的解析过程会消耗20-120毫秒的 时间,在dns查询结束之前，浏览器不会下载该域名下的任何东西。所以减少dns查询的时间可以加快页面的加载速度。yahoo的建议一个页面所包含的域 名数尽量控制在2-4个。这就需要对页面整体有一个很好的规划。</p>\n<h4 id=\"1-10-压缩JavaScript和CSS\"><a href=\"#1-10-压缩JavaScript和CSS\" class=\"headerlink\" title=\"1.10  压缩JavaScript和CSS\"></a>1.10  压缩JavaScript和CSS</h4><p>压缩js和css的左右很显然，减少页面字节数。容量小页面加载速度自然也就快。而且压缩除了减少体积以外还可以起到一定的保护左右。</p>\n<h4 id=\"1-11-避免重定向\"><a href=\"#1-11-避免重定向\" class=\"headerlink\" title=\"1.11 避免重定向\"></a>1.11 避免重定向</h4><p>每增加一次重定向就会增加一次web请求，所以因该尽量减少。</p>\n<ul>\n<li>301 Moved Permanently</li>\n</ul>\n<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</p>\n<ul>\n<li>302 Found</li>\n</ul>\n<p>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>\n<h4 id=\"1-12-移除重复的脚本\"><a href=\"#1-12-移除重复的脚本\" class=\"headerlink\" title=\"1.12 移除重复的脚本\"></a>1.12 移除重复的脚本</h4><p>不仅是从性能上考虑，代码规范上看也是这样。</p>\n<h4 id=\"1-13-配置实体标签ETags-也是从缓存的角度而言的\"><a href=\"#1-13-配置实体标签ETags-也是从缓存的角度而言的\" class=\"headerlink\" title=\"1.13 配置实体标签ETags(也是从缓存的角度而言的)\"></a>1.13 配置实体标签ETags(也是从缓存的角度而言的)</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体值”, 是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端。<br>聪明的服务器开发者会把ETags和GET请求的“If-None-Match”头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>\n<p>其过程如下：</p>\n<ul>\n<li>客户端请求一个页面（A）。</li>\n<li>服务器返回页面A，并在给A加上一个ETag。</li>\n<li>客户端展现该页面，并将页面连同ETag一起缓存。</li>\n<li>客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。</li>\n<li>服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。</li>\n</ul>\n<h4 id=\"1-14-使用ajax缓存\"><a href=\"#1-14-使用ajax缓存\" class=\"headerlink\" title=\"1.14 使用ajax缓存\"></a>1.14 使用ajax缓存</h4><p>ajax还要去缓存？做ajax请求的时候往往还要增加一个时间戳去避免他缓存。记住“异步”不是“瞬间”这一点很重要。记住，即使AJAX是动态产生的而且只对一个用户起作用，他们依然可以被缓存。</p>\n<blockquote>\n<p>雅虎14条总结起来其实就是以下几个方面：记住5432</p>\n</blockquote>\n<ul>\n<li><p>优化请求次数和请求路径（5个）</p>\n<p>减少http请求、合并js和css代码、使用CDN、避免重定向、减少DNS查询</p>\n</li>\n<li><p>合理利用缓存，减少请求次数（4个）</p>\n<p>使用Expires和cache-control、配置ETags、使用ajax缓存，将js和css独立出来</p>\n</li>\n<li><p>代码层面（3个）</p>\n<p>避免使用css表达式、将css放在页面头部、将js放在页面底部</p>\n</li>\n<li><p>减少文件的体积（2个）</p>\n<p>启用GZip、删除重复代码</p>\n<h2 id=\"二、我们在工作中如何做优化\"><a href=\"#二、我们在工作中如何做优化\" class=\"headerlink\" title=\"二、我们在工作中如何做优化\"></a>二、我们在工作中如何做优化</h2></li>\n</ul>\n<p>对于已有的项目，我们可以利用chrome的network查看页面中资源的加载速度和哪些资源特别的消耗了性能；利用chrome插件pagespeed分析页面，它会针对页面给出详细的分析和推荐解决方案。<br>总的来说，还是要遵循雅虎14条。</p>\n<h4 id=\"1-1-其他需要考虑的地方\"><a href=\"#1-1-其他需要考虑的地方\" class=\"headerlink\" title=\"1.1 其他需要考虑的地方\"></a>1.1 其他需要考虑的地方</h4><ul>\n<li><p>关于图片的优化</p>\n<p>  推荐读下面的几篇文章</p>\n</li>\n<li><p>关于css的优化</p>\n<ul>\n<li>合理的合并css文件</li>\n<li>不要使用css的表达式：</li>\n<li>将样式表放在头部、使用link代替import</li>\n<li>避免使用filters</li>\n</ul>\n</li>\n<li><p>关于js的优化</p>\n<ul>\n<li>避免使用with</li>\n<li>减少dom的访问</li>\n<li>js放在页面底部</li>\n</ul>\n</li>\n<li><p>减少repaint和reflow</p>\n</li>\n<li><p>根据域名划分内容<br>浏览器一般对<strong>同一个域的下载连接数有所限制，按照域名划分下载内容可以浏览器增大并行下载连接，</strong>但是注意控制域名使用在2-4个之间，不然dns查询也是个问题。一般网站规划会将静态资源放在类似于static.example.com，动态内容放在<a href=\"http://www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。后面我们会在cookie的规则中提到。\" target=\"_blank\" rel=\"noopener\">www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。后面我们会在cookie的规则中提到。</a></p>\n</li>\n<li><p>减少iframe数量</p>\n<blockquote>\n<p>优点：</p>\n</blockquote>\n<pre><code>可以用来加载速度较慢的内容，例如广告。\n安全沙箱保护。浏览器会对iframe中的内容进行安全控制。\n脚本可以并行下载\n</code></pre><blockquote>\n<p>缺点：</p>\n</blockquote>\n<pre><code>即使iframe内容为空也消耗加载时间\n会阻止页面加载\n没有语义\n</code></pre></li>\n</ul>\n<h2 id=\"三、推荐阅读\"><a href=\"#三、推荐阅读\" class=\"headerlink\" title=\"三、推荐阅读\"></a>三、推荐阅读</h2><ul>\n<li><a href=\"http://blog.sina.com.cn/s/blog_bf9440220102wwgo.html\" target=\"_blank\" rel=\"noopener\">dns-prefetch 对性能提升有多大</a></li>\n<li><a href=\"前端性能优化----yahoo前端性能团队总结的35条黄金定律\">前端性能优化—-yahoo前端性能团队总结的35条黄金定律</a></li>\n<li><a href=\"http://www.cnblogs.com/wizcabbit/p/web-image-optimization.html\" target=\"_blank\" rel=\"noopener\">Web性能优化：图片优化</a></li>\n<li><a href=\"https://www.zhihu.com/question/21815101\" target=\"_blank\" rel=\"noopener\">前端开发中，对图片的优化技巧有哪些？</a></li>\n<li><a href=\"http://isux.tencent.com/introduction-of-webp.html\" target=\"_blank\" rel=\"noopener\">WebP 探寻之路</a></li>\n<li><a href=\"http://www.cnblogs.com/rubylouvre/archive/2009/07/29/1534330.html\" target=\"_blank\" rel=\"noopener\">CSS Expression用法总结</a></li>\n<li><a href=\"http://www.cnblogs.com/jiajiaobj/archive/2012/06/11/2545291.html\" target=\"_blank\" rel=\"noopener\">javascript性能优化-repaint和reflow</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/\" target=\"_blank\" rel=\"noopener\">回流与重绘：CSS性能让JavaScript变慢？</a></li>\n<li><a href=\"http://blog.csdn.net/oscar999/article/details/38379523\" target=\"_blank\" rel=\"noopener\">[Web 性能] repaint and reflow (重绘和回流)</a></li>\n<li><a href=\"http://blog.csdn.net/fumier/article/details/50511174\" target=\"_blank\" rel=\"noopener\">优化TTFB</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\" target=\"_blank\" rel=\"noopener\">网页性能管理详解</a></li>\n<li><a href=\"http://harttle.com/2015/08/11/reflow-repaint.html\" target=\"_blank\" rel=\"noopener\">减少页面回流与重绘（Reflow &amp; Repaint）</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文主要是自己在了解前端性能优化过程觉得比较好的文章的总结。</p>\n<h2 id=\"一、雅虎军规14条\"><a href=\"#一、雅虎军规14条\" class=\"headerlink\" title=\"一、雅虎军规14条\"></a>一、雅虎军规14条</h2><p>前端的性能优化已经是老生常谈的话题，面试和实际工作中都会遇到如何去做前端优化。在做优化之前，我们至少要熟知雅虎的14条军规：</p>\n<p><img src=\"/images/雅虎35.PNG\" alt=\"雅虎军规35条\"></p>\n<h4 id=\"1-1-尽可能的减少http请求\"><a href=\"#1-1-尽可能的减少http请求\" class=\"headerlink\" title=\"1.1 尽可能的减少http请求\"></a>1.1 尽可能的减少http请求</h4><p>网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。</p>\n<ul>\n<li>合并文件（js、css、雪碧图等),并使用css的background-image和background-position属性来实现所需部分的图片</li>\n<li><p>Inline images: 通过编码的字符串将图片内嵌到网页文本中。例如下面的inline image的显示效果为一个勾选的checkbox。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.sample-inline-png</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-left</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: white <span class=\"built_in\">url</span>(<span class=\"string\">'data:image/png;base64,iVBOR....'</span>) no-repeat scroll left top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>减少http请求次数是性能优化的起点！对提高首次访问效率起到很重要的作用。</p>\n</li>\n</ul>\n<h4 id=\"1-2-使用CDN\"><a href=\"#1-2-使用CDN\" class=\"headerlink\" title=\"1.2 使用CDN\"></a>1.2 使用CDN</h4><p>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，杭州的用户访问近杭州服务器上的内容，北京的访问 近北京服务器上的内容。这样可以有效减少数据在网络上传输的时间，提高速度。</p>\n<h4 id=\"1-3-添加Expires或者cache-control\"><a href=\"#1-3-添加Expires或者cache-control\" class=\"headerlink\" title=\"1.3 添加Expires或者cache-control\"></a>1.3 添加Expires或者cache-control</h4><p>合理使用浏览器缓存来减少http请求次数和大小，使得网页加速装载。</p>\n<h4 id=\"1-4-启用Gzip压缩\"><a href=\"#1-4-启用Gzip压缩\" class=\"headerlink\" title=\"1.4 启用Gzip压缩\"></a>1.4 启用Gzip压缩</h4><p>Gzip的思想就是把文件先在服务器端进行压缩，然后再传输。这样可以显著减少文件传输的大小。传输完毕后浏览器会 重新对压缩过的内容进行解压缩，并执行。目前的浏览器都能“良好”地支持 gzip。不仅浏览器可以识别，而且各大“爬虫”也同样可以识别，各位seoer可以放下心了。而且gzip的压缩比例非常大，一般压缩率为85%，就是 说服务器端100K的页面可以压缩到25K左右再发送到客户端。</p>\n<h4 id=\"1-5-将css放在页面的上方\"><a href=\"#1-5-将css放在页面的上方\" class=\"headerlink\" title=\"1.5 将css放在页面的上方\"></a>1.5 将css放在页面的上方</h4><p>将css放在页面最上面，这是为什么？因为 ie，firefox等浏览器在css全部传输完全之前不会去渲染任何的东西。理由诚如小马哥说得那样很简单。css，全称Cascading Style Sheets (层叠样式表单)。层叠即意味这后面的css可以覆盖前面的css，级别高的css可以覆盖级别低的css。既然前面的可以被覆盖，浏览器在他完全加载完毕之后再去渲染无疑也是合情合理的很多浏览器下，如IE，把样式表放在页面的底部的问题在于它禁止了网页内容的顺序显示。浏览器阻止显示以免重画页面元素，那用户只能看到空白页了。Firefox不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需要重画，这导致闪烁问题。所以我们应该尽快让css加载完毕</p>\n<h4 id=\"1-6-将脚本移动到底部（包括内联的）\"><a href=\"#1-6-将脚本移动到底部（包括内联的）\" class=\"headerlink\" title=\"1.6 将脚本移动到底部（包括内联的）\"></a>1.6 将脚本移动到底部（包括内联的）</h4><ul>\n<li>因为防止script脚本的执行阻塞页面的下载。在页面loading的过程中，当浏览器读到js执行语句的时候一定会把它全部解释完毕后在会接下来读下面的内容。不信你可以写一个js死循环看看页面下面的东西还会不会出来。（setTimeout 和 setInterval的执行有点类似于多线程，在相应的响应时间之前也会继续下面的内容渲染。）浏览器这么做的逻辑是因为js随时可能执行 location.href或是其他可能完全中断此页面过程的函数，即如此，当然得等他执行完毕之后再加载咯。所以放在页面最后，可以有效减少页面可视元素的加载时间。</li>\n<li>脚本引起的第二个问题是它阻塞并行下载数量。HTTP/1.1规范建议浏览器每个主机的并行下载数不超过2个（IE只能为2个，其他浏览器如ff等都是默认设置为2个，不过新出的ie8可以达6个）。因此如果您把图像文件分布到多台机器的话，您可以达到超过2个的并行下载。但是当脚本文件下载时，浏览器不会启动其他的并行下载。</li>\n</ul>\n<h4 id=\"1-7-避免使用CSS中的expression\"><a href=\"#1-7-避免使用CSS中的expression\" class=\"headerlink\" title=\"1.7 避免使用CSS中的expression\"></a>1.7 避免使用CSS中的expression</h4><p>“为了确保有效性，CSS 表达式会进行频繁的求值”，到底有多频繁？就是在你改变窗口大小，滚动页面甚至移动鼠标都会触发表达式进行求值，如此频繁的求值以至于浏览器的性能收到严重的影响；</p>\n<h4 id=\"1-8-将JavaScript和css独立成外部文件\"><a href=\"#1-8-将JavaScript和css独立成外部文件\" class=\"headerlink\" title=\"1.8 将JavaScript和css独立成外部文件\"></a>1.8 将JavaScript和css独立成外部文件</h4><p>这点我想还是很容易理解的。不仅从性能优化上会这么做，用代码易于维护的角度看也应该这么做。把css和js写在页面内容可以减少2次请求，但也增 大了页面的大小。如果已经对css和js做了缓存，那也就没有2次多余的http请求了。当然，我在前面中也说过，有些特殊的页面开发人员还是会选择内联 的css和js文件。</p>\n<h4 id=\"1-9-减少DNS查询\"><a href=\"#1-9-减少DNS查询\" class=\"headerlink\" title=\"1.9 减少DNS查询\"></a>1.9 减少DNS查询</h4><p>在 Internet上域名与IP地址之间是一一对应的，域名（kuqin.com）很好记，但计算机不认识，计算机之间的“相认”还要转成ip地址。在网络 上每台计算机都对应有一个独立的ip地址。在域名和ip地址之间的转换工作称为域名解析，也称DNS查询。一次DNS的解析过程会消耗20-120毫秒的 时间,在dns查询结束之前，浏览器不会下载该域名下的任何东西。所以减少dns查询的时间可以加快页面的加载速度。yahoo的建议一个页面所包含的域 名数尽量控制在2-4个。这就需要对页面整体有一个很好的规划。</p>\n<h4 id=\"1-10-压缩JavaScript和CSS\"><a href=\"#1-10-压缩JavaScript和CSS\" class=\"headerlink\" title=\"1.10  压缩JavaScript和CSS\"></a>1.10  压缩JavaScript和CSS</h4><p>压缩js和css的左右很显然，减少页面字节数。容量小页面加载速度自然也就快。而且压缩除了减少体积以外还可以起到一定的保护左右。</p>\n<h4 id=\"1-11-避免重定向\"><a href=\"#1-11-避免重定向\" class=\"headerlink\" title=\"1.11 避免重定向\"></a>1.11 避免重定向</h4><p>每增加一次重定向就会增加一次web请求，所以因该尽量减少。</p>\n<ul>\n<li>301 Moved Permanently</li>\n</ul>\n<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</p>\n<ul>\n<li>302 Found</li>\n</ul>\n<p>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>\n<h4 id=\"1-12-移除重复的脚本\"><a href=\"#1-12-移除重复的脚本\" class=\"headerlink\" title=\"1.12 移除重复的脚本\"></a>1.12 移除重复的脚本</h4><p>不仅是从性能上考虑，代码规范上看也是这样。</p>\n<h4 id=\"1-13-配置实体标签ETags-也是从缓存的角度而言的\"><a href=\"#1-13-配置实体标签ETags-也是从缓存的角度而言的\" class=\"headerlink\" title=\"1.13 配置实体标签ETags(也是从缓存的角度而言的)\"></a>1.13 配置实体标签ETags(也是从缓存的角度而言的)</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体值”, 是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端。<br>聪明的服务器开发者会把ETags和GET请求的“If-None-Match”头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>\n<p>其过程如下：</p>\n<ul>\n<li>客户端请求一个页面（A）。</li>\n<li>服务器返回页面A，并在给A加上一个ETag。</li>\n<li>客户端展现该页面，并将页面连同ETag一起缓存。</li>\n<li>客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。</li>\n<li>服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。</li>\n</ul>\n<h4 id=\"1-14-使用ajax缓存\"><a href=\"#1-14-使用ajax缓存\" class=\"headerlink\" title=\"1.14 使用ajax缓存\"></a>1.14 使用ajax缓存</h4><p>ajax还要去缓存？做ajax请求的时候往往还要增加一个时间戳去避免他缓存。记住“异步”不是“瞬间”这一点很重要。记住，即使AJAX是动态产生的而且只对一个用户起作用，他们依然可以被缓存。</p>\n<blockquote>\n<p>雅虎14条总结起来其实就是以下几个方面：记住5432</p>\n</blockquote>\n<ul>\n<li><p>优化请求次数和请求路径（5个）</p>\n<p>减少http请求、合并js和css代码、使用CDN、避免重定向、减少DNS查询</p>\n</li>\n<li><p>合理利用缓存，减少请求次数（4个）</p>\n<p>使用Expires和cache-control、配置ETags、使用ajax缓存，将js和css独立出来</p>\n</li>\n<li><p>代码层面（3个）</p>\n<p>避免使用css表达式、将css放在页面头部、将js放在页面底部</p>\n</li>\n<li><p>减少文件的体积（2个）</p>\n<p>启用GZip、删除重复代码</p>\n<h2 id=\"二、我们在工作中如何做优化\"><a href=\"#二、我们在工作中如何做优化\" class=\"headerlink\" title=\"二、我们在工作中如何做优化\"></a>二、我们在工作中如何做优化</h2></li>\n</ul>\n<p>对于已有的项目，我们可以利用chrome的network查看页面中资源的加载速度和哪些资源特别的消耗了性能；利用chrome插件pagespeed分析页面，它会针对页面给出详细的分析和推荐解决方案。<br>总的来说，还是要遵循雅虎14条。</p>\n<h4 id=\"1-1-其他需要考虑的地方\"><a href=\"#1-1-其他需要考虑的地方\" class=\"headerlink\" title=\"1.1 其他需要考虑的地方\"></a>1.1 其他需要考虑的地方</h4><ul>\n<li><p>关于图片的优化</p>\n<p>  推荐读下面的几篇文章</p>\n</li>\n<li><p>关于css的优化</p>\n<ul>\n<li>合理的合并css文件</li>\n<li>不要使用css的表达式：</li>\n<li>将样式表放在头部、使用link代替import</li>\n<li>避免使用filters</li>\n</ul>\n</li>\n<li><p>关于js的优化</p>\n<ul>\n<li>避免使用with</li>\n<li>减少dom的访问</li>\n<li>js放在页面底部</li>\n</ul>\n</li>\n<li><p>减少repaint和reflow</p>\n</li>\n<li><p>根据域名划分内容<br>浏览器一般对<strong>同一个域的下载连接数有所限制，按照域名划分下载内容可以浏览器增大并行下载连接，</strong>但是注意控制域名使用在2-4个之间，不然dns查询也是个问题。一般网站规划会将静态资源放在类似于static.example.com，动态内容放在<a href=\"http://www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。后面我们会在cookie的规则中提到。\" target=\"_blank\" rel=\"noopener\">www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。后面我们会在cookie的规则中提到。</a></p>\n</li>\n<li><p>减少iframe数量</p>\n<blockquote>\n<p>优点：</p>\n</blockquote>\n<pre><code>可以用来加载速度较慢的内容，例如广告。\n安全沙箱保护。浏览器会对iframe中的内容进行安全控制。\n脚本可以并行下载\n</code></pre><blockquote>\n<p>缺点：</p>\n</blockquote>\n<pre><code>即使iframe内容为空也消耗加载时间\n会阻止页面加载\n没有语义\n</code></pre></li>\n</ul>\n<h2 id=\"三、推荐阅读\"><a href=\"#三、推荐阅读\" class=\"headerlink\" title=\"三、推荐阅读\"></a>三、推荐阅读</h2><ul>\n<li><a href=\"http://blog.sina.com.cn/s/blog_bf9440220102wwgo.html\" target=\"_blank\" rel=\"noopener\">dns-prefetch 对性能提升有多大</a></li>\n<li><a href=\"前端性能优化----yahoo前端性能团队总结的35条黄金定律\">前端性能优化—-yahoo前端性能团队总结的35条黄金定律</a></li>\n<li><a href=\"http://www.cnblogs.com/wizcabbit/p/web-image-optimization.html\" target=\"_blank\" rel=\"noopener\">Web性能优化：图片优化</a></li>\n<li><a href=\"https://www.zhihu.com/question/21815101\" target=\"_blank\" rel=\"noopener\">前端开发中，对图片的优化技巧有哪些？</a></li>\n<li><a href=\"http://isux.tencent.com/introduction-of-webp.html\" target=\"_blank\" rel=\"noopener\">WebP 探寻之路</a></li>\n<li><a href=\"http://www.cnblogs.com/rubylouvre/archive/2009/07/29/1534330.html\" target=\"_blank\" rel=\"noopener\">CSS Expression用法总结</a></li>\n<li><a href=\"http://www.cnblogs.com/jiajiaobj/archive/2012/06/11/2545291.html\" target=\"_blank\" rel=\"noopener\">javascript性能优化-repaint和reflow</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/\" target=\"_blank\" rel=\"noopener\">回流与重绘：CSS性能让JavaScript变慢？</a></li>\n<li><a href=\"http://blog.csdn.net/oscar999/article/details/38379523\" target=\"_blank\" rel=\"noopener\">[Web 性能] repaint and reflow (重绘和回流)</a></li>\n<li><a href=\"http://blog.csdn.net/fumier/article/details/50511174\" target=\"_blank\" rel=\"noopener\">优化TTFB</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\" target=\"_blank\" rel=\"noopener\">网页性能管理详解</a></li>\n<li><a href=\"http://harttle.com/2015/08/11/reflow-repaint.html\" target=\"_blank\" rel=\"noopener\">减少页面回流与重绘（Reflow &amp; Repaint）</a></li>\n</ul>\n<hr>\n<p>做一个勤于思考的人</p>\n"},{"title":"HTTP学习总结","date":"2017-02-21T16:00:00.000Z","_content":"\n前端工程师在面试过程中不可避免的会被问到是否知道http，讲真，似乎我们没有细究过http也好好的开发了很长一段时间。那为何越是大公司越会很注重你是否了解http呢。\n站在我们前端开发人员的角度，前后端通信几乎都是基于HTTP的，我们发送http请求，由RD接受请求处理后返回我们需要的资源。我们更深入的了解http到底是为了什么：\n+ `更好的定位问题：`我们发送一个请求之后，可以根据请求返回的状态码定位这次请求是否成功，如果没有成功是谁的问题\n+ `让前后端通信更快更安全：`在更深入的了解http请求后，我们就知道http通信的瓶颈在哪，有哪些行为会导致此次通信不安全、如何做可以让通信更快\n+ `用更好的方式去沟通：`不同的业务场景选用不同的方法沟通不仅仅提高可读性，也可以提高安全性、服务器处理的效率\n+ `应付面试：`很重要\n其实主要内容我还是从《HTTP权威指南》上抄的~\n\n## 1. 简介\nhttp说的通俗一点，相当于客户端和服务器端的沟通语言。那么http协议简单来说包括哪些内容呢：\n1. 如何沟通：http报文，告诉客户端如何提出要求，服务器端应该怎样分析客户端的请求并给出响应的反应\n1. 沟通的高效性：http缓存、长连接等\n1. 沟通的安全性：https、客户端识别、cookie机制\n站在前端的角度来讲，我们常用的客户端是浏览器，服务器端可以是任何提供服务一个机器（废话）。\n\n## 2. 如何沟通--http报文结构\n这个部分主要讲解客户端和服务器端应该遵循什么样的规范来沟通。他们都得遵循http报文规范。\n+ http报文是什么：简单的格式化数据块\n+ http报文包含3个部分\n\t+ 起始行：对报文进行描述\n\t+ 首部：包含一些属性\n\t+ 主体（可以没有）：包含数据主体\n##### 2.1 请求报文格式\n\t  method request-url version\n\t  headers\n\t  \n\t  entity-body\n\t  \n##### 2.2 响应报文格式\n    version status reason-phrase\n    headers\n    \n    entity-body\n    \n## 3. method请求的方法\nHTTP规范总共定义了**7个**请求方法，为了告诉客户端，客户端想要执行什么动作。但不是每个服务器都实现了以下的方法。**HTTP1.1协议要求实现GET和HEAD方法**\n1. GET:从服务器端获取资源，没有实体\nHTTP1.1要求实现GET方法\n2. HEAD：从服务器获取资源的首部，没有实体\n与GET方法很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。HTTP1.1要求实现GET方法。HEAD方法可以用来：\t\t\n    + 在不获取资源的情况下，知道资源的情况（资源的类型）\n    + 通过查看资源的状态码，了解资源的存在情况\n    + 通过查看首部，看资源是否被修改了\t\t\n3. POST：向服务器发送需要处理的数据，**有实体**\n\t\t\t\n4. PUT:将请求的主体部分放在服务器上，**有实体**\nPUT请求让服务器用PUT请求带的主体部分来创建一个由它所请求的url命名的新文档，如果文档已经存在，则覆盖它。PUT请求容许用户修改服务器的内容，所以从安全性角度来讲，应该要用户登录。\t\t\n5. TRACE：对可能经过的代理服务器传送到服务器上去的报文进行追踪，没有实体\n客户端发一个请求到达服务器时，可能会经过很多的代理服务器、防护墙、网关等等，中间每一个环节都有可能改变原来的HTTP请求。TRACE方法，容许客户端在最终发送请求到服务器端时，看看它变成了什么样子。最后一站的服务器会返回一个相关的响应，并在主体中携带上原始的请求报文。\t\t\n    + 优点：可以用于查看代理和其他的应用程序对用户请求的影响\n    + 缺点：它假定了中间程序对不同方法的请求处理方式是一致的。说到底我们还是不能保证中间代理和网关等对用户请求处理方式是一致的\n6. OPTIONS：决定（\"决定二字\"如何来理解？）可以在服务器上执行哪些方式，没有实体\nOPTIONS方式是希望服务器告诉我们，我们可以使用哪些方法，或者说对特殊资源支持哪些方法。\t\t\t\n7. DELETE：从服务器上删除一份文档，没有实体\n请求服务器端删除一个资源，但是不能保证这个请求一定会被执行，因为HTTP的规范容许服务器在不通知客户端的情况下撤销请求。\t\t\n8. 扩展方法\nHTTP被设计成字段可拓展的，这样可以向下兼容。但是我并不想看这块。\n\n## 4. 请求的URL简单介绍\nURL提供了统一的资源命名方式：方案：//服务器位置//路径。URL的语法会由于方案的不同而不同,几乎没有哪个URL中包含了所以所有的组件：scheme://user:pwd@host:port/path;params?query#frag\n1. params参数\n一个URL中可以有多个参数，参数为键值对，各个参数之间以及参数与URL其他部分之间用逗号分隔\t\t\n1. query\n查询组件的内容没有通用的格式，用字符“？”将其与URL的其余部分分隔开\n\n##### 4.1 方案：例如HTTP/FTP/SMTP\n方案名不区分大小写,告诉应用程序应该使用什么协议\t\t\n## 5. 版本\n格式类似于HTTP/1.1,HTTP/2.0,是为了服务器和客户端之间相互了解各自的能力和报文的格式。版本号说明了应用程序支持的最高的HTTP版本。版本号不会被当做小数来处理，所以HTTP2.22比HTTP2.3的版本要高，因为22>3\n## 6. 状态码\n状态码配合原因短语一起告诉客户端他的请求处于什么状态,目前有5个种类的状态码\n+ 100~199:信息类状态码(目前实现了2个)\n+ 200~299:成功类状态码(目前实现了7个)\n+ 300~399:重定向类状态码(目前实现了7个)\n+ 400~499:客户端失败状态码(目前实现了18个)\n+ 500~599:服务器端状态码(目前实现了6个)\n\n##### 6.1 信息类状态码\n这类型状态码是http1.1引入的,都比较新也比较受争议,所以目前只实现了2个:\n1. 100 Continue\n说明服务器端已经收到部分请求,请求客户端继续。那么为什么我们需要这个状态码: http客户端应用程序要发给服务器一个实体的主体,但是在发送前想知道服务器端是否接受服务器端只有接受到带有值为100 continue的expires请求头时才会返回100状态码,\n1. 101 switching protocols\n说明服务器根据客户端的请示,将协议切换成update首部所列的协议\n\n##### 6.2 成功类状态码\n目前已经实现了7个(200~206)\n1. 200 OK\n请求没有问题,响应的实体主体部分包含请求的资源\n1. 201 created\n主要用来创建服务器端请求(PUT)\n服务器在返回改状态码前必须已经创建好对象\n响应的主体部分应该包含各组引用了已创建的资源的URL\n1. 202 Accept\n请求已经被接受,但是服务器还未对该请求做任何处理也不能保证服务器能完成这个请求\n返回的实体主体部分包含对该请求的状态描述,或者也可以加上对请求完成时间的估计\n1. 203 None-Authoritative Information\n实体的信息不是来自于服务器端,而是来自于资源的一个副本\n如中间节点上有一份资源副本,但无法或者对发送资源进行验证就可以发送这个状态码\n1. 204 No content\n响应中包含起始行和首部,但是每天实体的主体部分\n主要用于浏览器不转为显示新文档的情况下对其进行更新\n1. 205 Reset content\n也是主要用于浏览器\n用于告知浏览器清空所以得HTML元素\n1. 206 partial content \n成功的执行了一个range请求\n206响应必须包含以下几个响应\n+ Content-range\n+ Date\n+ ETag\n+ Content-Location\n\n##### 6.3 重定向类状态码(目前实现了7个)\n1. 300 Multiple Choice\n请求的url对应多个资源(中文、英文等)会返回该状态码\n服务器可以在响应的location首部给出首选的URL\n1. 301 Moved permanently\n表示请求的资源已经转移\n响应的location头部应该包含资源的新URL\n1. 302 Found\n与301类似,客户端使用响应的location首部来临时定位资源\n以后还是会使用来的URL定位资源\n1. 303 See Other\n告知客户端使用另一个URL来访问资源\n新的URL位于响应的location首部\n主要目的是容许post请求将客户端定位到某个资源上\n讲真,我已经晕了\n1. 304 Not Found\n这个我倒是经常遇到,传说中的条件缓存\n客户端的条件get请求,资源未被修改\n响应的实体不包含主体部分\n1. 305 use proxy\n必须通过代理来访问资源,代理的位置在响应的location首部\n1. 306 未使用\n1. 307 Temporary Redirect\n临时的重定向,类似于301,但响应中给出的是临时的url\n以后还是使用老的url来访问资源\n\n##### 6.4 服务器端错误状态码\n目前实现了6个\n1. 500 Internal server error\n遇到妨碍服务器提供服务的内部错误时返回\n1. 501 Not implemented\n客户端发起的请求超出了服务器的能力范围,例如使用了服务器不支持的方法\n1. 502 bad gateway\n代理在请求的响应链的下一条链时返回一个伪响应(如无法连接父代理)\n测试过程中,测试服务器挂了会报这个错误类型\n1. 503 service unavailable\n表示服务器现在没办法为请求提供服务,但是未来可以\n如果服务器知道什么时候能够用,可以在响应中返回一个包含retry-after首部\n1. 504 gateway timeout \n类似于408,这里的响应来自于网关或者代理\n在等服务器等待请求进行响应时超时了\n1. 505 http version not support\n\n\n\n## 7. 学习时间线\n\n##### 2017-02-27\n\n+ http简介\n+ http报文结构\n+ url\n+ 请求的方法\n\n##### 2017-03-01\n\n+ 状态码 (信息类状态码、成功类状态码、重定向类状态码、服务器端错误状态码)\n\n\n-----\n\n做一个勤于思考的人~\n\n\n","source":"_posts/网络/HTTP简介.md","raw":"---\ntitle: HTTP学习总结\ndate: 2017-02-22\ntags:\n  - 前端开发\n  - HTTP学习总结\ncategories: 网络\n---\n\n前端工程师在面试过程中不可避免的会被问到是否知道http，讲真，似乎我们没有细究过http也好好的开发了很长一段时间。那为何越是大公司越会很注重你是否了解http呢。\n站在我们前端开发人员的角度，前后端通信几乎都是基于HTTP的，我们发送http请求，由RD接受请求处理后返回我们需要的资源。我们更深入的了解http到底是为了什么：\n+ `更好的定位问题：`我们发送一个请求之后，可以根据请求返回的状态码定位这次请求是否成功，如果没有成功是谁的问题\n+ `让前后端通信更快更安全：`在更深入的了解http请求后，我们就知道http通信的瓶颈在哪，有哪些行为会导致此次通信不安全、如何做可以让通信更快\n+ `用更好的方式去沟通：`不同的业务场景选用不同的方法沟通不仅仅提高可读性，也可以提高安全性、服务器处理的效率\n+ `应付面试：`很重要\n其实主要内容我还是从《HTTP权威指南》上抄的~\n\n## 1. 简介\nhttp说的通俗一点，相当于客户端和服务器端的沟通语言。那么http协议简单来说包括哪些内容呢：\n1. 如何沟通：http报文，告诉客户端如何提出要求，服务器端应该怎样分析客户端的请求并给出响应的反应\n1. 沟通的高效性：http缓存、长连接等\n1. 沟通的安全性：https、客户端识别、cookie机制\n站在前端的角度来讲，我们常用的客户端是浏览器，服务器端可以是任何提供服务一个机器（废话）。\n\n## 2. 如何沟通--http报文结构\n这个部分主要讲解客户端和服务器端应该遵循什么样的规范来沟通。他们都得遵循http报文规范。\n+ http报文是什么：简单的格式化数据块\n+ http报文包含3个部分\n\t+ 起始行：对报文进行描述\n\t+ 首部：包含一些属性\n\t+ 主体（可以没有）：包含数据主体\n##### 2.1 请求报文格式\n\t  method request-url version\n\t  headers\n\t  \n\t  entity-body\n\t  \n##### 2.2 响应报文格式\n    version status reason-phrase\n    headers\n    \n    entity-body\n    \n## 3. method请求的方法\nHTTP规范总共定义了**7个**请求方法，为了告诉客户端，客户端想要执行什么动作。但不是每个服务器都实现了以下的方法。**HTTP1.1协议要求实现GET和HEAD方法**\n1. GET:从服务器端获取资源，没有实体\nHTTP1.1要求实现GET方法\n2. HEAD：从服务器获取资源的首部，没有实体\n与GET方法很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。HTTP1.1要求实现GET方法。HEAD方法可以用来：\t\t\n    + 在不获取资源的情况下，知道资源的情况（资源的类型）\n    + 通过查看资源的状态码，了解资源的存在情况\n    + 通过查看首部，看资源是否被修改了\t\t\n3. POST：向服务器发送需要处理的数据，**有实体**\n\t\t\t\n4. PUT:将请求的主体部分放在服务器上，**有实体**\nPUT请求让服务器用PUT请求带的主体部分来创建一个由它所请求的url命名的新文档，如果文档已经存在，则覆盖它。PUT请求容许用户修改服务器的内容，所以从安全性角度来讲，应该要用户登录。\t\t\n5. TRACE：对可能经过的代理服务器传送到服务器上去的报文进行追踪，没有实体\n客户端发一个请求到达服务器时，可能会经过很多的代理服务器、防护墙、网关等等，中间每一个环节都有可能改变原来的HTTP请求。TRACE方法，容许客户端在最终发送请求到服务器端时，看看它变成了什么样子。最后一站的服务器会返回一个相关的响应，并在主体中携带上原始的请求报文。\t\t\n    + 优点：可以用于查看代理和其他的应用程序对用户请求的影响\n    + 缺点：它假定了中间程序对不同方法的请求处理方式是一致的。说到底我们还是不能保证中间代理和网关等对用户请求处理方式是一致的\n6. OPTIONS：决定（\"决定二字\"如何来理解？）可以在服务器上执行哪些方式，没有实体\nOPTIONS方式是希望服务器告诉我们，我们可以使用哪些方法，或者说对特殊资源支持哪些方法。\t\t\t\n7. DELETE：从服务器上删除一份文档，没有实体\n请求服务器端删除一个资源，但是不能保证这个请求一定会被执行，因为HTTP的规范容许服务器在不通知客户端的情况下撤销请求。\t\t\n8. 扩展方法\nHTTP被设计成字段可拓展的，这样可以向下兼容。但是我并不想看这块。\n\n## 4. 请求的URL简单介绍\nURL提供了统一的资源命名方式：方案：//服务器位置//路径。URL的语法会由于方案的不同而不同,几乎没有哪个URL中包含了所以所有的组件：scheme://user:pwd@host:port/path;params?query#frag\n1. params参数\n一个URL中可以有多个参数，参数为键值对，各个参数之间以及参数与URL其他部分之间用逗号分隔\t\t\n1. query\n查询组件的内容没有通用的格式，用字符“？”将其与URL的其余部分分隔开\n\n##### 4.1 方案：例如HTTP/FTP/SMTP\n方案名不区分大小写,告诉应用程序应该使用什么协议\t\t\n## 5. 版本\n格式类似于HTTP/1.1,HTTP/2.0,是为了服务器和客户端之间相互了解各自的能力和报文的格式。版本号说明了应用程序支持的最高的HTTP版本。版本号不会被当做小数来处理，所以HTTP2.22比HTTP2.3的版本要高，因为22>3\n## 6. 状态码\n状态码配合原因短语一起告诉客户端他的请求处于什么状态,目前有5个种类的状态码\n+ 100~199:信息类状态码(目前实现了2个)\n+ 200~299:成功类状态码(目前实现了7个)\n+ 300~399:重定向类状态码(目前实现了7个)\n+ 400~499:客户端失败状态码(目前实现了18个)\n+ 500~599:服务器端状态码(目前实现了6个)\n\n##### 6.1 信息类状态码\n这类型状态码是http1.1引入的,都比较新也比较受争议,所以目前只实现了2个:\n1. 100 Continue\n说明服务器端已经收到部分请求,请求客户端继续。那么为什么我们需要这个状态码: http客户端应用程序要发给服务器一个实体的主体,但是在发送前想知道服务器端是否接受服务器端只有接受到带有值为100 continue的expires请求头时才会返回100状态码,\n1. 101 switching protocols\n说明服务器根据客户端的请示,将协议切换成update首部所列的协议\n\n##### 6.2 成功类状态码\n目前已经实现了7个(200~206)\n1. 200 OK\n请求没有问题,响应的实体主体部分包含请求的资源\n1. 201 created\n主要用来创建服务器端请求(PUT)\n服务器在返回改状态码前必须已经创建好对象\n响应的主体部分应该包含各组引用了已创建的资源的URL\n1. 202 Accept\n请求已经被接受,但是服务器还未对该请求做任何处理也不能保证服务器能完成这个请求\n返回的实体主体部分包含对该请求的状态描述,或者也可以加上对请求完成时间的估计\n1. 203 None-Authoritative Information\n实体的信息不是来自于服务器端,而是来自于资源的一个副本\n如中间节点上有一份资源副本,但无法或者对发送资源进行验证就可以发送这个状态码\n1. 204 No content\n响应中包含起始行和首部,但是每天实体的主体部分\n主要用于浏览器不转为显示新文档的情况下对其进行更新\n1. 205 Reset content\n也是主要用于浏览器\n用于告知浏览器清空所以得HTML元素\n1. 206 partial content \n成功的执行了一个range请求\n206响应必须包含以下几个响应\n+ Content-range\n+ Date\n+ ETag\n+ Content-Location\n\n##### 6.3 重定向类状态码(目前实现了7个)\n1. 300 Multiple Choice\n请求的url对应多个资源(中文、英文等)会返回该状态码\n服务器可以在响应的location首部给出首选的URL\n1. 301 Moved permanently\n表示请求的资源已经转移\n响应的location头部应该包含资源的新URL\n1. 302 Found\n与301类似,客户端使用响应的location首部来临时定位资源\n以后还是会使用来的URL定位资源\n1. 303 See Other\n告知客户端使用另一个URL来访问资源\n新的URL位于响应的location首部\n主要目的是容许post请求将客户端定位到某个资源上\n讲真,我已经晕了\n1. 304 Not Found\n这个我倒是经常遇到,传说中的条件缓存\n客户端的条件get请求,资源未被修改\n响应的实体不包含主体部分\n1. 305 use proxy\n必须通过代理来访问资源,代理的位置在响应的location首部\n1. 306 未使用\n1. 307 Temporary Redirect\n临时的重定向,类似于301,但响应中给出的是临时的url\n以后还是使用老的url来访问资源\n\n##### 6.4 服务器端错误状态码\n目前实现了6个\n1. 500 Internal server error\n遇到妨碍服务器提供服务的内部错误时返回\n1. 501 Not implemented\n客户端发起的请求超出了服务器的能力范围,例如使用了服务器不支持的方法\n1. 502 bad gateway\n代理在请求的响应链的下一条链时返回一个伪响应(如无法连接父代理)\n测试过程中,测试服务器挂了会报这个错误类型\n1. 503 service unavailable\n表示服务器现在没办法为请求提供服务,但是未来可以\n如果服务器知道什么时候能够用,可以在响应中返回一个包含retry-after首部\n1. 504 gateway timeout \n类似于408,这里的响应来自于网关或者代理\n在等服务器等待请求进行响应时超时了\n1. 505 http version not support\n\n\n\n## 7. 学习时间线\n\n##### 2017-02-27\n\n+ http简介\n+ http报文结构\n+ url\n+ 请求的方法\n\n##### 2017-03-01\n\n+ 状态码 (信息类状态码、成功类状态码、重定向类状态码、服务器端错误状态码)\n\n\n-----\n\n做一个勤于思考的人~\n\n\n","slug":"网络/HTTP简介","published":1,"updated":"2019-03-14T13:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtd0yj3l002n9oxzdkaaskyc","content":"<p>前端工程师在面试过程中不可避免的会被问到是否知道http，讲真，似乎我们没有细究过http也好好的开发了很长一段时间。那为何越是大公司越会很注重你是否了解http呢。<br>站在我们前端开发人员的角度，前后端通信几乎都是基于HTTP的，我们发送http请求，由RD接受请求处理后返回我们需要的资源。我们更深入的了解http到底是为了什么：</p>\n<ul>\n<li><code>更好的定位问题：</code>我们发送一个请求之后，可以根据请求返回的状态码定位这次请求是否成功，如果没有成功是谁的问题</li>\n<li><code>让前后端通信更快更安全：</code>在更深入的了解http请求后，我们就知道http通信的瓶颈在哪，有哪些行为会导致此次通信不安全、如何做可以让通信更快</li>\n<li><code>用更好的方式去沟通：</code>不同的业务场景选用不同的方法沟通不仅仅提高可读性，也可以提高安全性、服务器处理的效率</li>\n<li><code>应付面试：</code>很重要<br>其实主要内容我还是从《HTTP权威指南》上抄的~</li>\n</ul>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>http说的通俗一点，相当于客户端和服务器端的沟通语言。那么http协议简单来说包括哪些内容呢：</p>\n<ol>\n<li>如何沟通：http报文，告诉客户端如何提出要求，服务器端应该怎样分析客户端的请求并给出响应的反应</li>\n<li>沟通的高效性：http缓存、长连接等</li>\n<li>沟通的安全性：https、客户端识别、cookie机制<br>站在前端的角度来讲，我们常用的客户端是浏览器，服务器端可以是任何提供服务一个机器（废话）。</li>\n</ol>\n<h2 id=\"2-如何沟通–http报文结构\"><a href=\"#2-如何沟通–http报文结构\" class=\"headerlink\" title=\"2. 如何沟通–http报文结构\"></a>2. 如何沟通–http报文结构</h2><p>这个部分主要讲解客户端和服务器端应该遵循什么样的规范来沟通。他们都得遵循http报文规范。</p>\n<ul>\n<li>http报文是什么：简单的格式化数据块</li>\n<li><p>http报文包含3个部分</p>\n<ul>\n<li>起始行：对报文进行描述</li>\n<li>首部：包含一些属性</li>\n<li><p>主体（可以没有）：包含数据主体</p>\n<h5 id=\"2-1-请求报文格式\"><a href=\"#2-1-请求报文格式\" class=\"headerlink\" title=\"2.1 请求报文格式\"></a>2.1 请求报文格式</h5><p>method request-url version<br>headers</p>\n<p>entity-body</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-响应报文格式\"><a href=\"#2-2-响应报文格式\" class=\"headerlink\" title=\"2.2 响应报文格式\"></a>2.2 响应报文格式</h5><pre><code>version status reason-phrase\nheaders\n\nentity-body\n</code></pre><h2 id=\"3-method请求的方法\"><a href=\"#3-method请求的方法\" class=\"headerlink\" title=\"3. method请求的方法\"></a>3. method请求的方法</h2><p>HTTP规范总共定义了<strong>7个</strong>请求方法，为了告诉客户端，客户端想要执行什么动作。但不是每个服务器都实现了以下的方法。<strong>HTTP1.1协议要求实现GET和HEAD方法</strong></p>\n<ol>\n<li>GET:从服务器端获取资源，没有实体<br>HTTP1.1要求实现GET方法</li>\n<li>HEAD：从服务器获取资源的首部，没有实体<br>与GET方法很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。HTTP1.1要求实现GET方法。HEAD方法可以用来：        <ul>\n<li>在不获取资源的情况下，知道资源的情况（资源的类型）</li>\n<li>通过查看资源的状态码，了解资源的存在情况</li>\n<li>通过查看首部，看资源是否被修改了        </li>\n</ul>\n</li>\n<li><p>POST：向服务器发送需要处理的数据，<strong>有实体</strong></p>\n</li>\n<li><p>PUT:将请求的主体部分放在服务器上，<strong>有实体</strong><br>PUT请求让服务器用PUT请求带的主体部分来创建一个由它所请求的url命名的新文档，如果文档已经存在，则覆盖它。PUT请求容许用户修改服务器的内容，所以从安全性角度来讲，应该要用户登录。        </p>\n</li>\n<li>TRACE：对可能经过的代理服务器传送到服务器上去的报文进行追踪，没有实体<br>客户端发一个请求到达服务器时，可能会经过很多的代理服务器、防护墙、网关等等，中间每一个环节都有可能改变原来的HTTP请求。TRACE方法，容许客户端在最终发送请求到服务器端时，看看它变成了什么样子。最后一站的服务器会返回一个相关的响应，并在主体中携带上原始的请求报文。        <ul>\n<li>优点：可以用于查看代理和其他的应用程序对用户请求的影响</li>\n<li>缺点：它假定了中间程序对不同方法的请求处理方式是一致的。说到底我们还是不能保证中间代理和网关等对用户请求处理方式是一致的</li>\n</ul>\n</li>\n<li>OPTIONS：决定（”决定二字”如何来理解？）可以在服务器上执行哪些方式，没有实体<br>OPTIONS方式是希望服务器告诉我们，我们可以使用哪些方法，或者说对特殊资源支持哪些方法。            </li>\n<li>DELETE：从服务器上删除一份文档，没有实体<br>请求服务器端删除一个资源，但是不能保证这个请求一定会被执行，因为HTTP的规范容许服务器在不通知客户端的情况下撤销请求。        </li>\n<li>扩展方法<br>HTTP被设计成字段可拓展的，这样可以向下兼容。但是我并不想看这块。</li>\n</ol>\n<h2 id=\"4-请求的URL简单介绍\"><a href=\"#4-请求的URL简单介绍\" class=\"headerlink\" title=\"4. 请求的URL简单介绍\"></a>4. 请求的URL简单介绍</h2><p>URL提供了统一的资源命名方式：方案：//服务器位置//路径。URL的语法会由于方案的不同而不同,几乎没有哪个URL中包含了所以所有的组件：scheme://user:pwd@host:port/path;params?query#frag</p>\n<ol>\n<li>params参数<br>一个URL中可以有多个参数，参数为键值对，各个参数之间以及参数与URL其他部分之间用逗号分隔        </li>\n<li>query<br>查询组件的内容没有通用的格式，用字符“？”将其与URL的其余部分分隔开</li>\n</ol>\n<h5 id=\"4-1-方案：例如HTTP-FTP-SMTP\"><a href=\"#4-1-方案：例如HTTP-FTP-SMTP\" class=\"headerlink\" title=\"4.1 方案：例如HTTP/FTP/SMTP\"></a>4.1 方案：例如HTTP/FTP/SMTP</h5><p>方案名不区分大小写,告诉应用程序应该使用什么协议        </p>\n<h2 id=\"5-版本\"><a href=\"#5-版本\" class=\"headerlink\" title=\"5. 版本\"></a>5. 版本</h2><p>格式类似于HTTP/1.1,HTTP/2.0,是为了服务器和客户端之间相互了解各自的能力和报文的格式。版本号说明了应用程序支持的最高的HTTP版本。版本号不会被当做小数来处理，所以HTTP2.22比HTTP2.3的版本要高，因为22&gt;3</p>\n<h2 id=\"6-状态码\"><a href=\"#6-状态码\" class=\"headerlink\" title=\"6. 状态码\"></a>6. 状态码</h2><p>状态码配合原因短语一起告诉客户端他的请求处于什么状态,目前有5个种类的状态码</p>\n<ul>\n<li>100~199:信息类状态码(目前实现了2个)</li>\n<li>200~299:成功类状态码(目前实现了7个)</li>\n<li>300~399:重定向类状态码(目前实现了7个)</li>\n<li>400~499:客户端失败状态码(目前实现了18个)</li>\n<li>500~599:服务器端状态码(目前实现了6个)</li>\n</ul>\n<h5 id=\"6-1-信息类状态码\"><a href=\"#6-1-信息类状态码\" class=\"headerlink\" title=\"6.1 信息类状态码\"></a>6.1 信息类状态码</h5><p>这类型状态码是http1.1引入的,都比较新也比较受争议,所以目前只实现了2个:</p>\n<ol>\n<li>100 Continue<br>说明服务器端已经收到部分请求,请求客户端继续。那么为什么我们需要这个状态码: http客户端应用程序要发给服务器一个实体的主体,但是在发送前想知道服务器端是否接受服务器端只有接受到带有值为100 continue的expires请求头时才会返回100状态码,</li>\n<li>101 switching protocols<br>说明服务器根据客户端的请示,将协议切换成update首部所列的协议</li>\n</ol>\n<h5 id=\"6-2-成功类状态码\"><a href=\"#6-2-成功类状态码\" class=\"headerlink\" title=\"6.2 成功类状态码\"></a>6.2 成功类状态码</h5><p>目前已经实现了7个(200~206)</p>\n<ol>\n<li>200 OK<br>请求没有问题,响应的实体主体部分包含请求的资源</li>\n<li>201 created<br>主要用来创建服务器端请求(PUT)<br>服务器在返回改状态码前必须已经创建好对象<br>响应的主体部分应该包含各组引用了已创建的资源的URL</li>\n<li>202 Accept<br>请求已经被接受,但是服务器还未对该请求做任何处理也不能保证服务器能完成这个请求<br>返回的实体主体部分包含对该请求的状态描述,或者也可以加上对请求完成时间的估计</li>\n<li>203 None-Authoritative Information<br>实体的信息不是来自于服务器端,而是来自于资源的一个副本<br>如中间节点上有一份资源副本,但无法或者对发送资源进行验证就可以发送这个状态码</li>\n<li>204 No content<br>响应中包含起始行和首部,但是每天实体的主体部分<br>主要用于浏览器不转为显示新文档的情况下对其进行更新</li>\n<li>205 Reset content<br>也是主要用于浏览器<br>用于告知浏览器清空所以得HTML元素</li>\n<li>206 partial content<br>成功的执行了一个range请求<br>206响应必须包含以下几个响应</li>\n</ol>\n<ul>\n<li>Content-range</li>\n<li>Date</li>\n<li>ETag</li>\n<li>Content-Location</li>\n</ul>\n<h5 id=\"6-3-重定向类状态码-目前实现了7个\"><a href=\"#6-3-重定向类状态码-目前实现了7个\" class=\"headerlink\" title=\"6.3 重定向类状态码(目前实现了7个)\"></a>6.3 重定向类状态码(目前实现了7个)</h5><ol>\n<li>300 Multiple Choice<br>请求的url对应多个资源(中文、英文等)会返回该状态码<br>服务器可以在响应的location首部给出首选的URL</li>\n<li>301 Moved permanently<br>表示请求的资源已经转移<br>响应的location头部应该包含资源的新URL</li>\n<li>302 Found<br>与301类似,客户端使用响应的location首部来临时定位资源<br>以后还是会使用来的URL定位资源</li>\n<li>303 See Other<br>告知客户端使用另一个URL来访问资源<br>新的URL位于响应的location首部<br>主要目的是容许post请求将客户端定位到某个资源上<br>讲真,我已经晕了</li>\n<li>304 Not Found<br>这个我倒是经常遇到,传说中的条件缓存<br>客户端的条件get请求,资源未被修改<br>响应的实体不包含主体部分</li>\n<li>305 use proxy<br>必须通过代理来访问资源,代理的位置在响应的location首部</li>\n<li>306 未使用</li>\n<li>307 Temporary Redirect<br>临时的重定向,类似于301,但响应中给出的是临时的url<br>以后还是使用老的url来访问资源</li>\n</ol>\n<h5 id=\"6-4-服务器端错误状态码\"><a href=\"#6-4-服务器端错误状态码\" class=\"headerlink\" title=\"6.4 服务器端错误状态码\"></a>6.4 服务器端错误状态码</h5><p>目前实现了6个</p>\n<ol>\n<li>500 Internal server error<br>遇到妨碍服务器提供服务的内部错误时返回</li>\n<li>501 Not implemented<br>客户端发起的请求超出了服务器的能力范围,例如使用了服务器不支持的方法</li>\n<li>502 bad gateway<br>代理在请求的响应链的下一条链时返回一个伪响应(如无法连接父代理)<br>测试过程中,测试服务器挂了会报这个错误类型</li>\n<li>503 service unavailable<br>表示服务器现在没办法为请求提供服务,但是未来可以<br>如果服务器知道什么时候能够用,可以在响应中返回一个包含retry-after首部</li>\n<li>504 gateway timeout<br>类似于408,这里的响应来自于网关或者代理<br>在等服务器等待请求进行响应时超时了</li>\n<li>505 http version not support</li>\n</ol>\n<h2 id=\"7-学习时间线\"><a href=\"#7-学习时间线\" class=\"headerlink\" title=\"7. 学习时间线\"></a>7. 学习时间线</h2><h5 id=\"2017-02-27\"><a href=\"#2017-02-27\" class=\"headerlink\" title=\"2017-02-27\"></a>2017-02-27</h5><ul>\n<li>http简介</li>\n<li>http报文结构</li>\n<li>url</li>\n<li>请求的方法</li>\n</ul>\n<h5 id=\"2017-03-01\"><a href=\"#2017-03-01\" class=\"headerlink\" title=\"2017-03-01\"></a>2017-03-01</h5><ul>\n<li>状态码 (信息类状态码、成功类状态码、重定向类状态码、服务器端错误状态码)</li>\n</ul>\n<hr>\n<p>做一个勤于思考的人~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前端工程师在面试过程中不可避免的会被问到是否知道http，讲真，似乎我们没有细究过http也好好的开发了很长一段时间。那为何越是大公司越会很注重你是否了解http呢。<br>站在我们前端开发人员的角度，前后端通信几乎都是基于HTTP的，我们发送http请求，由RD接受请求处理后返回我们需要的资源。我们更深入的了解http到底是为了什么：</p>\n<ul>\n<li><code>更好的定位问题：</code>我们发送一个请求之后，可以根据请求返回的状态码定位这次请求是否成功，如果没有成功是谁的问题</li>\n<li><code>让前后端通信更快更安全：</code>在更深入的了解http请求后，我们就知道http通信的瓶颈在哪，有哪些行为会导致此次通信不安全、如何做可以让通信更快</li>\n<li><code>用更好的方式去沟通：</code>不同的业务场景选用不同的方法沟通不仅仅提高可读性，也可以提高安全性、服务器处理的效率</li>\n<li><code>应付面试：</code>很重要<br>其实主要内容我还是从《HTTP权威指南》上抄的~</li>\n</ul>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>http说的通俗一点，相当于客户端和服务器端的沟通语言。那么http协议简单来说包括哪些内容呢：</p>\n<ol>\n<li>如何沟通：http报文，告诉客户端如何提出要求，服务器端应该怎样分析客户端的请求并给出响应的反应</li>\n<li>沟通的高效性：http缓存、长连接等</li>\n<li>沟通的安全性：https、客户端识别、cookie机制<br>站在前端的角度来讲，我们常用的客户端是浏览器，服务器端可以是任何提供服务一个机器（废话）。</li>\n</ol>\n<h2 id=\"2-如何沟通–http报文结构\"><a href=\"#2-如何沟通–http报文结构\" class=\"headerlink\" title=\"2. 如何沟通–http报文结构\"></a>2. 如何沟通–http报文结构</h2><p>这个部分主要讲解客户端和服务器端应该遵循什么样的规范来沟通。他们都得遵循http报文规范。</p>\n<ul>\n<li>http报文是什么：简单的格式化数据块</li>\n<li><p>http报文包含3个部分</p>\n<ul>\n<li>起始行：对报文进行描述</li>\n<li>首部：包含一些属性</li>\n<li><p>主体（可以没有）：包含数据主体</p>\n<h5 id=\"2-1-请求报文格式\"><a href=\"#2-1-请求报文格式\" class=\"headerlink\" title=\"2.1 请求报文格式\"></a>2.1 请求报文格式</h5><p>method request-url version<br>headers</p>\n<p>entity-body</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-响应报文格式\"><a href=\"#2-2-响应报文格式\" class=\"headerlink\" title=\"2.2 响应报文格式\"></a>2.2 响应报文格式</h5><pre><code>version status reason-phrase\nheaders\n\nentity-body\n</code></pre><h2 id=\"3-method请求的方法\"><a href=\"#3-method请求的方法\" class=\"headerlink\" title=\"3. method请求的方法\"></a>3. method请求的方法</h2><p>HTTP规范总共定义了<strong>7个</strong>请求方法，为了告诉客户端，客户端想要执行什么动作。但不是每个服务器都实现了以下的方法。<strong>HTTP1.1协议要求实现GET和HEAD方法</strong></p>\n<ol>\n<li>GET:从服务器端获取资源，没有实体<br>HTTP1.1要求实现GET方法</li>\n<li>HEAD：从服务器获取资源的首部，没有实体<br>与GET方法很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。HTTP1.1要求实现GET方法。HEAD方法可以用来：        <ul>\n<li>在不获取资源的情况下，知道资源的情况（资源的类型）</li>\n<li>通过查看资源的状态码，了解资源的存在情况</li>\n<li>通过查看首部，看资源是否被修改了        </li>\n</ul>\n</li>\n<li><p>POST：向服务器发送需要处理的数据，<strong>有实体</strong></p>\n</li>\n<li><p>PUT:将请求的主体部分放在服务器上，<strong>有实体</strong><br>PUT请求让服务器用PUT请求带的主体部分来创建一个由它所请求的url命名的新文档，如果文档已经存在，则覆盖它。PUT请求容许用户修改服务器的内容，所以从安全性角度来讲，应该要用户登录。        </p>\n</li>\n<li>TRACE：对可能经过的代理服务器传送到服务器上去的报文进行追踪，没有实体<br>客户端发一个请求到达服务器时，可能会经过很多的代理服务器、防护墙、网关等等，中间每一个环节都有可能改变原来的HTTP请求。TRACE方法，容许客户端在最终发送请求到服务器端时，看看它变成了什么样子。最后一站的服务器会返回一个相关的响应，并在主体中携带上原始的请求报文。        <ul>\n<li>优点：可以用于查看代理和其他的应用程序对用户请求的影响</li>\n<li>缺点：它假定了中间程序对不同方法的请求处理方式是一致的。说到底我们还是不能保证中间代理和网关等对用户请求处理方式是一致的</li>\n</ul>\n</li>\n<li>OPTIONS：决定（”决定二字”如何来理解？）可以在服务器上执行哪些方式，没有实体<br>OPTIONS方式是希望服务器告诉我们，我们可以使用哪些方法，或者说对特殊资源支持哪些方法。            </li>\n<li>DELETE：从服务器上删除一份文档，没有实体<br>请求服务器端删除一个资源，但是不能保证这个请求一定会被执行，因为HTTP的规范容许服务器在不通知客户端的情况下撤销请求。        </li>\n<li>扩展方法<br>HTTP被设计成字段可拓展的，这样可以向下兼容。但是我并不想看这块。</li>\n</ol>\n<h2 id=\"4-请求的URL简单介绍\"><a href=\"#4-请求的URL简单介绍\" class=\"headerlink\" title=\"4. 请求的URL简单介绍\"></a>4. 请求的URL简单介绍</h2><p>URL提供了统一的资源命名方式：方案：//服务器位置//路径。URL的语法会由于方案的不同而不同,几乎没有哪个URL中包含了所以所有的组件：scheme://user:pwd@host:port/path;params?query#frag</p>\n<ol>\n<li>params参数<br>一个URL中可以有多个参数，参数为键值对，各个参数之间以及参数与URL其他部分之间用逗号分隔        </li>\n<li>query<br>查询组件的内容没有通用的格式，用字符“？”将其与URL的其余部分分隔开</li>\n</ol>\n<h5 id=\"4-1-方案：例如HTTP-FTP-SMTP\"><a href=\"#4-1-方案：例如HTTP-FTP-SMTP\" class=\"headerlink\" title=\"4.1 方案：例如HTTP/FTP/SMTP\"></a>4.1 方案：例如HTTP/FTP/SMTP</h5><p>方案名不区分大小写,告诉应用程序应该使用什么协议        </p>\n<h2 id=\"5-版本\"><a href=\"#5-版本\" class=\"headerlink\" title=\"5. 版本\"></a>5. 版本</h2><p>格式类似于HTTP/1.1,HTTP/2.0,是为了服务器和客户端之间相互了解各自的能力和报文的格式。版本号说明了应用程序支持的最高的HTTP版本。版本号不会被当做小数来处理，所以HTTP2.22比HTTP2.3的版本要高，因为22&gt;3</p>\n<h2 id=\"6-状态码\"><a href=\"#6-状态码\" class=\"headerlink\" title=\"6. 状态码\"></a>6. 状态码</h2><p>状态码配合原因短语一起告诉客户端他的请求处于什么状态,目前有5个种类的状态码</p>\n<ul>\n<li>100~199:信息类状态码(目前实现了2个)</li>\n<li>200~299:成功类状态码(目前实现了7个)</li>\n<li>300~399:重定向类状态码(目前实现了7个)</li>\n<li>400~499:客户端失败状态码(目前实现了18个)</li>\n<li>500~599:服务器端状态码(目前实现了6个)</li>\n</ul>\n<h5 id=\"6-1-信息类状态码\"><a href=\"#6-1-信息类状态码\" class=\"headerlink\" title=\"6.1 信息类状态码\"></a>6.1 信息类状态码</h5><p>这类型状态码是http1.1引入的,都比较新也比较受争议,所以目前只实现了2个:</p>\n<ol>\n<li>100 Continue<br>说明服务器端已经收到部分请求,请求客户端继续。那么为什么我们需要这个状态码: http客户端应用程序要发给服务器一个实体的主体,但是在发送前想知道服务器端是否接受服务器端只有接受到带有值为100 continue的expires请求头时才会返回100状态码,</li>\n<li>101 switching protocols<br>说明服务器根据客户端的请示,将协议切换成update首部所列的协议</li>\n</ol>\n<h5 id=\"6-2-成功类状态码\"><a href=\"#6-2-成功类状态码\" class=\"headerlink\" title=\"6.2 成功类状态码\"></a>6.2 成功类状态码</h5><p>目前已经实现了7个(200~206)</p>\n<ol>\n<li>200 OK<br>请求没有问题,响应的实体主体部分包含请求的资源</li>\n<li>201 created<br>主要用来创建服务器端请求(PUT)<br>服务器在返回改状态码前必须已经创建好对象<br>响应的主体部分应该包含各组引用了已创建的资源的URL</li>\n<li>202 Accept<br>请求已经被接受,但是服务器还未对该请求做任何处理也不能保证服务器能完成这个请求<br>返回的实体主体部分包含对该请求的状态描述,或者也可以加上对请求完成时间的估计</li>\n<li>203 None-Authoritative Information<br>实体的信息不是来自于服务器端,而是来自于资源的一个副本<br>如中间节点上有一份资源副本,但无法或者对发送资源进行验证就可以发送这个状态码</li>\n<li>204 No content<br>响应中包含起始行和首部,但是每天实体的主体部分<br>主要用于浏览器不转为显示新文档的情况下对其进行更新</li>\n<li>205 Reset content<br>也是主要用于浏览器<br>用于告知浏览器清空所以得HTML元素</li>\n<li>206 partial content<br>成功的执行了一个range请求<br>206响应必须包含以下几个响应</li>\n</ol>\n<ul>\n<li>Content-range</li>\n<li>Date</li>\n<li>ETag</li>\n<li>Content-Location</li>\n</ul>\n<h5 id=\"6-3-重定向类状态码-目前实现了7个\"><a href=\"#6-3-重定向类状态码-目前实现了7个\" class=\"headerlink\" title=\"6.3 重定向类状态码(目前实现了7个)\"></a>6.3 重定向类状态码(目前实现了7个)</h5><ol>\n<li>300 Multiple Choice<br>请求的url对应多个资源(中文、英文等)会返回该状态码<br>服务器可以在响应的location首部给出首选的URL</li>\n<li>301 Moved permanently<br>表示请求的资源已经转移<br>响应的location头部应该包含资源的新URL</li>\n<li>302 Found<br>与301类似,客户端使用响应的location首部来临时定位资源<br>以后还是会使用来的URL定位资源</li>\n<li>303 See Other<br>告知客户端使用另一个URL来访问资源<br>新的URL位于响应的location首部<br>主要目的是容许post请求将客户端定位到某个资源上<br>讲真,我已经晕了</li>\n<li>304 Not Found<br>这个我倒是经常遇到,传说中的条件缓存<br>客户端的条件get请求,资源未被修改<br>响应的实体不包含主体部分</li>\n<li>305 use proxy<br>必须通过代理来访问资源,代理的位置在响应的location首部</li>\n<li>306 未使用</li>\n<li>307 Temporary Redirect<br>临时的重定向,类似于301,但响应中给出的是临时的url<br>以后还是使用老的url来访问资源</li>\n</ol>\n<h5 id=\"6-4-服务器端错误状态码\"><a href=\"#6-4-服务器端错误状态码\" class=\"headerlink\" title=\"6.4 服务器端错误状态码\"></a>6.4 服务器端错误状态码</h5><p>目前实现了6个</p>\n<ol>\n<li>500 Internal server error<br>遇到妨碍服务器提供服务的内部错误时返回</li>\n<li>501 Not implemented<br>客户端发起的请求超出了服务器的能力范围,例如使用了服务器不支持的方法</li>\n<li>502 bad gateway<br>代理在请求的响应链的下一条链时返回一个伪响应(如无法连接父代理)<br>测试过程中,测试服务器挂了会报这个错误类型</li>\n<li>503 service unavailable<br>表示服务器现在没办法为请求提供服务,但是未来可以<br>如果服务器知道什么时候能够用,可以在响应中返回一个包含retry-after首部</li>\n<li>504 gateway timeout<br>类似于408,这里的响应来自于网关或者代理<br>在等服务器等待请求进行响应时超时了</li>\n<li>505 http version not support</li>\n</ol>\n<h2 id=\"7-学习时间线\"><a href=\"#7-学习时间线\" class=\"headerlink\" title=\"7. 学习时间线\"></a>7. 学习时间线</h2><h5 id=\"2017-02-27\"><a href=\"#2017-02-27\" class=\"headerlink\" title=\"2017-02-27\"></a>2017-02-27</h5><ul>\n<li>http简介</li>\n<li>http报文结构</li>\n<li>url</li>\n<li>请求的方法</li>\n</ul>\n<h5 id=\"2017-03-01\"><a href=\"#2017-03-01\" class=\"headerlink\" title=\"2017-03-01\"></a>2017-03-01</h5><ul>\n<li>状态码 (信息类状态码、成功类状态码、重定向类状态码、服务器端错误状态码)</li>\n</ul>\n<hr>\n<p>做一个勤于思考的人~</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjtd0yj2e00049oxzqm8rz85l","category_id":"cjtd0yj2j00069oxzykb16gbr","_id":"cjtd0yj2x000f9oxzodgq9322"},{"post_id":"cjtd0yj2h00059oxzdan7ma8i","category_id":"cjtd0yj2o000b9oxznc1mmxch","_id":"cjtd0yj2z000k9oxzq09npsr1"},{"post_id":"cjtd0yj2l00089oxzszpe5stv","category_id":"cjtd0yj2x000g9oxzix4mh9ru","_id":"cjtd0yj33000r9oxz5knivq7c"},{"post_id":"cjtd0yj2m00099oxz5e57vzh6","category_id":"cjtd0yj2x000g9oxzix4mh9ru","_id":"cjtd0yj34000u9oxziz88ozig"},{"post_id":"cjtd0yj2n000a9oxzy1we6l0t","category_id":"cjtd0yj33000q9oxzl7krug0c","_id":"cjtd0yj35000y9oxzjv3hzok7"},{"post_id":"cjtd0yj2s000d9oxz7ez4pnrw","category_id":"cjtd0yj33000q9oxzl7krug0c","_id":"cjtd0yj3500109oxz71xjb1jd"},{"post_id":"cjtd0yj2v000e9oxz0cq4kk35","category_id":"cjtd0yj34000x9oxzimb1xjt1","_id":"cjtd0yj3600149oxz16dknghp"},{"post_id":"cjtd0yj2x000i9oxzr5nqemmc","category_id":"cjtd0yj3500119oxz9vn4jv1f","_id":"cjtd0yj37001a9oxz04f6z2dz"},{"post_id":"cjtd0yj2z000j9oxz7uyyug5m","category_id":"cjtd0yj3600169oxzrzg4yato","_id":"cjtd0yj38001d9oxzun4jp8dx"},{"post_id":"cjtd0yj31000n9oxz4otq9hal","category_id":"cjtd0yj37001c9oxzew4y4tcp","_id":"cjtd0yj38001f9oxz3vjmxcve"},{"post_id":"cjtd0yj3i002g9oxz17asaaxb","category_id":"cjtd0yj3j002h9oxzz7uveq8k","_id":"cjtd0yj3k002l9oxzoo43m9kc"},{"post_id":"cjtd0yj3l002n9oxzdkaaskyc","category_id":"cjtd0yj3m002o9oxzagj30h2z","_id":"cjtd0yj3n002s9oxz80szbcvv"}],"PostTag":[{"post_id":"cjtd0yj2e00049oxzqm8rz85l","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj32000o9oxz65ehyqyx"},{"post_id":"cjtd0yj2e00049oxzqm8rz85l","tag_id":"cjtd0yj2o000c9oxzsfqbjiar","_id":"cjtd0yj33000p9oxzpk1ciz6i"},{"post_id":"cjtd0yj2e00049oxzqm8rz85l","tag_id":"cjtd0yj2x000h9oxzhjg2wq10","_id":"cjtd0yj34000t9oxzugaimc0i"},{"post_id":"cjtd0yj2h00059oxzdan7ma8i","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3600139oxzn9thszwp"},{"post_id":"cjtd0yj2h00059oxzdan7ma8i","tag_id":"cjtd0yj33000s9oxzcj4rhm2c","_id":"cjtd0yj3600159oxz54p5ecqs"},{"post_id":"cjtd0yj2h00059oxzdan7ma8i","tag_id":"cjtd0yj34000w9oxzuzdcizg6","_id":"cjtd0yj3700189oxzj4t6xc6w"},{"post_id":"cjtd0yj2h00059oxzdan7ma8i","tag_id":"cjtd0yj35000z9oxzc85mq2pk","_id":"cjtd0yj3700199oxzsjj36nzp"},{"post_id":"cjtd0yj2l00089oxzszpe5stv","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj39001h9oxz1qbernhd"},{"post_id":"cjtd0yj2l00089oxzszpe5stv","tag_id":"cjtd0yj2o000c9oxzsfqbjiar","_id":"cjtd0yj39001i9oxzcynfvgex"},{"post_id":"cjtd0yj2l00089oxzszpe5stv","tag_id":"cjtd0yj37001b9oxz4nflgug6","_id":"cjtd0yj39001k9oxz14eq5ic7"},{"post_id":"cjtd0yj2l00089oxzszpe5stv","tag_id":"cjtd0yj38001e9oxz95hgdcee","_id":"cjtd0yj39001l9oxzu2p30kup"},{"post_id":"cjtd0yj2m00099oxz5e57vzh6","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3a001n9oxzjh5rbb4s"},{"post_id":"cjtd0yj2m00099oxz5e57vzh6","tag_id":"cjtd0yj2o000c9oxzsfqbjiar","_id":"cjtd0yj3a001o9oxz87rtlpgk"},{"post_id":"cjtd0yj2m00099oxz5e57vzh6","tag_id":"cjtd0yj37001b9oxz4nflgug6","_id":"cjtd0yj3a001q9oxz34gin5fb"},{"post_id":"cjtd0yj2n000a9oxzy1we6l0t","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3b001r9oxzvyhep6ln"},{"post_id":"cjtd0yj2n000a9oxzy1we6l0t","tag_id":"cjtd0yj2o000c9oxzsfqbjiar","_id":"cjtd0yj3b001t9oxza2ro5870"},{"post_id":"cjtd0yj2s000d9oxz7ez4pnrw","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3d001v9oxz3ct5uyrs"},{"post_id":"cjtd0yj2s000d9oxz7ez4pnrw","tag_id":"cjtd0yj3a001p9oxzcw9lv6bl","_id":"cjtd0yj3e001w9oxzyldy7nut"},{"post_id":"cjtd0yj2s000d9oxz7ez4pnrw","tag_id":"cjtd0yj3b001s9oxzyq460egg","_id":"cjtd0yj3e001y9oxzs411lq42"},{"post_id":"cjtd0yj2v000e9oxz0cq4kk35","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3e00209oxz1qzb110n"},{"post_id":"cjtd0yj2v000e9oxz0cq4kk35","tag_id":"cjtd0yj2o000c9oxzsfqbjiar","_id":"cjtd0yj3e00219oxzlfwi20qa"},{"post_id":"cjtd0yj2v000e9oxz0cq4kk35","tag_id":"cjtd0yj3c001u9oxzm9j9da0c","_id":"cjtd0yj3f00239oxz8bq0g9ym"},{"post_id":"cjtd0yj2v000e9oxz0cq4kk35","tag_id":"cjtd0yj3e001x9oxz5db7tzjt","_id":"cjtd0yj3f00249oxzqv4av6kv"},{"post_id":"cjtd0yj2x000i9oxzr5nqemmc","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3f00269oxzvmy0m1gf"},{"post_id":"cjtd0yj2x000i9oxzr5nqemmc","tag_id":"cjtd0yj3e001z9oxz1j2sedoj","_id":"cjtd0yj3f00279oxz95dbtwmc"},{"post_id":"cjtd0yj2z000j9oxz7uyyug5m","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3g00299oxzkt5tfytg"},{"post_id":"cjtd0yj2z000j9oxz7uyyug5m","tag_id":"cjtd0yj3e001z9oxz1j2sedoj","_id":"cjtd0yj3g002a9oxz8pnpn7hd"},{"post_id":"cjtd0yj2z000j9oxz7uyyug5m","tag_id":"cjtd0yj3f00259oxz0ibvurq3","_id":"cjtd0yj3g002c9oxzw4k1atpz"},{"post_id":"cjtd0yj31000n9oxz4otq9hal","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3g002d9oxzzh4v507h"},{"post_id":"cjtd0yj31000n9oxz4otq9hal","tag_id":"cjtd0yj3f00289oxzlotgdr8f","_id":"cjtd0yj3g002e9oxz6o4ez8qn"},{"post_id":"cjtd0yj31000n9oxz4otq9hal","tag_id":"cjtd0yj3g002b9oxzpfzq7cy0","_id":"cjtd0yj3g002f9oxzoftvn08x"},{"post_id":"cjtd0yj3i002g9oxz17asaaxb","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3k002j9oxzk3p1ekmk"},{"post_id":"cjtd0yj3i002g9oxz17asaaxb","tag_id":"cjtd0yj2o000c9oxzsfqbjiar","_id":"cjtd0yj3k002k9oxzakpa1tzk"},{"post_id":"cjtd0yj3i002g9oxz17asaaxb","tag_id":"cjtd0yj3j002i9oxz8byclss4","_id":"cjtd0yj3k002m9oxzptqomrvb"},{"post_id":"cjtd0yj3l002n9oxzdkaaskyc","tag_id":"cjtd0yj2k00079oxzattol83i","_id":"cjtd0yj3n002q9oxzvg5okpx9"},{"post_id":"cjtd0yj3l002n9oxzdkaaskyc","tag_id":"cjtd0yj3m002p9oxzynhhnn1b","_id":"cjtd0yj3n002r9oxz7n1nq10d"}],"Tag":[{"name":"前端开发","_id":"cjtd0yj2k00079oxzattol83i"},{"name":"个人成长","_id":"cjtd0yj2o000c9oxzsfqbjiar"},{"name":"CSS","_id":"cjtd0yj2x000h9oxzhjg2wq10"},{"name":"js实现对象的深度克隆","_id":"cjtd0yj33000s9oxzcj4rhm2c"},{"name":"javascript","_id":"cjtd0yj34000w9oxzuzdcizg6"},{"name":"深度克隆","_id":"cjtd0yj35000z9oxzc85mq2pk"},{"name":"JS","_id":"cjtd0yj37001b9oxz4nflgug6"},{"name":"继承","_id":"cjtd0yj38001e9oxz95hgdcee"},{"name":"前端资料总结","_id":"cjtd0yj3a001p9oxzcw9lv6bl"},{"name":"JavaScript、HTML、CSS、Node","_id":"cjtd0yj3b001s9oxzyq460egg"},{"name":"其他","_id":"cjtd0yj3c001u9oxzm9j9da0c"},{"name":"自动化构建","_id":"cjtd0yj3e001x9oxz5db7tzjt"},{"name":"前端面试题","_id":"cjtd0yj3e001z9oxz1j2sedoj"},{"name":"HTML5简介","_id":"cjtd0yj3f00259oxz0ibvurq3"},{"name":"代码版本控制","_id":"cjtd0yj3f00289oxzlotgdr8f"},{"name":"git","_id":"cjtd0yj3g002b9oxzpfzq7cy0"},{"name":"前端性能优化","_id":"cjtd0yj3j002i9oxz8byclss4"},{"name":"HTTP学习总结","_id":"cjtd0yj3m002p9oxzynhhnn1b"}]}}