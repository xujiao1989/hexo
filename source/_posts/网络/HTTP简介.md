---
title: HTTP学习总结
date: 2017-02-22
tags:
  - 前端开发
  - HTTP学习总结
categories: 网络
---

前端工程师在面试过程中不可避免的会被问到是否知道http，讲真，似乎我们没有细究过http也好好的开发了很长一段时间。那为何越是大公司越会很注重你是否了解http呢。
站在我们前端开发人员的角度，前后端通信几乎都是基于HTTP的，我们发送http请求，由RD接受请求处理后返回我们需要的资源。我们更深入的了解http到底是为了什么：
+ `更好的定位问题：`我们发送一个请求之后，可以根据请求返回的状态码定位这次请求是否成功，如果没有成功是谁的问题
+ `让前后端通信更快更安全：`在更深入的了解http请求后，我们就知道http通信的瓶颈在哪，有哪些行为会导致此次通信不安全、如何做可以让通信更快
+ `用更好的方式去沟通：`不同的业务场景选用不同的方法沟通不仅仅提高可读性，也可以提高安全性、服务器处理的效率
+ `应付面试：`很重要
其实主要内容我还是从《HTTP权威指南》上抄的~

## 简介
http说的通俗一点，相当于客户端和服务器端的沟通语言。那么http协议简单来说包括哪些内容呢：
1. 如何沟通：http报文，告诉客户端如何提出要求，服务器端应该怎样分析客户端的请求并给出响应的反应
1. 沟通的高效性：http缓存、长连接等
1. 沟通的安全性：https、客户端识别、cookie机制
站在前端的角度来讲，我们常用的客户端是浏览器，服务器端可以是任何提供服务一个机器（废话）。

## 如何沟通--http报文结构
这个部分主要讲解客户端和服务器端应该遵循什么样的规范来沟通。他们都得遵循http报文规范。
+ http报文是什么：简单的格式化数据块
+ http报文包含3个部分
	+ 起始行：对报文进行描述
	+ 首部：包含一些属性
	+ 主体（可以没有）：包含数据主体
##### 请求报文格式
	  method request-url version
	  headers
	  
	  entity-body
	  
##### 响应报文格式
    version status reason-phrase
    headers
    
    entity-body
    
## method请求的方法
HTTP规范总共定义了**7个**请求方法，为了告诉客户端，客户端想要执行什么动作。但不是每个服务器都实现了以下的方法。**HTTP1.1协议要求实现GET和HEAD方法**
1. GET:从服务器端获取资源，没有实体
HTTP1.1要求实现GET方法
2. HEAD：从服务器获取资源的首部，没有实体
与GET方法很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。HTTP1.1要求实现GET方法。HEAD方法可以用来：		
    + 在不获取资源的情况下，知道资源的情况（资源的类型）
    + 通过查看资源的状态码，了解资源的存在情况
    + 通过查看首部，看资源是否被修改了		
3. POST：向服务器发送需要处理的数据，**有实体**
			
4. PUT:将请求的主体部分放在服务器上，**有实体**
PUT请求让服务器用PUT请求带的主体部分来创建一个由它所请求的url命名的新文档，如果文档已经存在，则覆盖它。PUT请求容许用户修改服务器的内容，所以从安全性角度来讲，应该要用户登录。		
5. TRACE：对可能经过的代理服务器传送到服务器上去的报文进行追踪，没有实体
客户端发一个请求到达服务器时，可能会经过很多的代理服务器、防护墙、网关等等，中间每一个环节都有可能改变原来的HTTP请求。TRACE方法，容许客户端在最终发送请求到服务器端时，看看它变成了什么样子。最后一站的服务器会返回一个相关的响应，并在主体中携带上原始的请求报文。		
    + 优点：可以用于查看代理和其他的应用程序对用户请求的影响
    + 缺点：它假定了中间程序对不同方法的请求处理方式是一致的。说到底我们还是不能保证中间代理和网关等对用户请求处理方式是一致的
6. OPTIONS：决定（"决定二字"如何来理解？）可以在服务器上执行哪些方式，没有实体
OPTIONS方式是希望服务器告诉我们，我们可以使用哪些方法，或者说对特殊资源支持哪些方法。			
7. DELETE：从服务器上删除一份文档，没有实体
请求服务器端删除一个资源，但是不能保证这个请求一定会被执行，因为HTTP的规范容许服务器在不通知客户端的情况下撤销请求。		
8. 扩展方法
HTTP被设计成字段可拓展的，这样可以向下兼容。但是我并不想看这块。

## 请求的URL简单介绍
URL提供了统一的资源命名方式：方案：//服务器位置//路径。URL的语法会由于方案的不同而不同,几乎没有哪个URL中包含了所以所有的组件：scheme://user:pwd@host:port/path;params?query#frag
1. params参数
一个URL中可以有多个参数，参数为键值对，各个参数之间以及参数与URL其他部分之间用逗号分隔		
1. query
查询组件的内容没有通用的格式，用字符“？”将其与URL的其余部分分隔开

##### 方案：例如HTTP/FTP/SMTP
方案名不区分大小写,告诉应用程序应该使用什么协议		
## 版本
格式类似于HTTP/1.1,HTTP/2.0,是为了服务器和客户端之间相互了解各自的能力和报文的格式。版本号说明了应用程序支持的最高的HTTP版本。版本号不会被当做小数来处理，所以HTTP2.22比HTTP2.3的版本要高，因为22>3
## 状态码
状态码配合原因短语一起告诉客户端他的请求处于什么状态,目前有5个种类的状态码
+ 100~199:信息类状态码(目前实现了2个)
+ 200~299:成功类状态码(目前实现了7个)
+ 300~399:重定向类状态码(目前实现了7个)
+ 400~499:客户端失败状态码(目前实现了18个)
+ 500~599:服务器端状态码(目前实现了6个)

##### 信息类状态码
这类型状态码是http1.1引入的,都比较新也比较受争议,所以目前只实现了2个:
1. 100 Continue
说明服务器端已经收到部分请求,请求客户端继续。那么为什么我们需要这个状态码: http客户端应用程序要发给服务器一个实体的主体,但是在发送前想知道服务器端是否接受服务器端只有接受到带有值为100 continue的expires请求头时才会返回100状态码,
1. 101 switching protocols
说明服务器根据客户端的请示,将协议切换成update首部所列的协议

##### 成功类状态码
目前已经实现了7个(200~206)
1. 200 OK
请求没有问题,响应的实体主体部分包含请求的资源
1. 201 created
主要用来创建服务器端请求(PUT)
服务器在返回改状态码前必须已经创建好对象
响应的主体部分应该包含各组引用了已创建的资源的URL
1. 202 Accept
请求已经被接受,但是服务器还未对该请求做任何处理也不能保证服务器能完成这个请求
返回的实体主体部分包含对该请求的状态描述,或者也可以加上对请求完成时间的估计
1. 203 None-Authoritative Information
实体的信息不是来自于服务器端,而是来自于资源的一个副本
如中间节点上有一份资源副本,但无法或者对发送资源进行验证就可以发送这个状态码
1. 204 No content
响应中包含起始行和首部,但是每天实体的主体部分
主要用于浏览器不转为显示新文档的情况下对其进行更新
1. 205 Reset content
也是主要用于浏览器
用于告知浏览器清空所以得HTML元素
1. 206 partial content 
成功的执行了一个range请求
206响应必须包含以下几个响应
+ Content-range
+ Date
+ ETag
+ Content-Location

##### 重定向类状态码(目前实现了7个)
1. 300 Multiple Choice
请求的url对应多个资源(中文、英文等)会返回该状态码
服务器可以在响应的location首部给出首选的URL
1. 301 Moved permanently
表示请求的资源已经转移
响应的location头部应该包含资源的新URL
1. 302 Found
与301类似,客户端使用响应的location首部来临时定位资源
以后还是会使用来的URL定位资源
1. 303 See Other
告知客户端使用另一个URL来访问资源
新的URL位于响应的location首部
主要目的是容许post请求将客户端定位到某个资源上
讲真,我已经晕了
1. 304 Not Found
这个我倒是经常遇到,传说中的条件缓存
客户端的条件get请求,资源未被修改
响应的实体不包含主体部分
1. 305 use proxy
必须通过代理来访问资源,代理的位置在响应的location首部
1. 306 未使用
1. 307 Temporary Redirect
临时的重定向,类似于301,但响应中给出的是临时的url
以后还是使用老的url来访问资源

##### 服务器端错误状态码
目前实现了6个
1. 500 Internal server error
遇到妨碍服务器提供服务的内部错误时返回
1. 501 Not implemented
客户端发起的请求超出了服务器的能力范围,例如使用了服务器不支持的方法
1. 502 bad gateway
代理在请求的响应链的下一条链时返回一个伪响应(如无法连接父代理)
测试过程中,测试服务器挂了会报这个错误类型
1. 503 service unavailable
表示服务器现在没办法为请求提供服务,但是未来可以
如果服务器知道什么时候能够用,可以在响应中返回一个包含retry-after首部
1. 504 gateway timeout 
类似于408,这里的响应来自于网关或者代理
在等服务器等待请求进行响应时超时了
1. 505 http version not support



## 学习时间线

##### 2017-02-27

+ http简介
+ http报文结构
+ url
+ 请求的方法

##### 2017-03-01

+ 状态码 (信息类状态码、成功类状态码、重定向类状态码、服务器端错误状态码)


## 鸡汤

做一个勤于思考的人~


